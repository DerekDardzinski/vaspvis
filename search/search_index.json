{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"VaspVis","text":""},{"location":"#installation","title":"Installation","text":"<p>Currently VaspVis is available via pip and can be installed using:</p> <pre><code>pip install vaspvis\n</code></pre>"},{"location":"band/","title":"Band Structure","text":""},{"location":"band/#bandpy","title":"band.py","text":""},{"location":"band/#vaspvis.band.Band","title":"<code>Band</code>","text":"<p>This class contains all the methods for constructing band structures from the outputs of VASP band structure calculations.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>projected</code> <code>bool</code> <p>Determines whether of not to parse the projected eigenvalues from the PROCAR file. Making this true increases the computational time, so only use if a projected band structure is required.</p> <code>False</code> <code>spin</code> <code>str</code> <p>Choose which spin direction to parse. ('up' or 'down')</p> <code>'up'</code> <code>kpath</code> <code>str</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automaticall converted to \\Gamma)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry point. This is also only required for unfolded calculations. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> Source code in <code>vaspvis/band.py</code> <pre><code>class Band:\n    \"\"\"\n    This class contains all the methods for constructing band structures\n    from the outputs of VASP band structure calculations.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        projected (bool): Determines whether of not to parse the projected\n            eigenvalues from the PROCAR file. Making this true\n            increases the computational time, so only use if a projected\n            band structure is required.\n        spin (str): Choose which spin direction to parse. ('up' or 'down')\n        kpath (str): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automaticall converted to \\\\Gamma)\n        n (int): Number of points between each high symmetry point.\n            This is also only required for unfolded calculations. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n    \"\"\"\n\n    def __init__(\n        self,\n        folder,\n        projected=False,\n        unfold=False,\n        spin=\"up\",\n        kpath=None,\n        n=None,\n        M=None,\n        high_symm_points=None,\n        # bandgap=False,\n        # printbg=True,\n        shift_efermi=0,\n        interpolate=True,\n        new_n=200,\n        custom_kpath=None,\n        soc_axis=None,\n        stretch_factor=1.0,\n    ):\n        \"\"\"\n        Initialize parameters upon the generation of this class\n\n        Parameters:\n            folder (str): This is the folder that contains the VASP files\n            projected (bool): Determines whether of not to parse the projected\n                eigenvalues from the PROCAR file. Making this true\n                increases the computational time, so only use if a projected\n                band structure is required.\n            unfold (bool): Determines if the band structure should be unfolded or not.\n            spin (str): Choose which spin direction to parse. ('up' or 'down')\n            kpath (str): High symmetry k-point path of band structure calculation\n                Due to the nature of the KPOINTS file for unfolded calculations this\n                information is a required input for proper labeling of the figure\n                for unfolded calculations. This information is extracted from the KPOINTS\n                files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            n (int): Number of points between each high symmetry point.\n                This is also only required for unfolded calculations. This number should be\n                known by the user, as it was used to generate the KPOINTS file.\n            M (list[list]): Transformation matrix for unfolding calculations. Can be found using\n                the conver_slab function in the utils module.\n            high_symm_points (list[list]): Coordinates of the high symmetry points of the bulk\n                Brilloin zone for an unfolded calculation.\n            shift_efermi (float): Gives the option to shift the fermi energy by the specified value\n            interpolate (bool): Determines is the data between each high symmetry point should be\n                interpolated or not.\n            new_n (int): New number of k-points in between each high symmetry point.\n            custom_kpath (list): Custom kpath that can be selected is the user desires.\n                Given a path G-X-W-L-G-K then there are 5 segements to choose from\n                [1 -&gt; G-X, 2 -&gt; X-W, 3 -&gt; W-L, 4 -&gt; L-G, 5 -&gt; G-K]. If a user wanted to\n                plot only the path G-X-W they can set custom_kpath=[1,2]. If a user wanted\n                to flip the k-path of a segment, then the index should be made negative, so\n                if the desired path was G-X|L-W then custom_kpath=[1,-3]\n            soc_axis (None or str): This parameter can either take the value of None or the\n                it can take the value of 'x', 'y', or 'z'. If either 'x', 'y', or 'z' are given\n                then spin='up' states will be defined by positive values of this spin-component\n                and spin='down' states will be defined by negative values of this spin-component.\n                This will only be used for showing a pseudo-spin-polarized plot for calculations\n                that have SOC enabled.\n            stretch_factor (float): Used to scale the eigenvalues by a certain constant. Useful for comparing to ARPES data.\n                Default is scale_factor = 1.0 (i.e. no scaling)\n        \"\"\"\n        self.interpolate = interpolate\n        self.soc_axis = soc_axis\n        self.new_n = new_n\n        self.stretch_factor = stretch_factor\n        # self.bandgap = bandgap\n        # self.printbg = printbg\n        self.eigenval = Eigenval(os.path.join(folder, \"EIGENVAL\"))\n        self.efermi = (\n            float(\n                os.popen(f'grep E-fermi {os.path.join(folder, \"OUTCAR\")}')\n                .read()\n                .split()[2]\n            )\n            + shift_efermi\n        )\n        self.poscar = Poscar.from_file(\n            os.path.join(folder, \"POSCAR\"),\n            check_for_POTCAR=False,\n            read_velocities=False,\n        )\n        self.incar = Incar.from_file(os.path.join(folder, \"INCAR\"))\n        if \"LSORBIT\" in self.incar:\n            if self.incar[\"LSORBIT\"]:\n                self.lsorbit = True\n            else:\n                self.lsorbit = False\n        else:\n            self.lsorbit = False\n\n        if \"ISPIN\" in self.incar:\n            if self.incar[\"ISPIN\"] == 2:\n                self.ispin = True\n            else:\n                self.ispin = False\n        else:\n            self.ispin = False\n\n        if \"LHFCALC\" in self.incar:\n            if self.incar[\"LHFCALC\"]:\n                self.hse = True\n            else:\n                self.hse = False\n        else:\n            self.hse = False\n\n        self.kpoints_file = Kpoints.from_file(os.path.join(folder, \"KPOINTS\"))\n\n        self.wavecar = os.path.join(folder, \"WAVECAR\")\n        self.projected = projected\n\n        self.forbitals = self._check_f_orb()\n        self.unfold = unfold\n\n        if self.hse and self.unfold:\n            self.hse = False\n\n        self.kpath = kpath\n        self.n = n\n        self.M = M\n        self.high_symm_points = high_symm_points\n        self.folder = folder\n        self.spin = spin\n        self.spin_dict = {\"up\": Spin.up, \"down\": Spin.down}\n        if not self.unfold:\n            self.pre_loaded_bands = os.path.isfile(\n                os.path.join(folder, \"eigenvalues.npy\")\n            )\n            self.eigenvalues, self.kpoints = self._load_bands()\n        else:\n            self.pre_loaded_bands = os.path.isfile(\n                os.path.join(folder, \"unfolded_eigenvalues.npy\")\n            )\n            (\n                self.eigenvalues,\n                self.spectral_weights,\n                self.K_indices,\n                self.kpoints,\n            ) = self._load_bands_unfold()\n\n        if self.stretch_factor != 1.0:\n            self.eigenvalues *= self.stretch_factor\n\n        self.color_dict = {\n            0: \"#FF0000\",\n            1: \"#0000FF\",\n            2: \"#008000\",\n            3: \"#800080\",\n            4: \"#E09200\",\n            5: \"#FF5C77\",\n            6: \"#778392\",\n            7: \"#07C589\",\n            8: \"#40BAF2\",\n            9: \"#FF0000\",\n            10: \"#0000FF\",\n            11: \"#008000\",\n            12: \"#800080\",\n            13: \"#E09200\",\n            14: \"#FF5C77\",\n            15: \"#778392\",\n        }\n        self.orbital_labels = {\n            0: \"s\",\n            1: \"p_{y}\",\n            2: \"p_{z}\",\n            3: \"p_{x}\",\n            4: \"d_{xy}\",\n            5: \"d_{yz}\",\n            6: \"d_{z^{2}}\",\n            7: \"d_{xz}\",\n            8: \"d_{x^{2}-y^{2}}\",\n            9: \"f_{y^{3}x^{2}}\",\n            10: \"f_{xyz}\",\n            11: \"f_{yz^{2}}\",\n            12: \"f_{z^{3}}\",\n            13: \"f_{xz^{2}}\",\n            14: \"f_{zx^{3}}\",\n            15: \"f_{x^{3}}\",\n        }\n        self.spd_relations = {\n            \"s\": 0,\n            \"p\": 1,\n            \"d\": 2,\n            \"f\": 3,\n        }\n        # if self.bandgap:\n        #     self.bg = self._get_bandgap()\n        # else:\n        #     self.bg = None\n\n        self.custom_kpath = custom_kpath\n        if self.custom_kpath is not None:\n            (\n                self.custom_kpath_inds,\n                self.custom_kpath_flip,\n            ) = self._get_custom_kpath()\n        #  else:\n        #  self.custom_kpath_inds, self.custom_kpath_flip = None, None\n\n        if projected:\n            self.pre_loaded_projections = os.path.isfile(\n                os.path.join(folder, \"projected_eigenvalues.npy\")\n            )\n            self.projected_eigenvalues = self._load_projected_bands()\n\n        if soc_axis is not None and self.lsorbit:\n            self.pre_loaded_spin_projections = os.path.isfile(\n                os.path.join(folder, \"spin_projections.npy\")\n            )\n            self.spin_projections = self._load_soc_spin_projection()\n\n    def _get_custom_kpath(self):\n        flip = (-np.sign(self.custom_kpath) + 1).astype(bool)\n        inds = (np.abs(self.custom_kpath) - 1).astype(int)\n\n        return inds, flip\n\n    # def _get_bandgap(self):\n    #     from vaspvis.utils import BandGap\n    #     self.bg = BandGap(\n    #         folder=self.folder,\n    #         printbg=self.printbg,\n    #     )\n\n    def _check_f_orb(self):\n        f_elements = [\n            \"La\",\n            \"Ac\",\n            \"Ce\",\n            \"Tb\",\n            \"Th\",\n            \"Pr\",\n            \"Dy\",\n            \"Pa\",\n            \"Nd\",\n            \"Ho\",\n            \"U\",\n            \"Pm\",\n            \"Er\",\n            \"Np\",\n            \"Sm\",\n            \"Tm\",\n            \"Pu\",\n            \"Eu\",\n            \"Yb\",\n            \"Am\",\n            \"Gd\",\n            \"Lu\",\n        ]\n        f = False\n        for element in self.poscar.site_symbols:\n            if element in f_elements:\n                f = True\n\n        return f\n\n    def _load_bands(self):\n        \"\"\"\n        This function is used to load eigenvalues from the vasprun.xml\n        file and into a dictionary which is in the form of\n        band index --&gt; eigenvalues\n\n        Returns:\n            bands_dict (dict[str][np.ndarray]): Dictionary which contains\n                the eigenvalues for each band\n        \"\"\"\n\n        if self.spin == \"up\":\n            spin = 0\n        if self.spin == \"down\":\n            spin = 1\n\n        if self.pre_loaded_bands:\n            with open(\n                os.path.join(self.folder, \"eigenvalues.npy\"), \"rb\"\n            ) as eigenvals:\n                band_data = np.load(eigenvals)\n\n            if self.ispin and not self.lsorbit:\n                eigenvalues = band_data[:, :, [0, 2]]\n                kpoints = band_data[0, :, 4:]\n            else:\n                eigenvalues = band_data[:, :, 0]\n                kpoints = band_data[0, :, 2:]\n        else:\n            if len(self.eigenval.eigenvalues.keys()) &gt; 1:\n                eigenvalues_up = np.transpose(\n                    self.eigenval.eigenvalues[Spin.up], axes=(1, 0, 2)\n                )\n                eigenvalues_down = np.transpose(\n                    self.eigenval.eigenvalues[Spin.down], axes=(1, 0, 2)\n                )\n                eigenvalues_up[:, :, 0] = eigenvalues_up[:, :, 0] - self.efermi\n                eigenvalues_down[:, :, 0] = (\n                    eigenvalues_down[:, :, 0] - self.efermi\n                )\n                eigenvalues = np.concatenate(\n                    [eigenvalues_up, eigenvalues_down], axis=2\n                )\n            else:\n                eigenvalues = np.transpose(\n                    self.eigenval.eigenvalues[Spin.up], axes=(1, 0, 2)\n                )\n                eigenvalues[:, :, 0] = eigenvalues[:, :, 0] - self.efermi\n\n            kpoints = np.array(self.eigenval.kpoints)\n\n            if self.hse:\n                kpoint_weights = np.array(self.eigenval.kpoints_weights)\n                zero_weight = np.where(kpoint_weights == 0)[0]\n                eigenvalues = eigenvalues[:, zero_weight]\n                kpoints = kpoints[zero_weight]\n\n            band_data = np.append(\n                eigenvalues,\n                np.tile(kpoints, (eigenvalues.shape[0], 1, 1)),\n                axis=2,\n            )\n\n            np.save(os.path.join(self.folder, \"eigenvalues.npy\"), band_data)\n\n            if len(self.eigenval.eigenvalues.keys()) &gt; 1:\n                eigenvalues = eigenvalues[:, :, [0, 2]]\n            else:\n                eigenvalues = eigenvalues[:, :, 0]\n\n        if len(self.eigenval.eigenvalues.keys()) &gt; 1:\n            eigenvalues = eigenvalues[:, :, spin]\n\n        return eigenvalues, kpoints\n\n    def _load_bands_unfold(self):\n        if self.spin == \"up\":\n            spin = 0\n        if self.spin == \"down\":\n            if self.lsorbit:\n                spin = 0\n            else:\n                spin = 1\n\n        kpath = make_kpath(self.high_symm_points, nseg=self.n)\n\n        if self.pre_loaded_bands:\n            with open(\n                os.path.join(self.folder, \"unfolded_eigenvalues.npy\"), \"rb\"\n            ) as eigenvals:\n                band_data = np.load(eigenvals)\n        else:\n            wavecar_data = unfold(\n                M=self.M,\n                wavecar=self.wavecar,\n                lsorbit=self.lsorbit,\n            )\n            band_data = wavecar_data.spectral_weight(kpath)\n            np.save(\n                os.path.join(self.folder, \"unfolded_eigenvalues.npy\"),\n                band_data,\n            )\n\n        band_data = np.transpose(band_data[spin], axes=(2, 1, 0))\n        eigenvalues, spectral_weights, K_indices = band_data\n        eigenvalues = eigenvalues - self.efermi\n        kpath = np.array(kpath)\n\n        path_len = len(self.kpath)\n        n = self.n\n        inserts = [n * (i + 1) for i in range(path_len - 1)]\n        inds = list(range(n * path_len + 1))\n        for i in reversed(inserts):\n            inds.insert(i, i)\n\n        kpath = kpath[inds]\n        spectral_weights = spectral_weights[:, inds]\n        K_indices = K_indices[:, inds]\n        eigenvalues = eigenvalues[:, inds]\n\n        return eigenvalues, spectral_weights, K_indices, kpath\n\n    def _load_projected_bands(self):\n        \"\"\"\n        This function loads the project weights of the orbitals in each band\n        from vasprun.xml into a dictionary of the form:\n        band index --&gt; atom index --&gt; weights of orbitals\n\n        Returns:\n            projected_dict (dict([str][int][pd.DataFrame])): Dictionary containing the projected weights of all orbitals on each atom for each band.\n        \"\"\"\n\n        if self.lsorbit:\n            if self.soc_axis is None:\n                spin = 0\n            elif self.soc_axis == \"x\":\n                spin = 1\n            elif self.soc_axis == \"y\":\n                spin = 2\n            elif self.soc_axis == \"z\":\n                spin = 3\n        else:\n            if self.spin == \"up\":\n                spin = 0\n            elif self.spin == \"down\":\n                spin = 1\n\n        if not os.path.isfile(os.path.join(self.folder, \"PROCAR_repaired\")):\n            UtilsProcar().ProcarRepair(\n                os.path.join(self.folder, \"PROCAR\"),\n                os.path.join(self.folder, \"PROCAR_repaired\"),\n            )\n\n        if self.pre_loaded_projections:\n            with open(\n                os.path.join(self.folder, \"projected_eigenvalues.npy\"), \"rb\"\n            ) as projected_eigenvals:\n                projected_eigenvalues = np.load(projected_eigenvals)\n        else:\n            parser = ProcarParser()\n            parser.readFile(os.path.join(self.folder, \"PROCAR_repaired\"))\n            if (\n                self.ispin\n                and not self.lsorbit\n                and np.sum(self.poscar.natoms) == 1\n            ):\n                shape = int(parser.spd.shape[1] / 2)\n                projected_eigenvalues_up = np.transpose(\n                    parser.spd[:, :shape, 0, :, 1:-1], axes=(1, 0, 2, 3)\n                )\n                projected_eigenvalues_down = np.transpose(\n                    parser.spd[:, shape:, 0, :, 1:-1], axes=(1, 0, 2, 3)\n                )\n                projected_eigenvalues = np.concatenate(\n                    [\n                        projected_eigenvalues_up[:, :, :, :, np.newaxis],\n                        projected_eigenvalues_down[:, :, :, :, np.newaxis],\n                    ],\n                    axis=4,\n                )\n                projected_eigenvalues = np.transpose(\n                    projected_eigenvalues, axes=(0, 1, 4, 2, 3)\n                )\n            elif (\n                self.ispin\n                and not self.lsorbit\n                and np.sum(self.poscar.natoms) != 1\n            ):\n                shape = int(parser.spd.shape[1] / 2)\n                projected_eigenvalues_up = np.transpose(\n                    parser.spd[:, :shape, 0, :-1, 1:-1], axes=(1, 0, 2, 3)\n                )\n                projected_eigenvalues_down = np.transpose(\n                    parser.spd[:, shape:, 0, :-1, 1:-1], axes=(1, 0, 2, 3)\n                )\n                projected_eigenvalues = np.concatenate(\n                    [\n                        projected_eigenvalues_up[:, :, :, :, np.newaxis],\n                        projected_eigenvalues_down[:, :, :, :, np.newaxis],\n                    ],\n                    axis=4,\n                )\n                projected_eigenvalues = np.transpose(\n                    projected_eigenvalues, axes=(0, 1, 4, 2, 3)\n                )\n            else:\n                if np.sum(self.poscar.natoms) == 1:\n                    projected_eigenvalues = np.transpose(\n                        parser.spd[:, :, :, :, 1:-1], axes=(1, 0, 2, 3, 4)\n                    )\n                else:\n                    projected_eigenvalues = np.transpose(\n                        parser.spd[:, :, :, :-1, 1:-1], axes=(1, 0, 2, 3, 4)\n                    )\n\n            np.save(\n                os.path.join(self.folder, \"projected_eigenvalues.npy\"),\n                projected_eigenvalues,\n            )\n\n        projected_eigenvalues = projected_eigenvalues[:, :, spin, :, :]\n\n        if self.lsorbit and self.soc_axis is not None:\n            separated_projections = np.zeros(\n                projected_eigenvalues.shape + (2,)\n            )\n            separated_projections[\n                projected_eigenvalues &gt; 0, 0\n            ] = projected_eigenvalues[projected_eigenvalues &gt; 0]\n            separated_projections[\n                projected_eigenvalues &lt; 0, 1\n            ] = -projected_eigenvalues[projected_eigenvalues &lt; 0]\n\n            if self.spin == \"up\":\n                soc_spin = 0\n            elif self.spin == \"down\":\n                soc_spin = 1\n\n            projected_eigenvalues = separated_projections[..., soc_spin]\n\n        if self.hse:\n            kpoint_weights = np.array(self.eigenval.kpoints_weights)\n            zero_weight = np.where(kpoint_weights == 0)[0]\n            projected_eigenvalues = projected_eigenvalues[:, zero_weight]\n\n        projected_eigenvalues = np.square(projected_eigenvalues)\n\n        return projected_eigenvalues\n\n    def _load_soc_spin_projection(self):\n        \"\"\"\n        This function loads the project weights of the orbitals in each band\n        from vasprun.xml into a dictionary of the form:\n        band index --&gt; atom index --&gt; weights of orbitals\n\n        Returns:\n            projected_dict (dict([str][int][pd.DataFrame])): Dictionary containing the projected weights of all orbitals on each atom for each band.\n        \"\"\"\n\n        if not self.lsorbit:\n            raise BaseException(\n                f\"You selected soc_axis='{self.soc_axis}' for a non-soc axis calculation, please set soc_axis=None\"\n            )\n        if self.lsorbit and self.soc_axis == \"x\":\n            spin = 1\n        if self.lsorbit and self.soc_axis == \"y\":\n            spin = 2\n        if self.lsorbit and self.soc_axis == \"z\":\n            spin = 3\n\n        if not os.path.isfile(os.path.join(self.folder, \"PROCAR_repaired\")):\n            UtilsProcar().ProcarRepair(\n                os.path.join(self.folder, \"PROCAR\"),\n                os.path.join(self.folder, \"PROCAR_repaired\"),\n            )\n\n        if self.pre_loaded_spin_projections:\n            with open(\n                os.path.join(self.folder, \"spin_projections.npy\"), \"rb\"\n            ) as spin_projs:\n                spin_projections = np.load(spin_projs)\n        else:\n            parser = ProcarParser()\n            parser.readFile(os.path.join(self.folder, \"PROCAR_repaired\"))\n            spin_projections = np.transpose(\n                parser.spd[:, :, :, -1, -1], axes=(1, 0, 2)\n            )\n\n            np.save(\n                os.path.join(self.folder, \"spin_projections.npy\"),\n                spin_projections,\n            )\n\n        spin_projections = spin_projections[:, :, spin]\n\n        if self.hse:\n            kpoint_weights = np.array(self.eigenval.kpoints_weights)\n            zero_weight = np.where(kpoint_weights == 0)[0]\n            spin_projections = spin_projections[:, zero_weight]\n\n        separated_projections = np.zeros(\n            (spin_projections.shape[0], spin_projections.shape[1], 2)\n        )\n        separated_projections[spin_projections &gt; 0, 0] = spin_projections[\n            spin_projections &gt; 0\n        ]\n        separated_projections[spin_projections &lt; 0, 1] = -spin_projections[\n            spin_projections &lt; 0\n        ]\n\n        separated_projections = (\n            separated_projections / separated_projections.max()\n        )\n\n        if self.spin == \"up\":\n            separated_projections = separated_projections[:, :, 0]\n        elif self.spin == \"down\":\n            separated_projections = separated_projections[:, :, 1]\n        else:\n            raise BaseException(\n                \"The soc_axis feature does not work with spin='both'\"\n            )\n\n        return separated_projections\n\n    def _sum_spd(self, spd):\n        \"\"\"\n        This function sums the weights of the s, p, and d orbitals for each atom\n        and creates a dictionary of the form:\n        band index --&gt; s,p,d orbital weights\n\n        Returns:\n            spd_dict (dict([str][pd.DataFrame])): Dictionary that contains the summed weights for the s, p, and d orbitals for each band\n        \"\"\"\n\n        if not self.forbitals:\n            spd_indices = [\n                np.array([False for _ in range(9)]) for i in range(3)\n            ]\n            spd_indices[0][0] = True\n            spd_indices[1][1:4] = True\n            spd_indices[2][4:] = True\n        else:\n            spd_indices = [\n                np.array([False for _ in range(16)]) for i in range(4)\n            ]\n            spd_indices[0][0] = True\n            spd_indices[1][1:4] = True\n            spd_indices[2][4:9] = True\n            spd_indices[3][9:] = True\n\n        orbital_contributions = np.sum(self.projected_eigenvalues, axis=2)\n\n        spd_contributions = np.transpose(\n            np.array(\n                [\n                    np.sum(orbital_contributions[:, :, ind], axis=2)\n                    for ind in spd_indices\n                ]\n            ),\n            axes=[1, 2, 0],\n        )\n\n        #  norm_term = np.sum(spd_contributions, axis=2)[:,:,np.newaxis]\n        #  spd_contributions = np.divide(spd_contributions, norm_term, out=np.zeros_like(spd_contributions), where=norm_term!=0)\n\n        spd_contributions = spd_contributions[\n            :, :, [self.spd_relations[orb] for orb in spd]\n        ]\n\n        return spd_contributions\n\n    def _sum_orbitals(self, orbitals):\n        \"\"\"\n        This function finds the weights of desired orbitals for all atoms and\n            returns a dictionary of the form:\n            band index --&gt; orbital index\n\n        Parameters:\n            orbitals (list): List of desired orbitals.\n                0 = s\n                1 = py\n                2 = pz\n                3 = px\n                4 = dxy\n                5 = dyz\n                6 = dz2\n                7 = dxz\n                8 = dx2-y2\n                9 = fy3x2\n                10 = fxyz\n                11 = fyz2\n                12 = fz3\n                13 = fxz2\n                14 = fzx3\n                15 = fx3\n\n        Returns:\n            orbital_dict (dict[str][pd.DataFrame]): Dictionary that contains the projected weights of the selected orbitals.\n        \"\"\"\n        orbital_contributions = self.projected_eigenvalues.sum(axis=2)\n        #  norm_term =  np.sum(orbital_contributions, axis=2)[:,:,np.newaxis]\n        #  orbital_contributions = np.divide(orbital_contributions, norm_term, out=np.zeros_like(orbital_contributions), where=norm_term!=0)\n        orbital_contributions = orbital_contributions[:, :, [orbitals]]\n\n        return orbital_contributions\n\n    def _sum_atoms(self, atoms, spd=False):\n        \"\"\"\n        This function finds the weights of desired atoms for all orbitals and\n            returns a dictionary of the form:\n            band index --&gt; atom index\n\n        Parameters:\n            atoms (list): List of desired atoms where atom 0 is the first atom in\n                the POSCAR file.\n\n        Returns:\n            atom_dict (dict[str][pd.DataFrame]): Dictionary that contains the projected\n                weights of the selected atoms.\n        \"\"\"\n\n        if spd:\n            if not self.forbitals:\n                spd_indices = [\n                    np.array([False for _ in range(9)]) for i in range(3)\n                ]\n                spd_indices[0][0] = True\n                spd_indices[1][1:4] = True\n                spd_indices[2][4:] = True\n            else:\n                spd_indices = [\n                    np.array([False for _ in range(16)]) for i in range(4)\n                ]\n                spd_indices[0][0] = True\n                spd_indices[1][1:4] = True\n                spd_indices[2][4:9] = True\n                spd_indices[3][9:] = True\n\n            atoms_spd = np.transpose(\n                np.array(\n                    [\n                        np.sum(\n                            self.projected_eigenvalues[:, :, :, ind], axis=3\n                        )\n                        for ind in spd_indices\n                    ]\n                ),\n                axes=(1, 2, 3, 0),\n            )\n\n            #  atoms_spd = atoms_spd[:,:,[atoms], :]\n\n            #  norm_term = np.sum(atoms_spd_to_norm, axis=(2,3))[:,:, np.newaxis]\n            #  atoms_spd = np.divide(atoms_spd, norm_term, out=np.zeros_like(atoms_spd), where=norm_term!=0)\n\n            return atoms_spd\n        else:\n            atoms_array = self.projected_eigenvalues.sum(axis=3)\n            #  norm_term = np.sum(atoms_array, axis=2)[:,:,np.newaxis]\n            #  atoms_array = np.divide(atoms_array, norm_term, out=np.zeros_like(atoms_array), where=norm_term!=0)\n            atoms_array = atoms_array[:, :, [atoms]]\n\n            return atoms_array\n\n    def _sum_elements(\n        self, elements, orbitals=False, spd=False, spd_options=None\n    ):\n        \"\"\"\n        This function sums the weights of the orbitals of specific elements within the\n        calculated structure and returns a dictionary of the form:\n        band index --&gt; element label --&gt; orbital weights for orbitals = True\n        band index --&gt; element label for orbitals = False\n        This is useful for structures with many elements because manually entering indicies is\n        not practical for large structures.\n\n        Parameters:\n            elements (list): List of element symbols to sum the weights of.\n            orbitals (bool): Determines whether or not to inclue orbitals or not\n                (True = keep orbitals, False = sum orbitals together )\n            spd (bool): Determines whether or not to sum the s, p, and d orbitals\n\n\n        Returns:\n            element_dict (dict([str][str][pd.DataFrame])): Dictionary that contains the summed weights for each orbital for a given element in the structure.\n        \"\"\"\n\n        poscar = self.poscar\n        natoms = poscar.natoms\n        symbols = poscar.site_symbols\n        projected_eigenvalues = self.projected_eigenvalues\n\n        element_list = np.hstack(\n            [\n                [symbols[i] for j in range(natoms[i])]\n                for i in range(len(symbols))\n            ]\n        )\n\n        element_indices = [\n            np.where(np.isin(element_list, element))[0] for element in elements\n        ]\n\n        element_orbitals = np.transpose(\n            np.array(\n                [\n                    np.sum(projected_eigenvalues[:, :, ind, :], axis=2)\n                    for ind in element_indices\n                ]\n            ),\n            axes=(1, 2, 0, 3),\n        )\n\n        if orbitals:\n            return element_orbitals\n        elif spd:\n            if not self.forbitals:\n                spd_indices = [\n                    np.array([False for _ in range(9)]) for i in range(3)\n                ]\n                spd_indices[0][0] = True\n                spd_indices[1][1:4] = True\n                spd_indices[2][4:] = True\n            else:\n                spd_indices = [\n                    np.array([False for _ in range(16)]) for i in range(4)\n                ]\n                spd_indices[0][0] = True\n                spd_indices[1][1:4] = True\n                spd_indices[2][4:9] = True\n                spd_indices[3][9:] = True\n\n            element_spd = np.transpose(\n                np.array(\n                    [\n                        np.sum(element_orbitals[:, :, :, ind], axis=3)\n                        for ind in spd_indices\n                    ]\n                ),\n                axes=(1, 2, 3, 0),\n            )\n\n            #  norm_term = np.sum(element_spd, axis=(2,3))[:,:,np.newaxis, np.newaxis]\n            #  element_spd = np.divide(element_spd, norm_term, out=np.zeros_like(element_spd), where=norm_term!=0)\n\n            return element_spd\n        else:\n            element_array = np.sum(element_orbitals, axis=3)\n            #  norm_term = np.sum(element_array, axis=2)[:,:,np.newaxis]\n            #  element_array = np.divide(element_array, norm_term, out=np.zeros_like(element_array), where=norm_term!=0)\n\n            return element_array\n\n    def _get_k_distance_old(self):\n        cell = self.poscar.structure.lattice.matrix\n        kpt_c = np.dot(self.kpoints, np.linalg.inv(cell).T)\n        kdist = np.r_[\n            0, np.cumsum(np.linalg.norm(np.diff(kpt_c, axis=0), axis=1))\n        ]\n\n        return kdist\n\n    def _get_k_distance(self):\n        slices = self._get_slices(unfold=self.unfold, hse=self.hse)\n        kdists = []\n\n        if self.custom_kpath is not None:\n            #  if self.custom_kpath is None:\n            index = self.custom_kpath_inds\n        else:\n            index = range(len(slices))\n\n        for j, i in enumerate(index):\n            inv_cell = deepcopy(self.poscar.structure.lattice.inv_matrix)\n            inv_cell_norms = np.linalg.norm(inv_cell, axis=1)\n            inv_cell /= inv_cell_norms.min()\n\n            # If you want to be able to compare only identical relative cell lengths\n            kpt_c = np.dot(self.kpoints[slices[i]], inv_cell.T)\n\n            # If you want to be able to compare any cell length. Maybe straining an orthorhombic cell or something like that\n            # This will mess up relative distances though\n            # kpt_c = self.kpoints[slices[i]]\n            kdist = np.r_[\n                0, np.cumsum(np.linalg.norm(np.diff(kpt_c, axis=0), axis=1))\n            ]\n            if j == 0:\n                kdists.append(kdist)\n            else:\n                kdists.append(kdist + kdists[-1][-1])\n\n        # kdists = np.array(kdists)\n\n        return kdists\n\n    def _get_kticks(self, ax, wave_vectors, vlinecolor):\n        \"\"\"\n        This function extracts the kpoint labels and index locations for a regular\n        band structure calculation (non unfolded).\n\n        Parameters:\n            ax (matplotlib.pyplot.axis): Axis to append the tick labels\n        \"\"\"\n\n        high_sym_points = self.kpoints_file.kpts\n\n        segements = []\n        for i in range(0, len(high_sym_points) - 1):\n            if not i % 2:\n                segements.append([i, i + 1])\n\n        if self.custom_kpath is not None:\n            high_sym_points_inds = []\n            for i, b in zip(self.custom_kpath_inds, self.custom_kpath_flip):\n                if b:\n                    seg = list(reversed(segements[i]))\n                else:\n                    seg = segements[i]\n\n                high_sym_points_inds.extend(seg)\n        else:\n            high_sym_points_inds = list(range(len(high_sym_points)))\n\n        num_kpts = self.kpoints_file.num_kpts\n        kpts_labels = np.array(\n            [\n                f\"${k}$\" if k != \"G\" else \"$\\\\Gamma$\"\n                for k in self.kpoints_file.labels\n            ]\n        )\n        all_kpoints = self.kpoints\n\n        group_index = []\n        for i, j in enumerate(high_sym_points_inds):\n            if i == 0:\n                group_index.append([j])\n            if i % 2 and not i == len(high_sym_points_inds) - 1:\n                group_index.append([j, high_sym_points_inds[i + 1]])\n            if i == len(high_sym_points_inds) - 1:\n                group_index.append([j])\n\n        labels = []\n        index = []\n\n        for i in group_index:\n            if len(i) == 1:\n                labels.append(kpts_labels[i[0]])\n                index.append(i[0])\n            else:\n                if kpts_labels[i[0]] == kpts_labels[i[1]]:\n                    labels.append(kpts_labels[i[0]])\n                    index.append(i[0])\n                else:\n                    merged_label = \"|\".join(\n                        [\n                            kpts_labels[i[0]],\n                            kpts_labels[i[1]],\n                        ]\n                    ).replace(\"$|$\", \"|\")\n                    labels.append(merged_label)\n                    index.append(i[0])\n\n        kpoints_index = [0] + [\n            (i + 1) * num_kpts - 1\n            for i in range(int((len(high_sym_points_inds) + 1) / 2))\n        ]\n\n        for k in kpoints_index:\n            ax.axvline(\n                x=wave_vectors[k], color=vlinecolor, alpha=0.7, linewidth=0.5\n            )\n\n        ax.set_xticks([wave_vectors[k] for k in kpoints_index])\n        ax.set_xticklabels(labels)\n\n    def _get_kticks_hse(self, wave_vectors, ax, kpath, vlinecolor):\n        structure = self.poscar.structure\n        kpath_obj = HighSymmKpath(structure)\n        kpath_labels = np.array(list(kpath_obj._kpath[\"kpoints\"].keys()))\n        kpath_coords = np.array(list(kpath_obj._kpath[\"kpoints\"].values()))\n        index = np.where(\n            np.isclose(\n                self.kpoints[:, None],\n                kpath_coords,\n            )\n            .all(-1)\n            .any(-1)\n            == True\n        )[0]\n\n        segements = []\n        for i in range(0, len(index) - 1):\n            if not i % 2:\n                segements.append([index[i], index[i + 1]])\n\n        if self.custom_kpath is not None:\n            high_sym_points_inds = []\n            for i, b in zip(self.custom_kpath_inds, self.custom_kpath_flip):\n                if b:\n                    seg = list(reversed(segements[i]))\n                else:\n                    seg = segements[i]\n\n                high_sym_points_inds.extend(seg)\n        else:\n            high_sym_points_inds = list(np.concatenate(segements))\n\n        full_segments = []\n        for i in range(0, len(high_sym_points_inds) - 1):\n            if not i % 2:\n                full_segments.append(\n                    [high_sym_points_inds[i], high_sym_points_inds[i + 1]]\n                )\n\n        segment_lengths = [np.abs(i[1] - i[0]) + 1 for i in full_segments]\n        kpoints_index = [0] + [\n            np.sum(segment_lengths[:i])\n            for i in range(1, len(segment_lengths) + 1)\n        ]\n        kpoints_index[-1] -= 1\n\n        group_index = []\n        for i, j in enumerate(high_sym_points_inds):\n            if i == 0:\n                group_index.append([j])\n            if i % 2 and not i == len(high_sym_points_inds) - 1:\n                group_index.append([j, high_sym_points_inds[i + 1]])\n            if i == len(high_sym_points_inds) - 1:\n                group_index.append([j])\n\n        kpoints_in_band = []\n        for group in group_index:\n            g = [self.kpoints[g] for g in group]\n            kpoints_in_band.append(g)\n\n        group_labels = []\n        for kpoints in kpoints_in_band:\n            group = []\n            for k in kpoints:\n                for i, coords in enumerate(kpath_coords):\n                    if (np.round(k, 5) == np.round(coords, 5)).all():\n                        group.append(kpath_labels[i])\n            group_labels.append(group)\n\n        labels = []\n        index = []\n\n        for label in group_labels:\n            if len(label) == 1:\n                labels.append(label[0])\n            else:\n                if label[0] == label[1]:\n                    labels.append(label[0])\n                else:\n                    merged_label = \"|\".join(\n                        [\n                            label[0],\n                            label[1],\n                        ]\n                    ).replace(\"$|$\", \"|\")\n                    labels.append(merged_label)\n\n        kpath = [f\"${k}$\" if k != \"G\" else \"$\\\\Gamma$\" for k in labels]\n\n        for k in kpoints_index:\n            ax.axvline(\n                x=wave_vectors[k], color=vlinecolor, alpha=0.7, linewidth=0.5\n            )\n\n        ax.set_xticks([wave_vectors[k] for k in kpoints_index], kpath)\n\n    def _get_kticks_unfold(self, ax, wave_vectors, vlinecolor):\n        if self.custom_kpath is not None:\n            kpath = []\n            for i, b in zip(self.custom_kpath_inds, self.custom_kpath_flip):\n                if b:\n                    seg = list(reversed(self.kpath[i]))\n                else:\n                    seg = self.kpath[i]\n\n                kpath.extend(seg)\n        else:\n            kpath = []\n            for seg in self.kpath:\n                kpath.extend(seg)\n\n        kpath = [\n            f\"${k.strip()}$\" if k.strip() != \"G\" else \"$\\\\Gamma$\"\n            for k in kpath\n        ]\n\n        group_kpath = []\n        for i, j in enumerate(kpath):\n            if i == 0:\n                group_kpath.append([j])\n            if i % 2 and not i == len(kpath) - 1:\n                group_kpath.append([j, kpath[i + 1]])\n            if i == len(kpath) - 1:\n                group_kpath.append([j])\n\n        labels = []\n\n        for k in group_kpath:\n            if len(k) == 1:\n                labels.append(k[0])\n            else:\n                if k[0] == k[1]:\n                    labels.append(k[0])\n                else:\n                    merged_label = \"|\".join([k[0], k[1]]).replace(\"$|$\", \"|\")\n                    labels.append(merged_label)\n\n        n = int(len(self.kpoints) / len(self.kpath))\n        kpoints_index = [0] + [(n * i) for i in range(1, len(labels))]\n        kpoints_index[-1] -= 1\n\n        for k in kpoints_index:\n            ax.axvline(\n                x=wave_vectors[k], color=vlinecolor, alpha=0.7, linewidth=0.5\n            )\n\n        ax.set_xticks(wave_vectors[kpoints_index])\n        ax.set_xticklabels(labels)\n        #  plt.xticks(np.array(kpoints)[kpoints_index], kpath)\n\n    def _get_kticks_unfold_old(self, ax, wave_vectors, vlinecolor):\n        if type(self.kpath) == str:\n            kpath = [\n                f\"${k}$\" if k != \"G\" else \"$\\\\Gamma$\"\n                for k in self.kpath.upper().strip()\n            ]\n        elif type(self.kpath) == list:\n            kpath = self.kpath\n\n        kpoints_index = [0] + [(self.n * i) for i in range(1, len(self.kpath))]\n        kpoints_index[-1] -= 1\n\n        for k in kpoints_index:\n            ax.axvline(\n                x=wave_vectors[k], color=vlinecolor, alpha=0.7, linewidth=0.5\n            )\n\n        ax.set_xticks(wave_vectors[kpoints_index])\n        ax.set_xticklabels(kpath)\n        #  plt.xticks(np.array(kpoints)[kpoints_index], kpath)\n\n    def _get_kticks_old(self, ax, wave_vectors, vlinecolor):\n        \"\"\"\n        This function extracts the kpoint labels and index locations for a regular\n        band structure calculation (non unfolded).\n\n        Parameters:\n            ax (matplotlib.pyplot.axis): Axis to append the tick labels\n        \"\"\"\n\n        high_sym_points = self.kpoints_file.kpts\n        kpts_labels = np.array(\n            [\n                f\"${k}$\" if k != \"G\" else \"$\\\\Gamma$\"\n                for k in self.kpoints_file.labels\n            ]\n        )\n        all_kpoints = self.kpoints\n\n        index = [0]\n        for i in range(len(high_sym_points) - 2):\n            if high_sym_points[i + 2] != high_sym_points[i + 1]:\n                index.append(i)\n        index.append(len(high_sym_points) - 1)\n\n        kpts_loc = np.isin(\n            np.round(all_kpoints, 3), np.round(high_sym_points, 3)\n        ).all(1)\n        kpoints_index = np.where(kpts_loc == True)[0]\n\n        kpts_labels = kpts_labels[index]\n        kpoints_index = list(kpoints_index[index])\n        #  kpoints_index = ax.lines[0].get_xdata()[kpoints_index]\n\n        for k in kpoints_index:\n            ax.axvline(\n                x=wave_vectors[k], color=vlinecolor, alpha=0.7, linewidth=0.5\n            )\n\n        ax.set_xticks([wave_vectors[k] for k in kpoints_index])\n        ax.set_xticklabels(kpts_labels)\n\n    def _get_kticks_hse_old(self, wave_vectors, ax, kpath, vlinecolor):\n        structure = self.poscar.structure\n        kpath_obj = HighSymmKpath(structure)\n        kpath_labels = np.array(list(kpath_obj._kpath[\"kpoints\"].keys()))\n        kpath_coords = np.array(list(kpath_obj._kpath[\"kpoints\"].values()))\n        index = np.where(\n            np.isclose(\n                self.kpoints[:, None],\n                kpath_coords,\n            )\n            .all(-1)\n            .any(-1)\n            == True\n        )[0]\n        #  index = np.where(np.isclose(self.kpoints[:, None], kpath_coords).all(-1).any(-1) == True)[0]\n        #  index = np.where((self.kpoints[:, None] == kpath_coords).all(-1).any(-1) == True)[0]\n        index = (\n            [index[0]]\n            + [index[i] for i in range(1, len(index) - 1) if i % 2]\n            + [index[-1]]\n        )\n        kpoints_in_band = self.kpoints[index]\n\n        label_index = []\n        for i in range(kpoints_in_band.shape[0]):\n            for j in range(kpath_coords.shape[0]):\n                if (\n                    np.round(kpoints_in_band[i], 5)\n                    == np.round(kpath_coords[j], 5)\n                ).all():\n                    label_index.append(j)\n\n        kpoints_index = index\n        kpath = kpath_labels[label_index]\n        #  kpoints_index = ax.lines[0].get_xdata()[kpoints_index]\n\n        kpath = [f\"${k}$\" if k != \"G\" else \"$\\\\Gamma$\" for k in kpath]\n\n        for k in kpoints_index:\n            ax.axvline(\n                x=wave_vectors[k], color=vlinecolor, alpha=0.7, linewidth=0.5\n            )\n\n        plt.xticks([wave_vectors[k] for k in kpoints_index], kpath)\n\n    def _get_slices(self, unfold=False, hse=False):\n        if not unfold and not hse:\n            high_sym_points = self.kpoints_file.kpts\n            all_kpoints = self.kpoints\n            num_kpts = self.kpoints_file.num_kpts\n            num_slices = int(len(high_sym_points) / 2)\n            slices = [\n                slice(i * num_kpts, (i + 1) * num_kpts, None)\n                for i in range(num_slices)\n            ]\n\n        if hse and not unfold:\n            structure = self.poscar.structure\n            kpath_obj = HighSymmKpath(structure)\n            kpath_coords = np.array(list(kpath_obj._kpath[\"kpoints\"].values()))\n            index = np.where(\n                np.isclose(\n                    self.kpoints[:, None],\n                    kpath_coords,\n                )\n                .all(-1)\n                .any(-1)\n                == True\n            )[0]\n\n            segements = []\n            for i in range(0, len(index) - 1):\n                if not i % 2:\n                    segements.append([index[i], index[i + 1]])\n\n            # print(segements)\n\n            num_kpts = int(len(self.kpoints) / (len(index) / 2))\n            slices = [\n                slice(i * num_kpts, (i + 1) * num_kpts, None)\n                for i in range(int(len(index) / 2))\n            ]\n            # print(slices)\n            slices = [slice(i[0], i[1] + 1, None) for i in segements]\n            # print(slices)\n\n        if unfold and not hse:\n            n = int(len(self.kpoints) / len(self.kpath))\n            slices = [\n                slice(i * n, (i + 1) * n, None)\n                for i in range(int(len(self.kpath)))\n            ]\n\n        return slices\n\n    def _get_slices_old(self, unfold=False, hse=False):\n        if not unfold and not hse:\n            high_sym_points = self.kpoints_file.kpts\n            all_kpoints = self.kpoints\n            num_kpts = self.kpoints_file.num_kpts\n\n            if self.custom_kpath is not None:\n                num_slices = len(self.custom_kpath_inds)\n            else:\n                num_slices = int(len(high_sym_points) / 2)\n\n            slices = [\n                slice(i * num_kpts, (i + 1) * num_kpts, None)\n                for i in range(num_slices)\n            ]\n\n        if hse and not unfold:\n            structure = self.poscar.structure\n            kpath_obj = HighSymmKpath(structure)\n            kpath_coords = np.array(list(kpath_obj._kpath[\"kpoints\"].values()))\n            index = np.where(\n                np.isclose(\n                    self.kpoints[:, None],\n                    kpath_coords,\n                )\n                .all(-1)\n                .any(-1)\n                == True\n            )[0]\n\n            num_kpts = int(len(self.kpoints) / (len(index) / 2))\n            slices = [\n                slice(i * num_kpts, (i + 1) * num_kpts, None)\n                for i in range(int(len(index) / 2))\n            ]\n\n        if unfold and not hse:\n            n = int(len(self.kpoints) / len(self.kpath))\n            print(n)\n            slices = [\n                slice(i * n, (i + 1) * n, None)\n                for i in range(int(len(self.kpath) - 1))\n            ]\n            print(slices)\n\n        return slices\n\n    def _get_interpolated_data_segment(\n        self, wave_vectors, data, crop_zero=False, kind=\"cubic\"\n    ):\n        data_shape = data.shape\n\n        if len(data_shape) == 1:\n            fs = interp1d(wave_vectors, data, kind=kind, axis=0)\n        else:\n            fs = interp1d(wave_vectors, data, kind=kind, axis=1)\n\n        new_wave_vectors = np.linspace(\n            wave_vectors.min(), wave_vectors.max(), self.new_n\n        )\n        data = fs(new_wave_vectors)\n\n        if crop_zero:\n            data[np.where(data &lt; 0)] = 0\n\n        return new_wave_vectors, data\n\n    def _get_interpolated_data(\n        self, wave_vectors, data, crop_zero=False, kind=\"cubic\"\n    ):\n        slices = self._get_slices(unfold=self.unfold, hse=self.hse)\n        data_shape = data.shape\n        if len(data_shape) == 1:\n            data = [data[i] for i in slices]\n        else:\n            data = [data[:, i] for i in slices]\n\n        wave_vectors = [wave_vectors[i] for i in slices]\n\n        if len(data_shape) == 1:\n            fs = [\n                interp1d(i, j, kind=kind, axis=0)\n                for (i, j) in zip(wave_vectors, data)\n            ]\n        else:\n            fs = [\n                interp1d(i, j, kind=kind, axis=1)\n                for (i, j) in zip(wave_vectors, data)\n            ]\n\n        new_wave_vectors = [\n            np.linspace(wv.min(), wv.max(), self.new_n) for wv in wave_vectors\n        ]\n        data = np.hstack([f(wv) for (f, wv) in zip(fs, new_wave_vectors)])\n        wave_vectors = np.hstack(new_wave_vectors)\n\n        if crop_zero:\n            data[np.where(data &lt; 0)] = 0\n\n        return wave_vectors, data\n\n    def _filter_bands(self, erange):\n        eigenvalues = self.eigenvalues\n        where = (eigenvalues &gt;= np.min(erange) - 1) &amp; (\n            eigenvalues &lt;= np.max(erange) + 1\n        )\n        is_true = np.sum(np.isin(where, True), axis=1)\n        bands_in_plot = is_true &gt; 0\n\n        return bands_in_plot\n\n    def _add_legend(self, ax, names, colors, fontsize=10, markersize=4):\n        legend_lines = []\n        legend_labels = []\n        for name, color in zip(names, colors):\n            legend_lines.append(\n                plt.Line2D(\n                    [0],\n                    [0],\n                    marker=\"o\",\n                    markersize=markersize,\n                    linestyle=\"\",\n                    color=color,\n                )\n            )\n            legend_labels.append(f\"${name}$\")\n\n        leg = ax.get_legend()\n\n        if leg is None:\n            handles = legend_lines\n            labels = legend_labels\n        else:\n            handles = [l._legmarker for l in leg.legendHandles]\n            labels = [text._text for text in leg.texts]\n            handles.extend(legend_lines)\n            labels.extend(legend_labels)\n\n        ax.legend(\n            handles,\n            labels,\n            ncol=1,\n            loc=\"upper left\",\n            fontsize=fontsize,\n            bbox_to_anchor=(1, 1),\n            borderaxespad=0,\n            frameon=False,\n            handletextpad=0.1,\n        )\n\n    def _heatmap(\n        self,\n        ax,\n        wave_vectors,\n        eigenvalues,\n        weights,\n        sigma,\n        cmap,\n        bins,\n        projection=None,\n        powernorm=True,\n        gamma=0.5,\n    ):\n        eigenvalues_ravel = np.ravel(eigenvalues)\n        wave_vectors_tile = np.tile(wave_vectors, eigenvalues.shape[0])\n\n        if projection is not None:\n            if len(np.squeeze(projection).shape) == 2:\n                weights *= np.squeeze(projection)\n            else:\n                weights *= np.sum(np.squeeze(projection), axis=2)\n\n        weights_ravel = np.ravel(weights)\n\n        data = np.histogram2d(\n            wave_vectors_tile,\n            eigenvalues_ravel,\n            bins=bins,\n            weights=weights_ravel,\n        )[0]\n\n        data = gaussian_filter(data, sigma=sigma)\n        if powernorm:\n            norm = colors.PowerNorm(\n                gamma=gamma, vmin=np.min(data), vmax=np.max(data)\n            )\n        else:\n            norm = colors.Normalize(vmin=np.min(data), vmax=np.max(data))\n\n        ax.pcolormesh(\n            np.linspace(np.min(wave_vectors), np.max(wave_vectors), bins),\n            np.linspace(np.min(eigenvalues), np.max(eigenvalues), bins),\n            data.T,\n            shading=\"gouraud\",\n            cmap=cmap,\n            norm=norm,\n        )\n\n    def _alpha_cmap(self, color, repeats=3):\n        cmap = LinearSegmentedColormap.from_list(\n            \"custom_cmap\",\n            [to_rgb(color) + (0,)] + [to_rgba(color) for _ in range(repeats)],\n            N=10000,\n        )\n        return cmap\n\n    def plot_plain(\n        self,\n        ax,\n        color=\"black\",\n        erange=[-6, 6],\n        linewidth=1.25,\n        scale_factor=20,\n        linestyle=\"-\",\n        heatmap=False,\n        bins=400,\n        sigma=3,\n        cmap=\"hot\",\n        vlinecolor=\"black\",\n        powernorm=False,\n        gamma=0.5,\n        projection=None,\n        highlight_band=False,\n        highlight_band_color=\"red\",\n        band_index=None,\n        sp_color=\"red\",\n        sp_scale_factor=5,\n    ):\n        \"\"\"\n        This function plots a plain band structure.\n\n        Parameters:\n            ax (matplotlib.pyplot.axis): Axis to plot the data on\n            color (str): Color of the band structure lines\n            linewidth (float): Line width of the band structure lines\n            linestyle (str): Line style of the bands\n        \"\"\"\n        bands_in_plot = self._filter_bands(erange=erange)\n        slices = self._get_slices(unfold=self.unfold, hse=self.hse)\n        wave_vector_segments = self._get_k_distance()\n\n        # if self.soc_axis is not None and self.lsorbit:\n        #     color = \"black\"\n        #     linestyle = \"-\"\n\n        if self.soc_axis is not None and self.lsorbit:\n            if self.unfold:\n                K_indices = np.array(self.K_indices[0], dtype=int)\n                spin_projection_full_k = self.spin_projections[:, K_indices]\n            else:\n                spin_projection_full_k = self.spin_projections\n\n        if self.custom_kpath is not None:\n            kpath_inds = self.custom_kpath_inds\n            kpath_flip = self.custom_kpath_flip\n        else:\n            kpath_inds = range(len(slices))\n            kpath_flip = [False for _ in range(len(slices))]\n\n        for i, f, wave_vectors in zip(\n            kpath_inds, kpath_flip, wave_vector_segments\n        ):\n            if f:\n                eigenvalues = np.flip(\n                    self.eigenvalues[bands_in_plot, slices[i]], axis=1\n                )\n                if self.soc_axis is not None and self.lsorbit:\n                    spin_projections = np.flip(\n                        spin_projection_full_k[bands_in_plot, slices[i]],\n                        axis=1,\n                    )\n            else:\n                eigenvalues = self.eigenvalues[bands_in_plot, slices[i]]\n                if self.soc_axis is not None and self.lsorbit:\n                    spin_projections = spin_projection_full_k[\n                        bands_in_plot, slices[i]\n                    ]\n\n            if highlight_band:\n                if band_index is not None:\n                    if type(band_index) == int:\n                        highlight_eigenvalues = self.eigenvalues[\n                            int(band_index), slices[i]\n                        ]\n                    else:\n                        highlight_eigenvalues = self.eigenvalues[\n                            band_index, slices[i]\n                        ]\n\n            wave_vectors_for_kpoints = wave_vectors\n\n            if self.interpolate:\n                (\n                    wave_vectors,\n                    eigenvalues,\n                ) = self._get_interpolated_data_segment(\n                    wave_vectors_for_kpoints,\n                    eigenvalues,\n                )\n                if self.soc_axis is not None and self.lsorbit:\n                    _, spin_projections = self._get_interpolated_data_segment(\n                        wave_vectors_for_kpoints,\n                        spin_projections,\n                        crop_zero=True,\n                        kind=\"linear\",\n                    )\n\n                if highlight_band:\n                    if band_index is not None:\n                        (\n                            _,\n                            highlight_eigenvalues,\n                        ) = self._get_interpolated_data_segment(\n                            wave_vectors_for_kpoints,\n                            highlight_eigenvalues,\n                        )\n\n            eigenvalues_ravel = np.ravel(\n                np.c_[eigenvalues, np.empty(eigenvalues.shape[0]) * np.nan]\n            )\n            wave_vectors_tile = np.tile(\n                np.append(wave_vectors, np.nan), eigenvalues.shape[0]\n            )\n\n            if self.soc_axis is not None and self.lsorbit:\n                #  spin_cmap = self._alpha_cmap(color=spin_projection_color, repeats=1)\n                spin_projections_ravel = np.ravel(\n                    np.c_[\n                        spin_projections,\n                        np.empty(spin_projections.shape[0]) * np.nan,\n                    ]\n                )\n                #  spin_colors = [spin_cmap(s) for s in spin_projections_ravel]\n\n            if self.unfold:\n                spectral_weights = self.spectral_weights[\n                    bands_in_plot, slices[i]\n                ]\n                if f:\n                    spectral_weights = np.flip(spectral_weights, axis=1)\n                #  spectral_weights = spectral_weights / np.max(spectral_weights)\n\n                if highlight_band:\n                    if band_index is not None:\n                        highlight_spectral_weights = self.spectral_weights[\n                            int(band_index), slices[i]\n                        ]\n\n                if self.interpolate:\n                    _, spectral_weights = self._get_interpolated_data_segment(\n                        wave_vectors_for_kpoints,\n                        spectral_weights,\n                        crop_zero=True,\n                        kind=\"linear\",\n                    )\n\n                    if highlight_band:\n                        if band_index is not None:\n                            (\n                                _,\n                                highlight_spectral_weights,\n                            ) = self._get_interpolated_data_segment(\n                                wave_vectors_for_kpoints,\n                                highlight_spectral_weights,\n                                crop_zero=True,\n                                kind=\"linear\",\n                            )\n\n                spectral_weights_ravel = np.ravel(\n                    np.c_[\n                        spectral_weights,\n                        np.empty(spectral_weights.shape[0]) * np.nan,\n                    ]\n                )\n\n                if heatmap:\n                    self._heatmap(\n                        ax=ax,\n                        wave_vectors=wave_vectors,\n                        eigenvalues=eigenvalues,\n                        weights=spectral_weights,\n                        sigma=sigma,\n                        cmap=cmap,\n                        bins=bins,\n                        projection=projection,\n                        powernorm=powernorm,\n                        gamma=gamma,\n                    )\n                else:\n                    ax.scatter(\n                        wave_vectors_tile,\n                        eigenvalues_ravel,\n                        c=color,\n                        ec=None,\n                        s=scale_factor * spectral_weights_ravel,\n                        zorder=0,\n                    )\n                    if highlight_band:\n                        if band_index is not None:\n                            if type(band_index) == int:\n                                ax.scatter(\n                                    wave_vectors,\n                                    highlight_eigenvalues,\n                                    c=highlight_band_color,\n                                    ec=None,\n                                    s=scale_factor\n                                    * highlight_spectral_weights,\n                                    zorder=100,\n                                )\n                            else:\n                                ax.scatter(\n                                    np.tile(\n                                        np.append(wave_vectors, np.nan),\n                                        highlight_eigenvalues.shape[0],\n                                    ),\n                                    np.ravel(\n                                        np.c_[\n                                            highlight_eigenvalues,\n                                            np.empty(\n                                                highlight_eigenvalues.shape[0]\n                                            )\n                                            * np.nan,\n                                        ]\n                                    ),\n                                    c=highlight_band_color,\n                                    ec=None,\n                                    s=scale_factor\n                                    * np.ravel(highlight_spectral_weights),\n                                    zorder=100,\n                                )\n                    if self.soc_axis is not None and self.lsorbit:\n                        ax.scatter(\n                            wave_vectors_tile,\n                            eigenvalues_ravel,\n                            s=spectral_weights_ravel\n                            * sp_scale_factor\n                            * spin_projections_ravel,\n                            c=sp_color,\n                            zorder=100,\n                        )\n            else:\n                if heatmap:\n                    self._heatmap(\n                        ax=ax,\n                        wave_vectors=wave_vectors,\n                        eigenvalues=eigenvalues,\n                        weights=np.ones(eigenvalues.shape),\n                        sigma=sigma,\n                        cmap=cmap,\n                        bins=bins,\n                        projection=projection,\n                        powernorm=powernorm,\n                        gamma=gamma,\n                    )\n                else:\n                    ax.plot(\n                        wave_vectors_tile,\n                        eigenvalues_ravel,\n                        color=color,\n                        linewidth=linewidth,\n                        linestyle=linestyle,\n                        zorder=0,\n                    )\n                    if highlight_band:\n                        if band_index is not None:\n                            if type(band_index) == int:\n                                ax.plot(\n                                    wave_vectors,\n                                    highlight_eigenvalues,\n                                    color=highlight_band_color,\n                                    linewidth=linewidth,\n                                    linestyle=linestyle,\n                                    zorder=100,\n                                )\n                            else:\n                                ax.plot(\n                                    np.tile(\n                                        np.append(wave_vectors, np.nan),\n                                        highlight_eigenvalues.shape[0],\n                                    ),\n                                    np.ravel(\n                                        np.c_[\n                                            highlight_eigenvalues,\n                                            np.empty(\n                                                highlight_eigenvalues.shape[0]\n                                            )\n                                            * np.nan,\n                                        ]\n                                    ),\n                                    color=highlight_band_color,\n                                    linewidth=linewidth,\n                                    linestyle=linestyle,\n                                    zorder=100,\n                                )\n                    if self.soc_axis is not None and self.lsorbit:\n                        ax.scatter(\n                            wave_vectors_tile,\n                            eigenvalues_ravel,\n                            s=sp_scale_factor * spin_projections_ravel,\n                            c=sp_color,\n                            zorder=100,\n                        )\n\n        if self.hse:\n            self._get_kticks_hse(\n                ax=ax,\n                wave_vectors=np.concatenate(self._get_k_distance()),\n                kpath=self.kpath,\n                vlinecolor=vlinecolor,\n            )\n        elif self.unfold:\n            self._get_kticks_unfold(\n                ax=ax,\n                wave_vectors=np.concatenate(self._get_k_distance()),\n                vlinecolor=vlinecolor,\n            )\n        else:\n            self._get_kticks(\n                ax=ax,\n                wave_vectors=np.concatenate(self._get_k_distance()),\n                vlinecolor=vlinecolor,\n            )\n\n        ax.set_xlim(0, np.concatenate(self._get_k_distance()).max())\n\n    def _plot_projected_general(\n        self,\n        ax,\n        projected_data,\n        colors,\n        scale_factor=5,\n        erange=[-6, 6],\n        display_order=None,\n        linewidth=0.75,\n        band_color=\"black\",\n        heatmap=False,\n        bins=400,\n        sigma=3,\n        cmap=\"hot\",\n        vlinecolor=\"black\",\n        powernorm=False,\n        gamma=0.5,\n        plain_scale_factor=10,\n    ):\n        \"\"\"\n        This is a general method for plotting projected data\n\n        Parameters:\n            scale_factor (float): Factor to scale weights. This changes the size of the\n                points in the scatter plot\n            color_dict (dict[str][str]): This option allow the colors of each orbital\n                specified. Should be in the form of:\n                {'orbital index': &lt;color&gt;, 'orbital index': &lt;color&gt;, ...}\n            legend (bool): Determines if the legend should be included or not.\n            linewidth (float): Line width of the plain band structure plotted in the background\n            band_color (string): Color of the plain band structure\n        \"\"\"\n        if self.unfold:\n            if band_color == \"black\":\n                band_color = \"darkgrey\"\n            scale_factor = scale_factor * 4\n\n        bands_in_plot = self._filter_bands(erange=erange)\n        slices = self._get_slices(unfold=self.unfold, hse=self.hse)\n\n        if self.unfold:\n            K_indices = np.array(self.K_indices[0], dtype=int)\n            projected_data = projected_data[:, K_indices, :]\n\n        self.plot_plain(\n            ax=ax,\n            linewidth=linewidth,\n            color=band_color,\n            erange=erange,\n            heatmap=heatmap,\n            sigma=sigma,\n            cmap=cmap,\n            bins=bins,\n            vlinecolor=vlinecolor,\n            projection=projected_data,\n            scale_factor=plain_scale_factor,\n            sp_scale_factor=0,\n        )\n\n        wave_vector_segments = self._get_k_distance()\n\n        if self.custom_kpath is not None:\n            kpath_inds = self.custom_kpath_inds\n            kpath_flip = self.custom_kpath_flip\n        else:\n            kpath_inds = range(len(slices))\n            kpath_flip = [False for _ in range(len(slices))]\n\n        for i, f, wave_vectors in zip(\n            kpath_inds, kpath_flip, wave_vector_segments\n        ):\n            projected_data_slice = projected_data[bands_in_plot, slices[i]]\n            if f:\n                eigenvalues = np.flip(\n                    self.eigenvalues[bands_in_plot, slices[i]], axis=1\n                )\n                projected_data_slice = np.flip(projected_data_slice, axis=1)\n            else:\n                eigenvalues = self.eigenvalues[bands_in_plot, slices[i]]\n\n            unique_colors = np.unique(colors)\n            shapes = (\n                projected_data_slice.shape[0],\n                projected_data_slice.shape[1],\n                projected_data_slice.shape[-1],\n            )\n            projected_data_slice = projected_data_slice.reshape(shapes)\n\n            if len(unique_colors) == len(colors):\n                plot_colors = colors\n            else:\n                unique_inds = [np.isin(colors, c) for c in unique_colors]\n                projected_data_slice = np.squeeze(projected_data_slice)\n                projected_data_slice = np.c_[\n                    [\n                        np.sum(projected_data_slice[..., u], axis=2)\n                        for u in unique_inds\n                    ]\n                ].transpose((1, 2, 0))\n                plot_colors = unique_colors\n\n            wave_vectors_old = wave_vectors\n\n            if self.interpolate:\n                (\n                    wave_vectors,\n                    eigenvalues,\n                ) = self._get_interpolated_data_segment(\n                    wave_vectors_old, eigenvalues\n                )\n                _, projected_data_slice = self._get_interpolated_data_segment(\n                    wave_vectors_old,\n                    projected_data_slice,\n                    crop_zero=True,\n                    kind=\"linear\",\n                )\n\n            if not heatmap:\n                if self.unfold:\n                    spectral_weights = self.spectral_weights[\n                        bands_in_plot, slices[i]\n                    ]\n                    if f:\n                        spectral_weights = np.flip(spectral_weights, axis=1)\n                    #  spectral_weights = spectral_weights / np.max(spectral_weights)\n\n                    if self.interpolate:\n                        (\n                            _,\n                            spectral_weights,\n                        ) = self._get_interpolated_data_segment(\n                            wave_vectors_old,\n                            spectral_weights,\n                            crop_zero=True,\n                            kind=\"linear\",\n                        )\n\n                    spectral_weights_ravel = np.repeat(\n                        np.ravel(spectral_weights),\n                        projected_data_slice.shape[-1],\n                    )\n\n                projected_data_ravel = np.ravel(projected_data_slice)\n                wave_vectors_tile = np.tile(\n                    np.repeat(wave_vectors, projected_data_slice.shape[-1]),\n                    projected_data_slice.shape[0],\n                )\n                eigenvalues_tile = np.repeat(\n                    np.ravel(eigenvalues), projected_data_slice.shape[-1]\n                )\n                colors_tile = np.tile(\n                    plot_colors, np.prod(projected_data_slice.shape[:-1])\n                )\n\n                if display_order is None:\n                    pass\n                else:\n                    sort_index = np.argsort(projected_data_ravel)\n\n                    if display_order == \"all\":\n                        sort_index = sort_index[::-1]\n\n                    wave_vectors_tile = wave_vectors_tile[sort_index]\n                    eigenvalues_tile = eigenvalues_tile[sort_index]\n                    colors_tile = colors_tile[sort_index]\n                    projected_data_ravel = projected_data_ravel[sort_index]\n\n                    if self.unfold:\n                        spectral_weights_ravel = spectral_weights_ravel[\n                            sort_index\n                        ]\n\n                if self.unfold:\n                    s = (\n                        scale_factor\n                        * projected_data_ravel\n                        * spectral_weights_ravel\n                    )\n                    ec = None\n                else:\n                    s = scale_factor * projected_data_ravel\n                    ec = colors_tile\n\n                ax.scatter(\n                    wave_vectors_tile,\n                    eigenvalues_tile,\n                    c=colors_tile,\n                    ec=ec,\n                    s=s,\n                    zorder=100,\n                )\n\n    def plot_plain_old(\n        self,\n        ax,\n        color=\"black\",\n        erange=[-6, 6],\n        linewidth=1.25,\n        scale_factor=20,\n        linestyle=\"-\",\n        heatmap=False,\n        bins=400,\n        sigma=3,\n        cmap=\"hot\",\n        vlinecolor=\"black\",\n        powernorm=False,\n        gamma=0.5,\n        projection=None,\n        highlight_band=False,\n        highlight_band_color=\"red\",\n        band_index=None,\n    ):\n        \"\"\"\n        This function plots a plain band structure.\n\n        Parameters:\n            ax (matplotlib.pyplot.axis): Axis to plot the data on\n            color (str): Color of the band structure lines\n            linewidth (float): Line width of the band structure lines\n            linestyle (str): Line style of the bands\n        \"\"\"\n        bands_in_plot = self._filter_bands(erange=erange)\n        eigenvalues = self.eigenvalues[bands_in_plot]\n\n        if highlight_band:\n            if band_index is not None:\n                highlight_eigenvalues = self.eigenvalues[int(band_index)]\n\n        wave_vectors = self._get_k_distance()\n        wave_vectors_for_kpoints = wave_vectors\n\n        if self.interpolate:\n            wave_vectors, eigenvalues = self._get_interpolated_data_segment(\n                wave_vectors_for_kpoints, eigenvalues\n            )\n\n            if highlight_band:\n                if band_index is not None:\n                    (\n                        _,\n                        highlight_eigenvalues,\n                    ) = self._get_interpolated_data_segment(\n                        wave_vectors_for_kpoints,\n                        highlight_eigenvalues,\n                    )\n\n        eigenvalues_ravel = np.ravel(\n            np.c_[eigenvalues, np.empty(eigenvalues.shape[0]) * np.nan]\n        )\n        wave_vectors_tile = np.tile(\n            np.append(wave_vectors, np.nan), eigenvalues.shape[0]\n        )\n\n        if self.unfold:\n            spectral_weights = self.spectral_weights[bands_in_plot]\n            #  spectral_weights = spectral_weights / np.max(spectral_weights)\n\n            if highlight_band:\n                if band_index is not None:\n                    highlight_spectral_weights = self.spectral_weights[\n                        int(band_index)\n                    ]\n\n            if self.interpolate:\n                _, spectral_weights = self._get_interpolated_data_segment(\n                    wave_vectors_for_kpoints,\n                    spectral_weights,\n                    crop_zero=True,\n                    kind=\"linear\",\n                )\n\n                if highlight_band:\n                    if band_index is not None:\n                        (\n                            _,\n                            highlight_spectral_weights,\n                        ) = self._get_interpolated_data_segment(\n                            wave_vectors_for_kpoints,\n                            highlight_spectral_weights,\n                            crop_zero=True,\n                            kind=\"linear\",\n                        )\n\n            spectral_weights_ravel = np.ravel(\n                np.c_[\n                    spectral_weights,\n                    np.empty(spectral_weights.shape[0]) * np.nan,\n                ]\n            )\n\n            if heatmap:\n                self._heatmap(\n                    ax=ax,\n                    wave_vectors=wave_vectors,\n                    eigenvalues=eigenvalues,\n                    weights=spectral_weights,\n                    sigma=sigma,\n                    cmap=cmap,\n                    bins=bins,\n                    projection=projection,\n                    powernorm=powernorm,\n                    gamma=gamma,\n                )\n            else:\n                ax.scatter(\n                    wave_vectors_tile,\n                    eigenvalues_ravel,\n                    c=color,\n                    ec=None,\n                    s=scale_factor * spectral_weights_ravel,\n                    zorder=0,\n                )\n                if highlight_band:\n                    if band_index is not None:\n                        ax.scatter(\n                            wave_vectors,\n                            highlight_eigenvalues,\n                            c=highlight_band_color,\n                            ec=None,\n                            s=scale_factor * highlight_spectral_weights,\n                            zorder=100,\n                        )\n        else:\n            if heatmap:\n                self._heatmap(\n                    ax=ax,\n                    wave_vectors=wave_vectors,\n                    eigenvalues=eigenvalues,\n                    weights=np.ones(eigenvalues.shape),\n                    sigma=sigma,\n                    cmap=cmap,\n                    bins=bins,\n                    projection=projection,\n                    powernorm=powernorm,\n                    gamma=gamma,\n                )\n            else:\n                ax.plot(\n                    wave_vectors_tile,\n                    eigenvalues_ravel,\n                    color=color,\n                    linewidth=linewidth,\n                    linestyle=linestyle,\n                    zorder=0,\n                )\n                if highlight_band:\n                    if band_index is not None:\n                        ax.plot(\n                            wave_vectors,\n                            highlight_eigenvalues,\n                            color=highlight_band_color,\n                            linewidth=linewidth,\n                            linestyle=linestyle,\n                            zorder=100,\n                        )\n\n        if self.hse:\n            self._get_kticks_hse(\n                ax=ax,\n                wave_vectors=wave_vectors_for_kpoints,\n                kpath=self.kpath,\n                vlinecolor=vlinecolor,\n            )\n        elif self.unfold:\n            self._get_kticks_unfold(\n                ax=ax,\n                wave_vectors=wave_vectors_for_kpoints,\n                vlinecolor=vlinecolor,\n            )\n        else:\n            self._get_kticks(\n                ax=ax,\n                wave_vectors=wave_vectors_for_kpoints,\n                vlinecolor=vlinecolor,\n            )\n\n        ax.set_xlim(0, np.max(wave_vectors))\n\n    def _plot_projected_general_old(\n        self,\n        ax,\n        projected_data,\n        colors,\n        scale_factor=5,\n        erange=[-6, 6],\n        display_order=None,\n        linewidth=0.75,\n        band_color=\"black\",\n        heatmap=False,\n        bins=400,\n        sigma=3,\n        cmap=\"hot\",\n        vlinecolor=\"black\",\n        powernorm=False,\n        gamma=0.5,\n        plain_scale_factor=10,\n    ):\n        \"\"\"\n        This is a general method for plotting projected data\n\n        Parameters:\n            scale_factor (float): Factor to scale weights. This changes the size of the\n                points in the scatter plot\n            color_dict (dict[str][str]): This option allow the colors of each orbital\n                specified. Should be in the form of:\n                {'orbital index': &lt;color&gt;, 'orbital index': &lt;color&gt;, ...}\n            legend (bool): Determines if the legend should be included or not.\n            linewidth (float): Line width of the plain band structure plotted in the background\n            band_color (string): Color of the plain band structure\n        \"\"\"\n        if self.unfold:\n            if band_color == \"black\":\n                band_color = \"darkgrey\"\n            scale_factor = scale_factor * 4\n\n        bands_in_plot = self._filter_bands(erange=erange)\n        projected_data = projected_data[bands_in_plot]\n        unique_colors = np.unique(colors)\n        shapes = (\n            projected_data.shape[0],\n            projected_data.shape[1],\n            projected_data.shape[-1],\n        )\n        projected_data = projected_data.reshape(shapes)\n\n        if len(unique_colors) == len(colors):\n            pass\n        else:\n            unique_inds = [np.isin(colors, c) for c in unique_colors]\n            projected_data = np.squeeze(projected_data)\n            projected_data = np.c_[\n                [np.sum(projected_data[..., i], axis=2) for i in unique_inds]\n            ].transpose((1, 2, 0))\n            colors = unique_colors\n\n        #  projected_data = projected_data / np.max(projected_data)\n        wave_vectors = self._get_k_distance()\n        wave_vectors_old = wave_vectors\n        eigenvalues = self.eigenvalues[bands_in_plot]\n\n        if self.unfold:\n            K_indices = np.array(self.K_indices[0], dtype=int)\n            projected_data = projected_data[:, K_indices, :]\n\n        if self.interpolate:\n            wave_vectors, eigenvalues = self._get_interpolated_data(\n                wave_vectors_old, eigenvalues\n            )\n            _, projected_data = self._get_interpolated_data(\n                wave_vectors_old,\n                projected_data,\n                crop_zero=True,\n                kind=\"linear\",\n            )\n\n        self.plot_plain(\n            ax=ax,\n            linewidth=linewidth,\n            color=band_color,\n            erange=erange,\n            heatmap=heatmap,\n            sigma=sigma,\n            cmap=cmap,\n            bins=bins,\n            vlinecolor=vlinecolor,\n            projection=projected_data,\n            scale_factor=plain_scale_factor,\n        )\n\n        if not heatmap:\n            if self.unfold:\n                spectral_weights = self.spectral_weights[bands_in_plot]\n                spectral_weights = spectral_weights / np.max(spectral_weights)\n\n                if self.interpolate:\n                    _, spectral_weights = self._get_interpolated_data(\n                        wave_vectors_old,\n                        spectral_weights,\n                        crop_zero=True,\n                        kind=\"linear\",\n                    )\n\n                spectral_weights_ravel = np.repeat(\n                    np.ravel(spectral_weights), projected_data.shape[-1]\n                )\n\n            projected_data_ravel = np.ravel(projected_data)\n            wave_vectors_tile = np.tile(\n                np.repeat(wave_vectors, projected_data.shape[-1]),\n                projected_data.shape[0],\n            )\n            eigenvalues_tile = np.repeat(\n                np.ravel(eigenvalues), projected_data.shape[-1]\n            )\n            colors_tile = np.tile(colors, np.prod(projected_data.shape[:-1]))\n\n            if display_order is None:\n                pass\n            else:\n                sort_index = np.argsort(projected_data_ravel)\n\n                if display_order == \"all\":\n                    sort_index = sort_index[::-1]\n\n                wave_vectors_tile = wave_vectors_tile[sort_index]\n                eigenvalues_tile = eigenvalues_tile[sort_index]\n                colors_tile = colors_tile[sort_index]\n                projected_data_ravel = projected_data_ravel[sort_index]\n\n                if self.unfold:\n                    spectral_weights_ravel = spectral_weights_ravel[sort_index]\n\n            if self.unfold:\n                s = (\n                    scale_factor\n                    * projected_data_ravel\n                    * spectral_weights_ravel\n                )\n                ec = None\n            else:\n                s = scale_factor * projected_data_ravel\n                ec = colors_tile\n\n            ax.scatter(\n                wave_vectors_tile,\n                eigenvalues_tile,\n                c=colors_tile,\n                ec=ec,\n                s=s,\n                zorder=100,\n            )\n\n    def plot_orbitals(\n        self,\n        ax,\n        orbitals,\n        scale_factor=5,\n        erange=[-6, 6],\n        display_order=None,\n        color_list=None,\n        legend=True,\n        linewidth=0.75,\n        band_color=\"black\",\n        heatmap=False,\n        bins=400,\n        sigma=3,\n        cmap=\"hot\",\n        vlinecolor=\"black\",\n        powernorm=False,\n        gamma=0.5,\n    ):\n        \"\"\"\n        This function plots the projected band structure of given orbitals summed across all atoms on a given axis.\n\n        Parameters:\n            ax (matplotlib.pyplot.axis): Axis to plot the data on\n            orbitals (list): List of orbits to compare\n\n                | 0 = s\n                | 1 = py\n                | 2 = pz\n                | 3 = px\n                | 4 = dxy\n                | 5 = dyz\n                | 6 = dz2\n                | 7 = dxz\n                | 8 = dx2-y2\n                | 9 = fy3x2\n                | 10 = fxyz\n                | 11 = fyz2\n                | 12 = fz3\n                | 13 = fxz2\n                | 14 = fzx3\n                | 15 = fx3\n\n            scale_factor (float): Factor to scale weights. This changes the size of the\n                points in the scatter plot\n            color_dict (dict[str][str]): This option allow the colors of each orbital\n                specified. Should be in the form of:\n                {'orbital index': &lt;color&gt;, 'orbital index': &lt;color&gt;, ...}\n            legend (bool): Determines if the legend should be included or not.\n            linewidth (float): Line width of the plain band structure plotted in the background\n            band_color (string): Color of the plain band structure\n        \"\"\"\n\n        if color_list is None:\n            colors = np.array([self.color_dict[i] for i in orbitals])\n        else:\n            colors = color_list\n\n        projected_data = self._sum_orbitals(orbitals=orbitals)\n\n        self._plot_projected_general(\n            ax=ax,\n            projected_data=projected_data,\n            colors=colors,\n            scale_factor=scale_factor,\n            erange=erange,\n            display_order=display_order,\n            linewidth=linewidth,\n            band_color=band_color,\n            heatmap=heatmap,\n            bins=bins,\n            sigma=sigma,\n            cmap=cmap,\n            vlinecolor=vlinecolor,\n        )\n\n        if legend:\n            self._add_legend(\n                ax,\n                names=[self.orbital_labels[i] for i in orbitals],\n                colors=colors,\n            )\n\n    def plot_spd(\n        self,\n        ax,\n        scale_factor=5,\n        orbitals=\"spd\",\n        erange=[-6, 6],\n        display_order=None,\n        color_list=None,\n        legend=True,\n        linewidth=0.75,\n        band_color=\"black\",\n        heatmap=False,\n        bins=400,\n        sigma=3,\n        cmap=\"hot\",\n        vlinecolor=\"black\",\n        powernorm=False,\n        gamma=0.5,\n    ):\n        \"\"\"\n        This function plots the s, p, d projected band structure onto a given axis\n\n        Parameters:\n            ax (matplotlib.pyplot.axis): Axis to plot the data on\n            scale_factor (float): Factor to scale weights. This changes the size of the\n                points in the scatter plot\n            order (list): This determines the order in which the points are plotted on the\n                graph. This is an option because sometimes certain orbitals can be hidden\n                under others because they have a larger weight. For example, if the\n                weights of the d orbitals are greater than that of the s orbitals, it\n                might be smart to choose ['d', 'p', 's'] as the order so the s orbitals are\n                plotted over the d orbitals.\n            color_dict (dict[str][str]): This option allow the colors of the s, p, and d\n                orbitals to be specified. Should be in the form of:\n                {'s': &lt;s color&gt;, 'p': &lt;p color&gt;, 'd': &lt;d color&gt;}\n            legend (bool): Determines if the legend should be included or not.\n            linewidth (float): Line width of the plain band structure plotted in the background\n            band_color (string): Color of the plain band structure\n        \"\"\"\n        if color_list is None:\n            color_list = [\n                self.color_dict[0],\n                self.color_dict[1],\n                self.color_dict[2],\n                self.color_dict[4],\n            ]\n            colors = np.array([color_list[i] for i in range(len(orbitals))])\n        else:\n            colors = color_list\n\n        projected_data = self._sum_spd(spd=orbitals)\n\n        self._plot_projected_general(\n            ax=ax,\n            projected_data=projected_data,\n            colors=colors,\n            scale_factor=scale_factor,\n            erange=erange,\n            display_order=display_order,\n            linewidth=linewidth,\n            band_color=band_color,\n            heatmap=heatmap,\n            bins=bins,\n            sigma=sigma,\n            cmap=cmap,\n            vlinecolor=vlinecolor,\n        )\n\n        if legend:\n            self._add_legend(ax, names=[i for i in orbitals], colors=colors)\n\n    def plot_atoms(\n        self,\n        ax,\n        atoms,\n        scale_factor=5,\n        erange=[-6, 6],\n        display_order=None,\n        color_list=None,\n        legend=True,\n        linewidth=0.75,\n        band_color=\"black\",\n        heatmap=False,\n        bins=400,\n        sigma=3,\n        cmap=\"hot\",\n        vlinecolor=\"black\",\n        powernorm=False,\n        gamma=0.5,\n    ):\n        \"\"\"\n        This function plots the projected band structure of given atoms summed across all orbitals on a given axis.\n\n        Parameters:\n            ax (matplotlib.pyplot.axis): Axis to plot the data on\n            atoms (list): List of atoms to project onto\n            scale_factor (float): Factor to scale weights. This changes the size of the\n                points in the scatter plot\n            color_list (list): List of colors of the same length as the atoms list\n            legend (bool): Determines if the legend should be included or not.\n            linewidth (float): Line width of the plain band structure plotted in the background\n            band_color (string): Color of the plain band structure\n        \"\"\"\n        if color_list is None:\n            colors = np.array([self.color_dict[i] for i in range(len(atoms))])\n        else:\n            colors = color_list\n\n        projected_data = self._sum_atoms(atoms=atoms)\n\n        self._plot_projected_general(\n            ax=ax,\n            projected_data=projected_data,\n            colors=colors,\n            scale_factor=scale_factor,\n            erange=erange,\n            display_order=display_order,\n            linewidth=linewidth,\n            band_color=band_color,\n            heatmap=heatmap,\n            bins=bins,\n            sigma=sigma,\n            cmap=cmap,\n            vlinecolor=vlinecolor,\n        )\n\n        if legend:\n            self._add_legend(ax, names=atoms, colors=colors)\n\n    def plot_atom_orbitals(\n        self,\n        ax,\n        atom_orbital_dict,\n        scale_factor=5,\n        erange=[-6, 6],\n        display_order=None,\n        color_list=None,\n        legend=True,\n        linewidth=0.75,\n        band_color=\"black\",\n        heatmap=False,\n        bins=400,\n        sigma=3,\n        cmap=\"hot\",\n        vlinecolor=\"black\",\n        powernorm=False,\n        gamma=0.5,\n    ):\n        \"\"\"\n        This function plots the projected band structure of individual orbitals on a given axis.\n\n        Parameters:\n            ax (matplotlib.pyplot.axis): Axis to plot the data on\n            atom_orbital_pairs (list[list]): Selected orbitals on selected atoms to plot.\n                This should take the form of [[atom index, orbital_index], ...].\n                To plot the px orbital of the 1st atom and the pz orbital of the 2nd atom\n                in the POSCAR file, the input would be [[0, 3], [1, 2]]\n            scale_factor (float): Factor to scale weights. This changes the size of the\n                points in the scatter plot\n            color_list (list): List of colors of the same length as the atom_orbital_pairs\n            legend (bool): Determines if the legend should be included or not.\n            linewidth (float): Line width of the plain band structure plotted in the background\n            band_color (string): Color of the plain band structure\n        \"\"\"\n\n        atom_indices = list(atom_orbital_dict.keys())\n        orbital_indices = list(atom_orbital_dict.values())\n        number_orbitals = [len(i) for i in orbital_indices]\n        atom_indices = np.repeat(atom_indices, number_orbitals)\n        orbital_symbols_long = np.hstack(\n            [[self.orbital_labels[o] for o in orb] for orb in orbital_indices]\n        )\n        orbital_indices_long = np.hstack(orbital_indices)\n        indices = np.vstack([atom_indices, orbital_indices_long]).T\n\n        projected_data = self.projected_eigenvalues\n        projected_data = np.transpose(\n            np.array(\n                [projected_data[:, :, ind[0], ind[1]] for ind in indices]\n            ),\n            axes=(1, 2, 0),\n        )\n\n        if color_list is None:\n            colors = np.array(\n                [self.color_dict[i] for i in range(len(orbital_indices_long))]\n            )\n        else:\n            colors = color_list\n\n        self._plot_projected_general(\n            ax=ax,\n            projected_data=projected_data,\n            colors=colors,\n            scale_factor=scale_factor,\n            erange=erange,\n            display_order=display_order,\n            linewidth=linewidth,\n            band_color=band_color,\n            heatmap=heatmap,\n            bins=bins,\n            sigma=sigma,\n            cmap=cmap,\n            vlinecolor=vlinecolor,\n        )\n\n        if legend:\n            self._add_legend(\n                ax,\n                names=[\n                    f\"{i[0]}({i[1]})\"\n                    for i in zip(atom_indices, orbital_symbols_long)\n                ],\n                colors=colors,\n            )\n\n    def plot_atom_spd(\n        self,\n        ax,\n        atom_spd_dict,\n        scale_factor=5,\n        erange=[-6, 6],\n        display_order=None,\n        color_list=None,\n        legend=True,\n        linewidth=0.75,\n        band_color=\"black\",\n        heatmap=False,\n        bins=400,\n        sigma=3,\n        cmap=\"hot\",\n        vlinecolor=\"black\",\n        powernorm=False,\n        gamma=0.5,\n    ):\n        \"\"\"\n        This function plots the projected band structure on the s, p, and d orbitals for each specified atom in the calculated structure.\n\n        Parameters:\n            ax (matplotlib.pyplot.axis): Axis to plot the data on\n            atom_spd_dict (dict): Dictionary to determine the atom and spd orbitals to project onto\n                Format: {0: 'spd', 1: 'sp', 2: 's'} where 0,1,2 are atom indicies in the POSCAR\n            display_order (None or str): The available options are None, 'all', 'dominant' where None\n                plots the scatter points in the order presented in the atom_spd_dict, 'all' plots the\n                scatter points largest --&gt; smallest to all points are visable, and 'dominant' plots\n                the scatter points smallest --&gt; largest so only the dominant color is visable.\n            scale_factor (float): Factor to scale weights. This changes the size of the\n                points in the scatter plot\n            color_dict (dict[str][str]): This option allow the colors of the s, p, and d\n                orbitals to be specified. Should be in the form of:\n                {'s': &lt;s color&gt;, 'p': &lt;p color&gt;, 'd': &lt;d color&gt;}\n            legend (bool): Determines if the legend should be included or not.\n            linewidth (float): Line width of the plain band structure plotted in the background\n            band_color (string): Color of the plain band structure\n        \"\"\"\n        atom_indices = list(atom_spd_dict.keys())\n        orbital_symbols = list(atom_spd_dict.values())\n        number_orbitals = [len(i) for i in orbital_symbols]\n        atom_indices = np.repeat(atom_indices, number_orbitals)\n        orbital_symbols_long = np.hstack(\n            [[o for o in orb] for orb in orbital_symbols]\n        )\n        orbital_indices = np.hstack(\n            [[self.spd_relations[o] for o in orb] for orb in orbital_symbols]\n        )\n        indices = np.vstack([atom_indices, orbital_indices]).T\n\n        projected_data = self._sum_atoms(atoms=atom_indices, spd=True)\n        projected_data = np.transpose(\n            np.array(\n                [projected_data[:, :, ind[0], ind[1]] for ind in indices]\n            ),\n            axes=(1, 2, 0),\n        )\n\n        if color_list is None:\n            colors = np.array(\n                [self.color_dict[i] for i in range(len(orbital_symbols_long))]\n            )\n        else:\n            colors = color_list\n\n        self._plot_projected_general(\n            ax=ax,\n            projected_data=projected_data,\n            colors=colors,\n            scale_factor=scale_factor,\n            erange=erange,\n            display_order=display_order,\n            linewidth=linewidth,\n            band_color=band_color,\n            heatmap=heatmap,\n            bins=bins,\n            sigma=sigma,\n            cmap=cmap,\n            vlinecolor=vlinecolor,\n        )\n\n        if legend:\n            self._add_legend(\n                ax,\n                names=[\n                    f\"{i[0]}({i[1]})\"\n                    for i in zip(atom_indices, orbital_symbols_long)\n                ],\n                colors=colors,\n            )\n\n    def plot_elements(\n        self,\n        ax,\n        elements,\n        scale_factor=5,\n        erange=[-6, 6],\n        display_order=None,\n        color_list=None,\n        legend=True,\n        linewidth=0.75,\n        band_color=\"black\",\n        heatmap=False,\n        bins=400,\n        sigma=3,\n        cmap=\"hot\",\n        vlinecolor=\"black\",\n        powernorm=False,\n        gamma=0.5,\n    ):\n        \"\"\"\n        This function plots the projected band structure on specified elements in the calculated structure\n\n        Parameters:\n            ax (matplotlib.pyplot.axis): Axis to plot the data on\n            elements (list): List of element symbols to project onto\n            scale_factor (float): Factor to scale weights. This changes the size of the\n                points in the scatter plot\n            color_list (list): List of colors of the same length as the elements list\n            legend (bool): Determines if the legend should be included or not.\n            linewidth (float): Line width of the plain band structure plotted in the background\n            band_color (string): Color of the plain band structure\n        \"\"\"\n        if color_list is None:\n            colors = np.array(\n                [self.color_dict[i] for i in range(len(elements))]\n            )\n        else:\n            colors = color_list\n\n        projected_data = self._sum_elements(elements=elements)\n\n        self._plot_projected_general(\n            ax=ax,\n            projected_data=projected_data,\n            colors=colors,\n            scale_factor=scale_factor,\n            erange=erange,\n            display_order=display_order,\n            linewidth=linewidth,\n            band_color=band_color,\n            heatmap=heatmap,\n            bins=bins,\n            sigma=sigma,\n            cmap=cmap,\n            vlinecolor=vlinecolor,\n        )\n\n        if legend:\n            self._add_legend(ax, names=elements, colors=colors)\n\n    def plot_element_orbitals(\n        self,\n        ax,\n        element_orbital_dict,\n        scale_factor=5,\n        erange=[-6, 6],\n        display_order=None,\n        color_list=None,\n        legend=True,\n        linewidth=0.75,\n        band_color=\"black\",\n        heatmap=False,\n        bins=400,\n        sigma=3,\n        cmap=\"hot\",\n        vlinecolor=\"black\",\n        powernorm=False,\n        gamma=0.5,\n    ):\n        \"\"\"\n        this function plots the projected band structure on chosen orbitals for each specified element in the calculated structure.\n\n        Parameters:\n            ax (matplotlib.pyplot.axis): axis to plot the data on\n            element_orbital_pairs (list[list]): List of list in the form of\n                [[element symbol, orbital index], [element symbol, orbital_index], ...]\n            scale_factor (float): factor to scale weights. this changes the size of the\n                points in the scatter plot\n            color_list (list): List of colors of the same length as the element_orbital_pairs\n            legend (bool): determines if the legend should be included or not.\n            linewidth (float): line width of the plain band structure plotted in the background\n            band_color (string): color of the plain band structure\n        \"\"\"\n        element_symbols = list(element_orbital_dict.keys())\n        orbital_indices = list(element_orbital_dict.values())\n        number_orbitals = [len(i) for i in orbital_indices]\n        element_symbols_long = np.repeat(element_symbols, number_orbitals)\n        element_indices = np.repeat(\n            range(len(element_symbols)), number_orbitals\n        )\n        orbital_symbols_long = np.hstack(\n            [[self.orbital_labels[o] for o in orb] for orb in orbital_indices]\n        )\n        orbital_indices_long = np.hstack(orbital_indices)\n        indices = np.vstack([element_indices, orbital_indices_long]).T\n\n        projected_data = self._sum_elements(\n            elements=element_symbols, orbitals=True\n        )\n        projected_data = np.transpose(\n            np.array(\n                [projected_data[:, :, ind[0], ind[1]] for ind in indices]\n            ),\n            axes=(1, 2, 0),\n        )\n\n        if color_list is None:\n            colors = np.array(\n                [self.color_dict[i] for i in range(len(orbital_indices_long))]\n            )\n        else:\n            colors = color_list\n\n        self._plot_projected_general(\n            ax=ax,\n            projected_data=projected_data,\n            colors=colors,\n            scale_factor=scale_factor,\n            erange=erange,\n            display_order=display_order,\n            linewidth=linewidth,\n            band_color=band_color,\n            heatmap=heatmap,\n            bins=bins,\n            sigma=sigma,\n            cmap=cmap,\n            vlinecolor=vlinecolor,\n        )\n\n        if legend:\n            self._add_legend(\n                ax,\n                names=[\n                    f\"{i[0]}({i[1]})\"\n                    for i in zip(element_symbols_long, orbital_symbols_long)\n                ],\n                colors=colors,\n            )\n\n    def plot_element_spd(\n        self,\n        ax,\n        element_spd_dict,\n        scale_factor=5,\n        erange=[-6, 6],\n        display_order=None,\n        color_list=None,\n        legend=True,\n        linewidth=0.75,\n        band_color=\"black\",\n        heatmap=False,\n        bins=400,\n        sigma=3,\n        cmap=\"hot\",\n        vlinecolor=\"black\",\n        powernorm=False,\n        gamma=0.5,\n    ):\n        \"\"\"\n        This function plots the projected band structure on the s, p, and d orbitals for each specified element in the calculated structure.\n\n        Parameters:\n            ax (matplotlib.pyplot.axis): Axis to plot the data on\n            elements (list): List of element symbols to project onto\n            order (list): This determines the order in which the points are plotted on the\n                graph. This is an option because sometimes certain orbitals can be hidden\n                under other orbitals because they have a larger weight. For example, if the\n                signitures of the d orbitals are greater than that of the s orbitals, it\n                might be smart to choose ['d', 'p', 's'] as the order so the s orbitals are\n                plotted over the d orbitals.\n            scale_factor (float): Factor to scale weights. This changes the size of the\n                points in the scatter plot\n            color_dict (dict[str][str]): This option allow the colors of the s, p, and d\n                orbitals to be specified. Should be in the form of:\n                {'s': &lt;s color&gt;, 'p': &lt;p color&gt;, 'd': &lt;d color&gt;}\n            legend (bool): Determines if the legend should be included or not.\n            linewidth (float):12 Line width of the plain band structure plotted in the background\n            band_color (string): Color of the plain band structure\n        \"\"\"\n        element_symbols = list(element_spd_dict.keys())\n        orbital_symbols = list(element_spd_dict.values())\n        number_orbitals = [len(i) for i in orbital_symbols]\n        element_symbols_long = np.repeat(element_symbols, number_orbitals)\n        element_indices = np.repeat(\n            range(len(element_symbols)), number_orbitals\n        )\n        orbital_symbols_long = np.hstack(\n            [[o for o in orb] for orb in orbital_symbols]\n        )\n        orbital_indices = np.hstack(\n            [[self.spd_relations[o] for o in orb] for orb in orbital_symbols]\n        )\n        indices = np.vstack([element_indices, orbital_indices]).T\n\n        projected_data = self._sum_elements(elements=element_symbols, spd=True)\n        projected_data = np.transpose(\n            np.array(\n                [projected_data[:, :, ind[0], ind[1]] for ind in indices]\n            ),\n            axes=(1, 2, 0),\n        )\n\n        if color_list is None:\n            colors = np.array(\n                [self.color_dict[i] for i in range(len(orbital_symbols_long))]\n            )\n        else:\n            colors = color_list\n\n        self._plot_projected_general(\n            ax=ax,\n            projected_data=projected_data,\n            colors=colors,\n            scale_factor=scale_factor,\n            erange=erange,\n            display_order=display_order,\n            linewidth=linewidth,\n            band_color=band_color,\n            heatmap=heatmap,\n            bins=bins,\n            sigma=sigma,\n            cmap=cmap,\n            vlinecolor=vlinecolor,\n        )\n\n        if legend:\n            self._add_legend(\n                ax,\n                names=[\n                    f\"{i[0]}({i[1]})\"\n                    for i in zip(element_symbols_long, orbital_symbols_long)\n                ],\n                colors=colors,\n            )\n</code></pre>"},{"location":"band/#vaspvis.band.Band.__init__","title":"<code>__init__(folder, projected=False, unfold=False, spin='up', kpath=None, n=None, M=None, high_symm_points=None, shift_efermi=0, interpolate=True, new_n=200, custom_kpath=None, soc_axis=None, stretch_factor=1.0)</code>","text":"<p>Initialize parameters upon the generation of this class</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>projected</code> <code>bool</code> <p>Determines whether of not to parse the projected eigenvalues from the PROCAR file. Making this true increases the computational time, so only use if a projected band structure is required.</p> <code>False</code> <code>unfold</code> <code>bool</code> <p>Determines if the band structure should be unfolded or not.</p> <code>False</code> <code>spin</code> <code>str</code> <p>Choose which spin direction to parse. ('up' or 'down')</p> <code>'up'</code> <code>kpath</code> <code>str</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry point. This is also only required for unfolded calculations. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix for unfolding calculations. Can be found using the conver_slab function in the utils module.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>Coordinates of the high symmetry points of the bulk Brilloin zone for an unfolded calculation.</p> <code>None</code> <code>shift_efermi</code> <code>float</code> <p>Gives the option to shift the fermi energy by the specified value</p> <code>0</code> <code>interpolate</code> <code>bool</code> <p>Determines is the data between each high symmetry point should be interpolated or not.</p> <code>True</code> <code>new_n</code> <code>int</code> <p>New number of k-points in between each high symmetry point.</p> <code>200</code> <code>custom_kpath</code> <code>list</code> <p>Custom kpath that can be selected is the user desires. Given a path G-X-W-L-G-K then there are 5 segements to choose from [1 -&gt; G-X, 2 -&gt; X-W, 3 -&gt; W-L, 4 -&gt; L-G, 5 -&gt; G-K]. If a user wanted to plot only the path G-X-W they can set custom_kpath=[1,2]. If a user wanted to flip the k-path of a segment, then the index should be made negative, so if the desired path was G-X|L-W then custom_kpath=[1,-3]</p> <code>None</code> <code>soc_axis</code> <code>None or str</code> <p>This parameter can either take the value of None or the it can take the value of 'x', 'y', or 'z'. If either 'x', 'y', or 'z' are given then spin='up' states will be defined by positive values of this spin-component and spin='down' states will be defined by negative values of this spin-component. This will only be used for showing a pseudo-spin-polarized plot for calculations that have SOC enabled.</p> <code>None</code> <code>stretch_factor</code> <code>float</code> <p>Used to scale the eigenvalues by a certain constant. Useful for comparing to ARPES data. Default is scale_factor = 1.0 (i.e. no scaling)</p> <code>1.0</code> Source code in <code>vaspvis/band.py</code> <pre><code>def __init__(\n    self,\n    folder,\n    projected=False,\n    unfold=False,\n    spin=\"up\",\n    kpath=None,\n    n=None,\n    M=None,\n    high_symm_points=None,\n    # bandgap=False,\n    # printbg=True,\n    shift_efermi=0,\n    interpolate=True,\n    new_n=200,\n    custom_kpath=None,\n    soc_axis=None,\n    stretch_factor=1.0,\n):\n    \"\"\"\n    Initialize parameters upon the generation of this class\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        projected (bool): Determines whether of not to parse the projected\n            eigenvalues from the PROCAR file. Making this true\n            increases the computational time, so only use if a projected\n            band structure is required.\n        unfold (bool): Determines if the band structure should be unfolded or not.\n        spin (str): Choose which spin direction to parse. ('up' or 'down')\n        kpath (str): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n        n (int): Number of points between each high symmetry point.\n            This is also only required for unfolded calculations. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        M (list[list]): Transformation matrix for unfolding calculations. Can be found using\n            the conver_slab function in the utils module.\n        high_symm_points (list[list]): Coordinates of the high symmetry points of the bulk\n            Brilloin zone for an unfolded calculation.\n        shift_efermi (float): Gives the option to shift the fermi energy by the specified value\n        interpolate (bool): Determines is the data between each high symmetry point should be\n            interpolated or not.\n        new_n (int): New number of k-points in between each high symmetry point.\n        custom_kpath (list): Custom kpath that can be selected is the user desires.\n            Given a path G-X-W-L-G-K then there are 5 segements to choose from\n            [1 -&gt; G-X, 2 -&gt; X-W, 3 -&gt; W-L, 4 -&gt; L-G, 5 -&gt; G-K]. If a user wanted to\n            plot only the path G-X-W they can set custom_kpath=[1,2]. If a user wanted\n            to flip the k-path of a segment, then the index should be made negative, so\n            if the desired path was G-X|L-W then custom_kpath=[1,-3]\n        soc_axis (None or str): This parameter can either take the value of None or the\n            it can take the value of 'x', 'y', or 'z'. If either 'x', 'y', or 'z' are given\n            then spin='up' states will be defined by positive values of this spin-component\n            and spin='down' states will be defined by negative values of this spin-component.\n            This will only be used for showing a pseudo-spin-polarized plot for calculations\n            that have SOC enabled.\n        stretch_factor (float): Used to scale the eigenvalues by a certain constant. Useful for comparing to ARPES data.\n            Default is scale_factor = 1.0 (i.e. no scaling)\n    \"\"\"\n    self.interpolate = interpolate\n    self.soc_axis = soc_axis\n    self.new_n = new_n\n    self.stretch_factor = stretch_factor\n    # self.bandgap = bandgap\n    # self.printbg = printbg\n    self.eigenval = Eigenval(os.path.join(folder, \"EIGENVAL\"))\n    self.efermi = (\n        float(\n            os.popen(f'grep E-fermi {os.path.join(folder, \"OUTCAR\")}')\n            .read()\n            .split()[2]\n        )\n        + shift_efermi\n    )\n    self.poscar = Poscar.from_file(\n        os.path.join(folder, \"POSCAR\"),\n        check_for_POTCAR=False,\n        read_velocities=False,\n    )\n    self.incar = Incar.from_file(os.path.join(folder, \"INCAR\"))\n    if \"LSORBIT\" in self.incar:\n        if self.incar[\"LSORBIT\"]:\n            self.lsorbit = True\n        else:\n            self.lsorbit = False\n    else:\n        self.lsorbit = False\n\n    if \"ISPIN\" in self.incar:\n        if self.incar[\"ISPIN\"] == 2:\n            self.ispin = True\n        else:\n            self.ispin = False\n    else:\n        self.ispin = False\n\n    if \"LHFCALC\" in self.incar:\n        if self.incar[\"LHFCALC\"]:\n            self.hse = True\n        else:\n            self.hse = False\n    else:\n        self.hse = False\n\n    self.kpoints_file = Kpoints.from_file(os.path.join(folder, \"KPOINTS\"))\n\n    self.wavecar = os.path.join(folder, \"WAVECAR\")\n    self.projected = projected\n\n    self.forbitals = self._check_f_orb()\n    self.unfold = unfold\n\n    if self.hse and self.unfold:\n        self.hse = False\n\n    self.kpath = kpath\n    self.n = n\n    self.M = M\n    self.high_symm_points = high_symm_points\n    self.folder = folder\n    self.spin = spin\n    self.spin_dict = {\"up\": Spin.up, \"down\": Spin.down}\n    if not self.unfold:\n        self.pre_loaded_bands = os.path.isfile(\n            os.path.join(folder, \"eigenvalues.npy\")\n        )\n        self.eigenvalues, self.kpoints = self._load_bands()\n    else:\n        self.pre_loaded_bands = os.path.isfile(\n            os.path.join(folder, \"unfolded_eigenvalues.npy\")\n        )\n        (\n            self.eigenvalues,\n            self.spectral_weights,\n            self.K_indices,\n            self.kpoints,\n        ) = self._load_bands_unfold()\n\n    if self.stretch_factor != 1.0:\n        self.eigenvalues *= self.stretch_factor\n\n    self.color_dict = {\n        0: \"#FF0000\",\n        1: \"#0000FF\",\n        2: \"#008000\",\n        3: \"#800080\",\n        4: \"#E09200\",\n        5: \"#FF5C77\",\n        6: \"#778392\",\n        7: \"#07C589\",\n        8: \"#40BAF2\",\n        9: \"#FF0000\",\n        10: \"#0000FF\",\n        11: \"#008000\",\n        12: \"#800080\",\n        13: \"#E09200\",\n        14: \"#FF5C77\",\n        15: \"#778392\",\n    }\n    self.orbital_labels = {\n        0: \"s\",\n        1: \"p_{y}\",\n        2: \"p_{z}\",\n        3: \"p_{x}\",\n        4: \"d_{xy}\",\n        5: \"d_{yz}\",\n        6: \"d_{z^{2}}\",\n        7: \"d_{xz}\",\n        8: \"d_{x^{2}-y^{2}}\",\n        9: \"f_{y^{3}x^{2}}\",\n        10: \"f_{xyz}\",\n        11: \"f_{yz^{2}}\",\n        12: \"f_{z^{3}}\",\n        13: \"f_{xz^{2}}\",\n        14: \"f_{zx^{3}}\",\n        15: \"f_{x^{3}}\",\n    }\n    self.spd_relations = {\n        \"s\": 0,\n        \"p\": 1,\n        \"d\": 2,\n        \"f\": 3,\n    }\n    # if self.bandgap:\n    #     self.bg = self._get_bandgap()\n    # else:\n    #     self.bg = None\n\n    self.custom_kpath = custom_kpath\n    if self.custom_kpath is not None:\n        (\n            self.custom_kpath_inds,\n            self.custom_kpath_flip,\n        ) = self._get_custom_kpath()\n    #  else:\n    #  self.custom_kpath_inds, self.custom_kpath_flip = None, None\n\n    if projected:\n        self.pre_loaded_projections = os.path.isfile(\n            os.path.join(folder, \"projected_eigenvalues.npy\")\n        )\n        self.projected_eigenvalues = self._load_projected_bands()\n\n    if soc_axis is not None and self.lsorbit:\n        self.pre_loaded_spin_projections = os.path.isfile(\n            os.path.join(folder, \"spin_projections.npy\")\n        )\n        self.spin_projections = self._load_soc_spin_projection()\n</code></pre>"},{"location":"band/#vaspvis.band.Band.plot_atom_orbitals","title":"<code>plot_atom_orbitals(ax, atom_orbital_dict, scale_factor=5, erange=[-6, 6], display_order=None, color_list=None, legend=True, linewidth=0.75, band_color='black', heatmap=False, bins=400, sigma=3, cmap='hot', vlinecolor='black', powernorm=False, gamma=0.5)</code>","text":"<p>This function plots the projected band structure of individual orbitals on a given axis.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>axis</code> <p>Axis to plot the data on</p> required <code>atom_orbital_pairs</code> <code>list[list]</code> <p>Selected orbitals on selected atoms to plot. This should take the form of [[atom index, orbital_index], ...]. To plot the px orbital of the 1st atom and the pz orbital of the 2nd atom in the POSCAR file, the input would be [[0, 3], [1, 2]]</p> required <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot</p> <code>5</code> <code>color_list</code> <code>list</code> <p>List of colors of the same length as the atom_orbital_pairs</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure</p> <code>'black'</code> Source code in <code>vaspvis/band.py</code> <pre><code>def plot_atom_orbitals(\n    self,\n    ax,\n    atom_orbital_dict,\n    scale_factor=5,\n    erange=[-6, 6],\n    display_order=None,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    heatmap=False,\n    bins=400,\n    sigma=3,\n    cmap=\"hot\",\n    vlinecolor=\"black\",\n    powernorm=False,\n    gamma=0.5,\n):\n    \"\"\"\n    This function plots the projected band structure of individual orbitals on a given axis.\n\n    Parameters:\n        ax (matplotlib.pyplot.axis): Axis to plot the data on\n        atom_orbital_pairs (list[list]): Selected orbitals on selected atoms to plot.\n            This should take the form of [[atom index, orbital_index], ...].\n            To plot the px orbital of the 1st atom and the pz orbital of the 2nd atom\n            in the POSCAR file, the input would be [[0, 3], [1, 2]]\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot\n        color_list (list): List of colors of the same length as the atom_orbital_pairs\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background\n        band_color (string): Color of the plain band structure\n    \"\"\"\n\n    atom_indices = list(atom_orbital_dict.keys())\n    orbital_indices = list(atom_orbital_dict.values())\n    number_orbitals = [len(i) for i in orbital_indices]\n    atom_indices = np.repeat(atom_indices, number_orbitals)\n    orbital_symbols_long = np.hstack(\n        [[self.orbital_labels[o] for o in orb] for orb in orbital_indices]\n    )\n    orbital_indices_long = np.hstack(orbital_indices)\n    indices = np.vstack([atom_indices, orbital_indices_long]).T\n\n    projected_data = self.projected_eigenvalues\n    projected_data = np.transpose(\n        np.array(\n            [projected_data[:, :, ind[0], ind[1]] for ind in indices]\n        ),\n        axes=(1, 2, 0),\n    )\n\n    if color_list is None:\n        colors = np.array(\n            [self.color_dict[i] for i in range(len(orbital_indices_long))]\n        )\n    else:\n        colors = color_list\n\n    self._plot_projected_general(\n        ax=ax,\n        projected_data=projected_data,\n        colors=colors,\n        scale_factor=scale_factor,\n        erange=erange,\n        display_order=display_order,\n        linewidth=linewidth,\n        band_color=band_color,\n        heatmap=heatmap,\n        bins=bins,\n        sigma=sigma,\n        cmap=cmap,\n        vlinecolor=vlinecolor,\n    )\n\n    if legend:\n        self._add_legend(\n            ax,\n            names=[\n                f\"{i[0]}({i[1]})\"\n                for i in zip(atom_indices, orbital_symbols_long)\n            ],\n            colors=colors,\n        )\n</code></pre>"},{"location":"band/#vaspvis.band.Band.plot_atom_spd","title":"<code>plot_atom_spd(ax, atom_spd_dict, scale_factor=5, erange=[-6, 6], display_order=None, color_list=None, legend=True, linewidth=0.75, band_color='black', heatmap=False, bins=400, sigma=3, cmap='hot', vlinecolor='black', powernorm=False, gamma=0.5)</code>","text":"<p>This function plots the projected band structure on the s, p, and d orbitals for each specified atom in the calculated structure.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>axis</code> <p>Axis to plot the data on</p> required <code>atom_spd_dict</code> <code>dict</code> <p>Dictionary to determine the atom and spd orbitals to project onto Format: {0: 'spd', 1: 'sp', 2: 's'} where 0,1,2 are atom indicies in the POSCAR</p> required <code>display_order</code> <code>None or str</code> <p>The available options are None, 'all', 'dominant' where None plots the scatter points in the order presented in the atom_spd_dict, 'all' plots the scatter points largest --&gt; smallest to all points are visable, and 'dominant' plots the scatter points smallest --&gt; largest so only the dominant color is visable.</p> <code>None</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot</p> <code>5</code> <code>color_dict</code> <code>dict[str][str]</code> <p>This option allow the colors of the s, p, and d orbitals to be specified. Should be in the form of: {'s': , 'p': <p>, 'd': } required <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure</p> <code>'black'</code> Source code in <code>vaspvis/band.py</code> <pre><code>def plot_atom_spd(\n    self,\n    ax,\n    atom_spd_dict,\n    scale_factor=5,\n    erange=[-6, 6],\n    display_order=None,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    heatmap=False,\n    bins=400,\n    sigma=3,\n    cmap=\"hot\",\n    vlinecolor=\"black\",\n    powernorm=False,\n    gamma=0.5,\n):\n    \"\"\"\n    This function plots the projected band structure on the s, p, and d orbitals for each specified atom in the calculated structure.\n\n    Parameters:\n        ax (matplotlib.pyplot.axis): Axis to plot the data on\n        atom_spd_dict (dict): Dictionary to determine the atom and spd orbitals to project onto\n            Format: {0: 'spd', 1: 'sp', 2: 's'} where 0,1,2 are atom indicies in the POSCAR\n        display_order (None or str): The available options are None, 'all', 'dominant' where None\n            plots the scatter points in the order presented in the atom_spd_dict, 'all' plots the\n            scatter points largest --&gt; smallest to all points are visable, and 'dominant' plots\n            the scatter points smallest --&gt; largest so only the dominant color is visable.\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot\n        color_dict (dict[str][str]): This option allow the colors of the s, p, and d\n            orbitals to be specified. Should be in the form of:\n            {'s': &lt;s color&gt;, 'p': &lt;p color&gt;, 'd': &lt;d color&gt;}\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background\n        band_color (string): Color of the plain band structure\n    \"\"\"\n    atom_indices = list(atom_spd_dict.keys())\n    orbital_symbols = list(atom_spd_dict.values())\n    number_orbitals = [len(i) for i in orbital_symbols]\n    atom_indices = np.repeat(atom_indices, number_orbitals)\n    orbital_symbols_long = np.hstack(\n        [[o for o in orb] for orb in orbital_symbols]\n    )\n    orbital_indices = np.hstack(\n        [[self.spd_relations[o] for o in orb] for orb in orbital_symbols]\n    )\n    indices = np.vstack([atom_indices, orbital_indices]).T\n\n    projected_data = self._sum_atoms(atoms=atom_indices, spd=True)\n    projected_data = np.transpose(\n        np.array(\n            [projected_data[:, :, ind[0], ind[1]] for ind in indices]\n        ),\n        axes=(1, 2, 0),\n    )\n\n    if color_list is None:\n        colors = np.array(\n            [self.color_dict[i] for i in range(len(orbital_symbols_long))]\n        )\n    else:\n        colors = color_list\n\n    self._plot_projected_general(\n        ax=ax,\n        projected_data=projected_data,\n        colors=colors,\n        scale_factor=scale_factor,\n        erange=erange,\n        display_order=display_order,\n        linewidth=linewidth,\n        band_color=band_color,\n        heatmap=heatmap,\n        bins=bins,\n        sigma=sigma,\n        cmap=cmap,\n        vlinecolor=vlinecolor,\n    )\n\n    if legend:\n        self._add_legend(\n            ax,\n            names=[\n                f\"{i[0]}({i[1]})\"\n                for i in zip(atom_indices, orbital_symbols_long)\n            ],\n            colors=colors,\n        )\n</code></pre>"},{"location":"band/#vaspvis.band.Band.plot_atoms","title":"<code>plot_atoms(ax, atoms, scale_factor=5, erange=[-6, 6], display_order=None, color_list=None, legend=True, linewidth=0.75, band_color='black', heatmap=False, bins=400, sigma=3, cmap='hot', vlinecolor='black', powernorm=False, gamma=0.5)</code>","text":"<p>This function plots the projected band structure of given atoms summed across all orbitals on a given axis.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>axis</code> <p>Axis to plot the data on</p> required <code>atoms</code> <code>list</code> <p>List of atoms to project onto</p> required <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot</p> <code>5</code> <code>color_list</code> <code>list</code> <p>List of colors of the same length as the atoms list</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure</p> <code>'black'</code> Source code in <code>vaspvis/band.py</code> <pre><code>def plot_atoms(\n    self,\n    ax,\n    atoms,\n    scale_factor=5,\n    erange=[-6, 6],\n    display_order=None,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    heatmap=False,\n    bins=400,\n    sigma=3,\n    cmap=\"hot\",\n    vlinecolor=\"black\",\n    powernorm=False,\n    gamma=0.5,\n):\n    \"\"\"\n    This function plots the projected band structure of given atoms summed across all orbitals on a given axis.\n\n    Parameters:\n        ax (matplotlib.pyplot.axis): Axis to plot the data on\n        atoms (list): List of atoms to project onto\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot\n        color_list (list): List of colors of the same length as the atoms list\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background\n        band_color (string): Color of the plain band structure\n    \"\"\"\n    if color_list is None:\n        colors = np.array([self.color_dict[i] for i in range(len(atoms))])\n    else:\n        colors = color_list\n\n    projected_data = self._sum_atoms(atoms=atoms)\n\n    self._plot_projected_general(\n        ax=ax,\n        projected_data=projected_data,\n        colors=colors,\n        scale_factor=scale_factor,\n        erange=erange,\n        display_order=display_order,\n        linewidth=linewidth,\n        band_color=band_color,\n        heatmap=heatmap,\n        bins=bins,\n        sigma=sigma,\n        cmap=cmap,\n        vlinecolor=vlinecolor,\n    )\n\n    if legend:\n        self._add_legend(ax, names=atoms, colors=colors)\n</code></pre>"},{"location":"band/#vaspvis.band.Band.plot_element_orbitals","title":"<code>plot_element_orbitals(ax, element_orbital_dict, scale_factor=5, erange=[-6, 6], display_order=None, color_list=None, legend=True, linewidth=0.75, band_color='black', heatmap=False, bins=400, sigma=3, cmap='hot', vlinecolor='black', powernorm=False, gamma=0.5)</code>","text":"<p>this function plots the projected band structure on chosen orbitals for each specified element in the calculated structure.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>axis</code> <p>axis to plot the data on</p> required <code>element_orbital_pairs</code> <code>list[list]</code> <p>List of list in the form of [[element symbol, orbital index], [element symbol, orbital_index], ...]</p> required <code>scale_factor</code> <code>float</code> <p>factor to scale weights. this changes the size of the points in the scatter plot</p> <code>5</code> <code>color_list</code> <code>list</code> <p>List of colors of the same length as the element_orbital_pairs</p> <code>None</code> <code>legend</code> <code>bool</code> <p>determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>line width of the plain band structure plotted in the background</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>color of the plain band structure</p> <code>'black'</code> Source code in <code>vaspvis/band.py</code> <pre><code>def plot_element_orbitals(\n    self,\n    ax,\n    element_orbital_dict,\n    scale_factor=5,\n    erange=[-6, 6],\n    display_order=None,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    heatmap=False,\n    bins=400,\n    sigma=3,\n    cmap=\"hot\",\n    vlinecolor=\"black\",\n    powernorm=False,\n    gamma=0.5,\n):\n    \"\"\"\n    this function plots the projected band structure on chosen orbitals for each specified element in the calculated structure.\n\n    Parameters:\n        ax (matplotlib.pyplot.axis): axis to plot the data on\n        element_orbital_pairs (list[list]): List of list in the form of\n            [[element symbol, orbital index], [element symbol, orbital_index], ...]\n        scale_factor (float): factor to scale weights. this changes the size of the\n            points in the scatter plot\n        color_list (list): List of colors of the same length as the element_orbital_pairs\n        legend (bool): determines if the legend should be included or not.\n        linewidth (float): line width of the plain band structure plotted in the background\n        band_color (string): color of the plain band structure\n    \"\"\"\n    element_symbols = list(element_orbital_dict.keys())\n    orbital_indices = list(element_orbital_dict.values())\n    number_orbitals = [len(i) for i in orbital_indices]\n    element_symbols_long = np.repeat(element_symbols, number_orbitals)\n    element_indices = np.repeat(\n        range(len(element_symbols)), number_orbitals\n    )\n    orbital_symbols_long = np.hstack(\n        [[self.orbital_labels[o] for o in orb] for orb in orbital_indices]\n    )\n    orbital_indices_long = np.hstack(orbital_indices)\n    indices = np.vstack([element_indices, orbital_indices_long]).T\n\n    projected_data = self._sum_elements(\n        elements=element_symbols, orbitals=True\n    )\n    projected_data = np.transpose(\n        np.array(\n            [projected_data[:, :, ind[0], ind[1]] for ind in indices]\n        ),\n        axes=(1, 2, 0),\n    )\n\n    if color_list is None:\n        colors = np.array(\n            [self.color_dict[i] for i in range(len(orbital_indices_long))]\n        )\n    else:\n        colors = color_list\n\n    self._plot_projected_general(\n        ax=ax,\n        projected_data=projected_data,\n        colors=colors,\n        scale_factor=scale_factor,\n        erange=erange,\n        display_order=display_order,\n        linewidth=linewidth,\n        band_color=band_color,\n        heatmap=heatmap,\n        bins=bins,\n        sigma=sigma,\n        cmap=cmap,\n        vlinecolor=vlinecolor,\n    )\n\n    if legend:\n        self._add_legend(\n            ax,\n            names=[\n                f\"{i[0]}({i[1]})\"\n                for i in zip(element_symbols_long, orbital_symbols_long)\n            ],\n            colors=colors,\n        )\n</code></pre>"},{"location":"band/#vaspvis.band.Band.plot_element_spd","title":"<code>plot_element_spd(ax, element_spd_dict, scale_factor=5, erange=[-6, 6], display_order=None, color_list=None, legend=True, linewidth=0.75, band_color='black', heatmap=False, bins=400, sigma=3, cmap='hot', vlinecolor='black', powernorm=False, gamma=0.5)</code>","text":"<p>This function plots the projected band structure on the s, p, and d orbitals for each specified element in the calculated structure.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>axis</code> <p>Axis to plot the data on</p> required <code>elements</code> <code>list</code> <p>List of element symbols to project onto</p> required <code>order</code> <code>list</code> <p>This determines the order in which the points are plotted on the graph. This is an option because sometimes certain orbitals can be hidden under other orbitals because they have a larger weight. For example, if the signitures of the d orbitals are greater than that of the s orbitals, it might be smart to choose ['d', 'p', 's'] as the order so the s orbitals are plotted over the d orbitals.</p> required <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot</p> <code>5</code> <code>color_dict</code> <code>dict[str][str]</code> <p>This option allow the colors of the s, p, and d orbitals to be specified. Should be in the form of: {'s': , 'p': <p>, 'd': } required <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>12 Line width of the plain band structure plotted in the background</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure</p> <code>'black'</code> Source code in <code>vaspvis/band.py</code> <pre><code>def plot_element_spd(\n    self,\n    ax,\n    element_spd_dict,\n    scale_factor=5,\n    erange=[-6, 6],\n    display_order=None,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    heatmap=False,\n    bins=400,\n    sigma=3,\n    cmap=\"hot\",\n    vlinecolor=\"black\",\n    powernorm=False,\n    gamma=0.5,\n):\n    \"\"\"\n    This function plots the projected band structure on the s, p, and d orbitals for each specified element in the calculated structure.\n\n    Parameters:\n        ax (matplotlib.pyplot.axis): Axis to plot the data on\n        elements (list): List of element symbols to project onto\n        order (list): This determines the order in which the points are plotted on the\n            graph. This is an option because sometimes certain orbitals can be hidden\n            under other orbitals because they have a larger weight. For example, if the\n            signitures of the d orbitals are greater than that of the s orbitals, it\n            might be smart to choose ['d', 'p', 's'] as the order so the s orbitals are\n            plotted over the d orbitals.\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot\n        color_dict (dict[str][str]): This option allow the colors of the s, p, and d\n            orbitals to be specified. Should be in the form of:\n            {'s': &lt;s color&gt;, 'p': &lt;p color&gt;, 'd': &lt;d color&gt;}\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float):12 Line width of the plain band structure plotted in the background\n        band_color (string): Color of the plain band structure\n    \"\"\"\n    element_symbols = list(element_spd_dict.keys())\n    orbital_symbols = list(element_spd_dict.values())\n    number_orbitals = [len(i) for i in orbital_symbols]\n    element_symbols_long = np.repeat(element_symbols, number_orbitals)\n    element_indices = np.repeat(\n        range(len(element_symbols)), number_orbitals\n    )\n    orbital_symbols_long = np.hstack(\n        [[o for o in orb] for orb in orbital_symbols]\n    )\n    orbital_indices = np.hstack(\n        [[self.spd_relations[o] for o in orb] for orb in orbital_symbols]\n    )\n    indices = np.vstack([element_indices, orbital_indices]).T\n\n    projected_data = self._sum_elements(elements=element_symbols, spd=True)\n    projected_data = np.transpose(\n        np.array(\n            [projected_data[:, :, ind[0], ind[1]] for ind in indices]\n        ),\n        axes=(1, 2, 0),\n    )\n\n    if color_list is None:\n        colors = np.array(\n            [self.color_dict[i] for i in range(len(orbital_symbols_long))]\n        )\n    else:\n        colors = color_list\n\n    self._plot_projected_general(\n        ax=ax,\n        projected_data=projected_data,\n        colors=colors,\n        scale_factor=scale_factor,\n        erange=erange,\n        display_order=display_order,\n        linewidth=linewidth,\n        band_color=band_color,\n        heatmap=heatmap,\n        bins=bins,\n        sigma=sigma,\n        cmap=cmap,\n        vlinecolor=vlinecolor,\n    )\n\n    if legend:\n        self._add_legend(\n            ax,\n            names=[\n                f\"{i[0]}({i[1]})\"\n                for i in zip(element_symbols_long, orbital_symbols_long)\n            ],\n            colors=colors,\n        )\n</code></pre>"},{"location":"band/#vaspvis.band.Band.plot_elements","title":"<code>plot_elements(ax, elements, scale_factor=5, erange=[-6, 6], display_order=None, color_list=None, legend=True, linewidth=0.75, band_color='black', heatmap=False, bins=400, sigma=3, cmap='hot', vlinecolor='black', powernorm=False, gamma=0.5)</code>","text":"<p>This function plots the projected band structure on specified elements in the calculated structure</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>axis</code> <p>Axis to plot the data on</p> required <code>elements</code> <code>list</code> <p>List of element symbols to project onto</p> required <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot</p> <code>5</code> <code>color_list</code> <code>list</code> <p>List of colors of the same length as the elements list</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure</p> <code>'black'</code> Source code in <code>vaspvis/band.py</code> <pre><code>def plot_elements(\n    self,\n    ax,\n    elements,\n    scale_factor=5,\n    erange=[-6, 6],\n    display_order=None,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    heatmap=False,\n    bins=400,\n    sigma=3,\n    cmap=\"hot\",\n    vlinecolor=\"black\",\n    powernorm=False,\n    gamma=0.5,\n):\n    \"\"\"\n    This function plots the projected band structure on specified elements in the calculated structure\n\n    Parameters:\n        ax (matplotlib.pyplot.axis): Axis to plot the data on\n        elements (list): List of element symbols to project onto\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot\n        color_list (list): List of colors of the same length as the elements list\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background\n        band_color (string): Color of the plain band structure\n    \"\"\"\n    if color_list is None:\n        colors = np.array(\n            [self.color_dict[i] for i in range(len(elements))]\n        )\n    else:\n        colors = color_list\n\n    projected_data = self._sum_elements(elements=elements)\n\n    self._plot_projected_general(\n        ax=ax,\n        projected_data=projected_data,\n        colors=colors,\n        scale_factor=scale_factor,\n        erange=erange,\n        display_order=display_order,\n        linewidth=linewidth,\n        band_color=band_color,\n        heatmap=heatmap,\n        bins=bins,\n        sigma=sigma,\n        cmap=cmap,\n        vlinecolor=vlinecolor,\n    )\n\n    if legend:\n        self._add_legend(ax, names=elements, colors=colors)\n</code></pre>"},{"location":"band/#vaspvis.band.Band.plot_orbitals","title":"<code>plot_orbitals(ax, orbitals, scale_factor=5, erange=[-6, 6], display_order=None, color_list=None, legend=True, linewidth=0.75, band_color='black', heatmap=False, bins=400, sigma=3, cmap='hot', vlinecolor='black', powernorm=False, gamma=0.5)</code>","text":"<p>This function plots the projected band structure of given orbitals summed across all atoms on a given axis.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>axis</code> <p>Axis to plot the data on</p> required <code>orbitals</code> <code>list</code> <p>List of orbits to compare</p> <p>| 0 = s | 1 = py | 2 = pz | 3 = px | 4 = dxy | 5 = dyz | 6 = dz2 | 7 = dxz | 8 = dx2-y2 | 9 = fy3x2 | 10 = fxyz | 11 = fyz2 | 12 = fz3 | 13 = fxz2 | 14 = fzx3 | 15 = fx3</p> required <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot</p> <code>5</code> <code>color_dict</code> <code>dict[str][str]</code> <p>This option allow the colors of each orbital specified. Should be in the form of: {'orbital index': , 'orbital index': , ...} required <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure</p> <code>'black'</code> Source code in <code>vaspvis/band.py</code> <pre><code>def plot_orbitals(\n    self,\n    ax,\n    orbitals,\n    scale_factor=5,\n    erange=[-6, 6],\n    display_order=None,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    heatmap=False,\n    bins=400,\n    sigma=3,\n    cmap=\"hot\",\n    vlinecolor=\"black\",\n    powernorm=False,\n    gamma=0.5,\n):\n    \"\"\"\n    This function plots the projected band structure of given orbitals summed across all atoms on a given axis.\n\n    Parameters:\n        ax (matplotlib.pyplot.axis): Axis to plot the data on\n        orbitals (list): List of orbits to compare\n\n            | 0 = s\n            | 1 = py\n            | 2 = pz\n            | 3 = px\n            | 4 = dxy\n            | 5 = dyz\n            | 6 = dz2\n            | 7 = dxz\n            | 8 = dx2-y2\n            | 9 = fy3x2\n            | 10 = fxyz\n            | 11 = fyz2\n            | 12 = fz3\n            | 13 = fxz2\n            | 14 = fzx3\n            | 15 = fx3\n\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot\n        color_dict (dict[str][str]): This option allow the colors of each orbital\n            specified. Should be in the form of:\n            {'orbital index': &lt;color&gt;, 'orbital index': &lt;color&gt;, ...}\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background\n        band_color (string): Color of the plain band structure\n    \"\"\"\n\n    if color_list is None:\n        colors = np.array([self.color_dict[i] for i in orbitals])\n    else:\n        colors = color_list\n\n    projected_data = self._sum_orbitals(orbitals=orbitals)\n\n    self._plot_projected_general(\n        ax=ax,\n        projected_data=projected_data,\n        colors=colors,\n        scale_factor=scale_factor,\n        erange=erange,\n        display_order=display_order,\n        linewidth=linewidth,\n        band_color=band_color,\n        heatmap=heatmap,\n        bins=bins,\n        sigma=sigma,\n        cmap=cmap,\n        vlinecolor=vlinecolor,\n    )\n\n    if legend:\n        self._add_legend(\n            ax,\n            names=[self.orbital_labels[i] for i in orbitals],\n            colors=colors,\n        )\n</code></pre>"},{"location":"band/#vaspvis.band.Band.plot_plain","title":"<code>plot_plain(ax, color='black', erange=[-6, 6], linewidth=1.25, scale_factor=20, linestyle='-', heatmap=False, bins=400, sigma=3, cmap='hot', vlinecolor='black', powernorm=False, gamma=0.5, projection=None, highlight_band=False, highlight_band_color='red', band_index=None, sp_color='red', sp_scale_factor=5)</code>","text":"<p>This function plots a plain band structure.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>axis</code> <p>Axis to plot the data on</p> required <code>color</code> <code>str</code> <p>Color of the band structure lines</p> <code>'black'</code> <code>linewidth</code> <code>float</code> <p>Line width of the band structure lines</p> <code>1.25</code> <code>linestyle</code> <code>str</code> <p>Line style of the bands</p> <code>'-'</code> Source code in <code>vaspvis/band.py</code> <pre><code>def plot_plain(\n    self,\n    ax,\n    color=\"black\",\n    erange=[-6, 6],\n    linewidth=1.25,\n    scale_factor=20,\n    linestyle=\"-\",\n    heatmap=False,\n    bins=400,\n    sigma=3,\n    cmap=\"hot\",\n    vlinecolor=\"black\",\n    powernorm=False,\n    gamma=0.5,\n    projection=None,\n    highlight_band=False,\n    highlight_band_color=\"red\",\n    band_index=None,\n    sp_color=\"red\",\n    sp_scale_factor=5,\n):\n    \"\"\"\n    This function plots a plain band structure.\n\n    Parameters:\n        ax (matplotlib.pyplot.axis): Axis to plot the data on\n        color (str): Color of the band structure lines\n        linewidth (float): Line width of the band structure lines\n        linestyle (str): Line style of the bands\n    \"\"\"\n    bands_in_plot = self._filter_bands(erange=erange)\n    slices = self._get_slices(unfold=self.unfold, hse=self.hse)\n    wave_vector_segments = self._get_k_distance()\n\n    # if self.soc_axis is not None and self.lsorbit:\n    #     color = \"black\"\n    #     linestyle = \"-\"\n\n    if self.soc_axis is not None and self.lsorbit:\n        if self.unfold:\n            K_indices = np.array(self.K_indices[0], dtype=int)\n            spin_projection_full_k = self.spin_projections[:, K_indices]\n        else:\n            spin_projection_full_k = self.spin_projections\n\n    if self.custom_kpath is not None:\n        kpath_inds = self.custom_kpath_inds\n        kpath_flip = self.custom_kpath_flip\n    else:\n        kpath_inds = range(len(slices))\n        kpath_flip = [False for _ in range(len(slices))]\n\n    for i, f, wave_vectors in zip(\n        kpath_inds, kpath_flip, wave_vector_segments\n    ):\n        if f:\n            eigenvalues = np.flip(\n                self.eigenvalues[bands_in_plot, slices[i]], axis=1\n            )\n            if self.soc_axis is not None and self.lsorbit:\n                spin_projections = np.flip(\n                    spin_projection_full_k[bands_in_plot, slices[i]],\n                    axis=1,\n                )\n        else:\n            eigenvalues = self.eigenvalues[bands_in_plot, slices[i]]\n            if self.soc_axis is not None and self.lsorbit:\n                spin_projections = spin_projection_full_k[\n                    bands_in_plot, slices[i]\n                ]\n\n        if highlight_band:\n            if band_index is not None:\n                if type(band_index) == int:\n                    highlight_eigenvalues = self.eigenvalues[\n                        int(band_index), slices[i]\n                    ]\n                else:\n                    highlight_eigenvalues = self.eigenvalues[\n                        band_index, slices[i]\n                    ]\n\n        wave_vectors_for_kpoints = wave_vectors\n\n        if self.interpolate:\n            (\n                wave_vectors,\n                eigenvalues,\n            ) = self._get_interpolated_data_segment(\n                wave_vectors_for_kpoints,\n                eigenvalues,\n            )\n            if self.soc_axis is not None and self.lsorbit:\n                _, spin_projections = self._get_interpolated_data_segment(\n                    wave_vectors_for_kpoints,\n                    spin_projections,\n                    crop_zero=True,\n                    kind=\"linear\",\n                )\n\n            if highlight_band:\n                if band_index is not None:\n                    (\n                        _,\n                        highlight_eigenvalues,\n                    ) = self._get_interpolated_data_segment(\n                        wave_vectors_for_kpoints,\n                        highlight_eigenvalues,\n                    )\n\n        eigenvalues_ravel = np.ravel(\n            np.c_[eigenvalues, np.empty(eigenvalues.shape[0]) * np.nan]\n        )\n        wave_vectors_tile = np.tile(\n            np.append(wave_vectors, np.nan), eigenvalues.shape[0]\n        )\n\n        if self.soc_axis is not None and self.lsorbit:\n            #  spin_cmap = self._alpha_cmap(color=spin_projection_color, repeats=1)\n            spin_projections_ravel = np.ravel(\n                np.c_[\n                    spin_projections,\n                    np.empty(spin_projections.shape[0]) * np.nan,\n                ]\n            )\n            #  spin_colors = [spin_cmap(s) for s in spin_projections_ravel]\n\n        if self.unfold:\n            spectral_weights = self.spectral_weights[\n                bands_in_plot, slices[i]\n            ]\n            if f:\n                spectral_weights = np.flip(spectral_weights, axis=1)\n            #  spectral_weights = spectral_weights / np.max(spectral_weights)\n\n            if highlight_band:\n                if band_index is not None:\n                    highlight_spectral_weights = self.spectral_weights[\n                        int(band_index), slices[i]\n                    ]\n\n            if self.interpolate:\n                _, spectral_weights = self._get_interpolated_data_segment(\n                    wave_vectors_for_kpoints,\n                    spectral_weights,\n                    crop_zero=True,\n                    kind=\"linear\",\n                )\n\n                if highlight_band:\n                    if band_index is not None:\n                        (\n                            _,\n                            highlight_spectral_weights,\n                        ) = self._get_interpolated_data_segment(\n                            wave_vectors_for_kpoints,\n                            highlight_spectral_weights,\n                            crop_zero=True,\n                            kind=\"linear\",\n                        )\n\n            spectral_weights_ravel = np.ravel(\n                np.c_[\n                    spectral_weights,\n                    np.empty(spectral_weights.shape[0]) * np.nan,\n                ]\n            )\n\n            if heatmap:\n                self._heatmap(\n                    ax=ax,\n                    wave_vectors=wave_vectors,\n                    eigenvalues=eigenvalues,\n                    weights=spectral_weights,\n                    sigma=sigma,\n                    cmap=cmap,\n                    bins=bins,\n                    projection=projection,\n                    powernorm=powernorm,\n                    gamma=gamma,\n                )\n            else:\n                ax.scatter(\n                    wave_vectors_tile,\n                    eigenvalues_ravel,\n                    c=color,\n                    ec=None,\n                    s=scale_factor * spectral_weights_ravel,\n                    zorder=0,\n                )\n                if highlight_band:\n                    if band_index is not None:\n                        if type(band_index) == int:\n                            ax.scatter(\n                                wave_vectors,\n                                highlight_eigenvalues,\n                                c=highlight_band_color,\n                                ec=None,\n                                s=scale_factor\n                                * highlight_spectral_weights,\n                                zorder=100,\n                            )\n                        else:\n                            ax.scatter(\n                                np.tile(\n                                    np.append(wave_vectors, np.nan),\n                                    highlight_eigenvalues.shape[0],\n                                ),\n                                np.ravel(\n                                    np.c_[\n                                        highlight_eigenvalues,\n                                        np.empty(\n                                            highlight_eigenvalues.shape[0]\n                                        )\n                                        * np.nan,\n                                    ]\n                                ),\n                                c=highlight_band_color,\n                                ec=None,\n                                s=scale_factor\n                                * np.ravel(highlight_spectral_weights),\n                                zorder=100,\n                            )\n                if self.soc_axis is not None and self.lsorbit:\n                    ax.scatter(\n                        wave_vectors_tile,\n                        eigenvalues_ravel,\n                        s=spectral_weights_ravel\n                        * sp_scale_factor\n                        * spin_projections_ravel,\n                        c=sp_color,\n                        zorder=100,\n                    )\n        else:\n            if heatmap:\n                self._heatmap(\n                    ax=ax,\n                    wave_vectors=wave_vectors,\n                    eigenvalues=eigenvalues,\n                    weights=np.ones(eigenvalues.shape),\n                    sigma=sigma,\n                    cmap=cmap,\n                    bins=bins,\n                    projection=projection,\n                    powernorm=powernorm,\n                    gamma=gamma,\n                )\n            else:\n                ax.plot(\n                    wave_vectors_tile,\n                    eigenvalues_ravel,\n                    color=color,\n                    linewidth=linewidth,\n                    linestyle=linestyle,\n                    zorder=0,\n                )\n                if highlight_band:\n                    if band_index is not None:\n                        if type(band_index) == int:\n                            ax.plot(\n                                wave_vectors,\n                                highlight_eigenvalues,\n                                color=highlight_band_color,\n                                linewidth=linewidth,\n                                linestyle=linestyle,\n                                zorder=100,\n                            )\n                        else:\n                            ax.plot(\n                                np.tile(\n                                    np.append(wave_vectors, np.nan),\n                                    highlight_eigenvalues.shape[0],\n                                ),\n                                np.ravel(\n                                    np.c_[\n                                        highlight_eigenvalues,\n                                        np.empty(\n                                            highlight_eigenvalues.shape[0]\n                                        )\n                                        * np.nan,\n                                    ]\n                                ),\n                                color=highlight_band_color,\n                                linewidth=linewidth,\n                                linestyle=linestyle,\n                                zorder=100,\n                            )\n                if self.soc_axis is not None and self.lsorbit:\n                    ax.scatter(\n                        wave_vectors_tile,\n                        eigenvalues_ravel,\n                        s=sp_scale_factor * spin_projections_ravel,\n                        c=sp_color,\n                        zorder=100,\n                    )\n\n    if self.hse:\n        self._get_kticks_hse(\n            ax=ax,\n            wave_vectors=np.concatenate(self._get_k_distance()),\n            kpath=self.kpath,\n            vlinecolor=vlinecolor,\n        )\n    elif self.unfold:\n        self._get_kticks_unfold(\n            ax=ax,\n            wave_vectors=np.concatenate(self._get_k_distance()),\n            vlinecolor=vlinecolor,\n        )\n    else:\n        self._get_kticks(\n            ax=ax,\n            wave_vectors=np.concatenate(self._get_k_distance()),\n            vlinecolor=vlinecolor,\n        )\n\n    ax.set_xlim(0, np.concatenate(self._get_k_distance()).max())\n</code></pre>"},{"location":"band/#vaspvis.band.Band.plot_plain_old","title":"<code>plot_plain_old(ax, color='black', erange=[-6, 6], linewidth=1.25, scale_factor=20, linestyle='-', heatmap=False, bins=400, sigma=3, cmap='hot', vlinecolor='black', powernorm=False, gamma=0.5, projection=None, highlight_band=False, highlight_band_color='red', band_index=None)</code>","text":"<p>This function plots a plain band structure.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>axis</code> <p>Axis to plot the data on</p> required <code>color</code> <code>str</code> <p>Color of the band structure lines</p> <code>'black'</code> <code>linewidth</code> <code>float</code> <p>Line width of the band structure lines</p> <code>1.25</code> <code>linestyle</code> <code>str</code> <p>Line style of the bands</p> <code>'-'</code> Source code in <code>vaspvis/band.py</code> <pre><code>def plot_plain_old(\n    self,\n    ax,\n    color=\"black\",\n    erange=[-6, 6],\n    linewidth=1.25,\n    scale_factor=20,\n    linestyle=\"-\",\n    heatmap=False,\n    bins=400,\n    sigma=3,\n    cmap=\"hot\",\n    vlinecolor=\"black\",\n    powernorm=False,\n    gamma=0.5,\n    projection=None,\n    highlight_band=False,\n    highlight_band_color=\"red\",\n    band_index=None,\n):\n    \"\"\"\n    This function plots a plain band structure.\n\n    Parameters:\n        ax (matplotlib.pyplot.axis): Axis to plot the data on\n        color (str): Color of the band structure lines\n        linewidth (float): Line width of the band structure lines\n        linestyle (str): Line style of the bands\n    \"\"\"\n    bands_in_plot = self._filter_bands(erange=erange)\n    eigenvalues = self.eigenvalues[bands_in_plot]\n\n    if highlight_band:\n        if band_index is not None:\n            highlight_eigenvalues = self.eigenvalues[int(band_index)]\n\n    wave_vectors = self._get_k_distance()\n    wave_vectors_for_kpoints = wave_vectors\n\n    if self.interpolate:\n        wave_vectors, eigenvalues = self._get_interpolated_data_segment(\n            wave_vectors_for_kpoints, eigenvalues\n        )\n\n        if highlight_band:\n            if band_index is not None:\n                (\n                    _,\n                    highlight_eigenvalues,\n                ) = self._get_interpolated_data_segment(\n                    wave_vectors_for_kpoints,\n                    highlight_eigenvalues,\n                )\n\n    eigenvalues_ravel = np.ravel(\n        np.c_[eigenvalues, np.empty(eigenvalues.shape[0]) * np.nan]\n    )\n    wave_vectors_tile = np.tile(\n        np.append(wave_vectors, np.nan), eigenvalues.shape[0]\n    )\n\n    if self.unfold:\n        spectral_weights = self.spectral_weights[bands_in_plot]\n        #  spectral_weights = spectral_weights / np.max(spectral_weights)\n\n        if highlight_band:\n            if band_index is not None:\n                highlight_spectral_weights = self.spectral_weights[\n                    int(band_index)\n                ]\n\n        if self.interpolate:\n            _, spectral_weights = self._get_interpolated_data_segment(\n                wave_vectors_for_kpoints,\n                spectral_weights,\n                crop_zero=True,\n                kind=\"linear\",\n            )\n\n            if highlight_band:\n                if band_index is not None:\n                    (\n                        _,\n                        highlight_spectral_weights,\n                    ) = self._get_interpolated_data_segment(\n                        wave_vectors_for_kpoints,\n                        highlight_spectral_weights,\n                        crop_zero=True,\n                        kind=\"linear\",\n                    )\n\n        spectral_weights_ravel = np.ravel(\n            np.c_[\n                spectral_weights,\n                np.empty(spectral_weights.shape[0]) * np.nan,\n            ]\n        )\n\n        if heatmap:\n            self._heatmap(\n                ax=ax,\n                wave_vectors=wave_vectors,\n                eigenvalues=eigenvalues,\n                weights=spectral_weights,\n                sigma=sigma,\n                cmap=cmap,\n                bins=bins,\n                projection=projection,\n                powernorm=powernorm,\n                gamma=gamma,\n            )\n        else:\n            ax.scatter(\n                wave_vectors_tile,\n                eigenvalues_ravel,\n                c=color,\n                ec=None,\n                s=scale_factor * spectral_weights_ravel,\n                zorder=0,\n            )\n            if highlight_band:\n                if band_index is not None:\n                    ax.scatter(\n                        wave_vectors,\n                        highlight_eigenvalues,\n                        c=highlight_band_color,\n                        ec=None,\n                        s=scale_factor * highlight_spectral_weights,\n                        zorder=100,\n                    )\n    else:\n        if heatmap:\n            self._heatmap(\n                ax=ax,\n                wave_vectors=wave_vectors,\n                eigenvalues=eigenvalues,\n                weights=np.ones(eigenvalues.shape),\n                sigma=sigma,\n                cmap=cmap,\n                bins=bins,\n                projection=projection,\n                powernorm=powernorm,\n                gamma=gamma,\n            )\n        else:\n            ax.plot(\n                wave_vectors_tile,\n                eigenvalues_ravel,\n                color=color,\n                linewidth=linewidth,\n                linestyle=linestyle,\n                zorder=0,\n            )\n            if highlight_band:\n                if band_index is not None:\n                    ax.plot(\n                        wave_vectors,\n                        highlight_eigenvalues,\n                        color=highlight_band_color,\n                        linewidth=linewidth,\n                        linestyle=linestyle,\n                        zorder=100,\n                    )\n\n    if self.hse:\n        self._get_kticks_hse(\n            ax=ax,\n            wave_vectors=wave_vectors_for_kpoints,\n            kpath=self.kpath,\n            vlinecolor=vlinecolor,\n        )\n    elif self.unfold:\n        self._get_kticks_unfold(\n            ax=ax,\n            wave_vectors=wave_vectors_for_kpoints,\n            vlinecolor=vlinecolor,\n        )\n    else:\n        self._get_kticks(\n            ax=ax,\n            wave_vectors=wave_vectors_for_kpoints,\n            vlinecolor=vlinecolor,\n        )\n\n    ax.set_xlim(0, np.max(wave_vectors))\n</code></pre>"},{"location":"band/#vaspvis.band.Band.plot_spd","title":"<code>plot_spd(ax, scale_factor=5, orbitals='spd', erange=[-6, 6], display_order=None, color_list=None, legend=True, linewidth=0.75, band_color='black', heatmap=False, bins=400, sigma=3, cmap='hot', vlinecolor='black', powernorm=False, gamma=0.5)</code>","text":"<p>This function plots the s, p, d projected band structure onto a given axis</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>axis</code> <p>Axis to plot the data on</p> required <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot</p> <code>5</code> <code>order</code> <code>list</code> <p>This determines the order in which the points are plotted on the graph. This is an option because sometimes certain orbitals can be hidden under others because they have a larger weight. For example, if the weights of the d orbitals are greater than that of the s orbitals, it might be smart to choose ['d', 'p', 's'] as the order so the s orbitals are plotted over the d orbitals.</p> required <code>color_dict</code> <code>dict[str][str]</code> <p>This option allow the colors of the s, p, and d orbitals to be specified. Should be in the form of: {'s': , 'p': <p>, 'd': } required <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure</p> <code>'black'</code> Source code in <code>vaspvis/band.py</code> <pre><code>def plot_spd(\n    self,\n    ax,\n    scale_factor=5,\n    orbitals=\"spd\",\n    erange=[-6, 6],\n    display_order=None,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    heatmap=False,\n    bins=400,\n    sigma=3,\n    cmap=\"hot\",\n    vlinecolor=\"black\",\n    powernorm=False,\n    gamma=0.5,\n):\n    \"\"\"\n    This function plots the s, p, d projected band structure onto a given axis\n\n    Parameters:\n        ax (matplotlib.pyplot.axis): Axis to plot the data on\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot\n        order (list): This determines the order in which the points are plotted on the\n            graph. This is an option because sometimes certain orbitals can be hidden\n            under others because they have a larger weight. For example, if the\n            weights of the d orbitals are greater than that of the s orbitals, it\n            might be smart to choose ['d', 'p', 's'] as the order so the s orbitals are\n            plotted over the d orbitals.\n        color_dict (dict[str][str]): This option allow the colors of the s, p, and d\n            orbitals to be specified. Should be in the form of:\n            {'s': &lt;s color&gt;, 'p': &lt;p color&gt;, 'd': &lt;d color&gt;}\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background\n        band_color (string): Color of the plain band structure\n    \"\"\"\n    if color_list is None:\n        color_list = [\n            self.color_dict[0],\n            self.color_dict[1],\n            self.color_dict[2],\n            self.color_dict[4],\n        ]\n        colors = np.array([color_list[i] for i in range(len(orbitals))])\n    else:\n        colors = color_list\n\n    projected_data = self._sum_spd(spd=orbitals)\n\n    self._plot_projected_general(\n        ax=ax,\n        projected_data=projected_data,\n        colors=colors,\n        scale_factor=scale_factor,\n        erange=erange,\n        display_order=display_order,\n        linewidth=linewidth,\n        band_color=band_color,\n        heatmap=heatmap,\n        bins=bins,\n        sigma=sigma,\n        cmap=cmap,\n        vlinecolor=vlinecolor,\n    )\n\n    if legend:\n        self._add_legend(ax, names=[i for i in orbitals], colors=colors)\n</code></pre>"},{"location":"charge/","title":"Charge Transfer Plots","text":""},{"location":"charge/#chargepy","title":"charge.py","text":""},{"location":"charge/#vaspvis.charge.Charge","title":"<code>Charge</code>","text":"<p>This class contains all the methods for performing charge transfer calculations</p> Source code in <code>vaspvis/charge.py</code> <pre><code>class Charge:\n    \"\"\"\n    This class contains all the methods for performing charge transfer calculations\n    \"\"\"\n\n    def __init__(\n        self,\n        interface_folder,\n        substrate_folder,\n        film_folder,\n    ):\n        self.interface_folder = interface_folder\n        self.substrate_folder = substrate_folder\n        self.film_folder = film_folder\n        self.interface_structure = Structure.from_file(\n            os.path.join(self.interface_folder, \"POSCAR\"),\n        )\n        self.film_structure = Structure.from_file(\n            os.path.join(self.film_folder, \"POSCAR\"),\n        )\n        self.substrate_structure = Structure.from_file(\n            os.path.join(self.substrate_folder, \"POSCAR\"),\n        )\n        self.area = self._get_area()\n        pool = Pool(processes=3)\n        [self.interface_data, self.substrate_data, self.film_data] = pool.map(\n            self._load_data,\n            (self.interface_folder, self.substrate_folder, self.film_folder),\n        )\n        pool.close()\n        pool.join()\n\n        (\n            self.x_plot,\n            self.y_plot,\n            self.film_min,\n            self.film_y,\n            self.sub_max,\n            self.sub_y,\n            self.sub_diff,\n            self.film_diff,\n        ) = self._get_planar_charge_transfer()\n\n    @property\n    def substrate_charge_transfer(self):\n        return self.sub_diff\n\n    @property\n    def film_charge_transfer(self):\n        return self.film_diff\n\n    def _get_area(self):\n        a = self.interface_structure.lattice.matrix[0]\n        b = self.interface_structure.lattice.matrix[1]\n\n        return np.linalg.norm(np.cross(a, b))\n\n    def _load_data(self, folder):\n        preloaded_data = os.path.isfile(os.path.join(folder, \"chgcar.npy\"))\n        if preloaded_data:\n            with open(os.path.join(folder, \"chgcar.npy\"), \"rb\") as p:\n                data = np.load(p)\n        else:\n            chgcar = Chgcar.from_file(os.path.join(folder, \"CHGCAR\"))\n            data = chgcar.data[\"total\"]\n            np.save(os.path.join(folder, \"chgcar.npy\"), data)\n\n        a_vals = np.linspace(0, 1, data.shape[0])\n        b_vals = np.linspace(0, 1, data.shape[1])\n        c_vals = np.linspace(0, 1, data.shape[2])\n\n        return data, a_vals, b_vals, c_vals\n\n    def _planar_average(self, data):\n        return data.mean(axis=(0, 1)) / self.area\n\n    def _locate_ind(self, data, coord):\n        return np.abs(data - coord).argmin()\n\n    def _get_planar_charge_transfer(self):\n        int_data, _, _, int_c = self.interface_data\n        sub_data, _, _, sub_c = self.substrate_data\n        film_data, _, _, film_c = self.film_data\n\n        total_c_len = self.interface_structure.lattice.matrix[-1, -1]\n\n        int_data = self._planar_average(int_data)\n        sub_data = self._planar_average(sub_data)\n        film_data = self._planar_average(film_data)\n\n        int_cs = CubicSpline(int_c * total_c_len, int_data)\n        sub_cs = CubicSpline(sub_c * total_c_len, sub_data)\n        film_cs = CubicSpline(film_c * total_c_len, film_data)\n\n        int_min = self.interface_structure.cart_coords[:, -1].min()\n        int_max = self.interface_structure.cart_coords[:, -1].max()\n        sub_max = self.substrate_structure.cart_coords[:, -1].max()\n        film_min = self.film_structure.cart_coords[:, -1].min()\n        mid_line = (sub_max + film_min) / 2\n\n        sub_to_mid_z = np.linspace(int_min, mid_line, 1001)\n        mid_to_film_z = np.linspace(mid_line, int_max, 1001)\n\n        sub_to_mid_data = (\n            int_cs(sub_to_mid_z) - film_cs(sub_to_mid_z) - sub_cs(sub_to_mid_z)\n        )\n\n        mid_to_film_data = (\n            int_cs(mid_to_film_z)\n            - film_cs(mid_to_film_z)\n            - sub_cs(mid_to_film_z)\n        )\n\n        sub_chg = int_cs(sub_max) - film_cs(sub_max) - sub_cs(sub_max)\n        film_chg = int_cs(film_min) - film_cs(film_min) - sub_cs(film_min)\n\n        sub_charge = trapz(y=sub_to_mid_data, x=sub_to_mid_z)\n        film_charge = trapz(y=mid_to_film_data, x=mid_to_film_z)\n\n        all_z = np.linspace(int_min, int_max, 1001)\n        all_data = int_cs(all_z) - film_cs(all_z) - sub_cs(all_z)\n        all_z -= mid_line\n\n        return (\n            all_z,\n            all_data,\n            film_min - mid_line,\n            film_chg,\n            sub_max - mid_line,\n            sub_chg,\n            sub_charge,\n            film_charge,\n        )\n\n    def plot_charge_transfer(\n        self,\n        ax,\n        color=\"black\",\n        linestyle=\"-\",\n        linewidth=1,\n        film_line_color=\"red\",\n        film_linestyle=\"-\",\n        film_linewidth=0.75,\n        substrate_line_color=\"blue\",\n        substrate_linestyle=\"-\",\n        substrate_linewidth=0.75,\n        method=0,\n        plot_film_and_substrate_lines=True,\n        add_labels=True,\n        xlim=[-10, 10],\n        label_fontsize=10,\n    ):\n\n        ax.axhline(y=0, color=\"grey\", linewidth=0.5)\n\n        if plot_film_and_substrate_lines:\n            ax.axvline(\n                x=self.film_min,\n                color=film_line_color,\n                linewidth=film_linewidth,\n                linestyle=film_linestyle,\n            )\n            ax.axvspan(\n                self.film_min,\n                xlim[1],\n                color=film_line_color,\n                alpha=0.05,\n            )\n            ax.scatter(\n                [self.film_min],\n                [self.film_y],\n                ec=film_line_color,\n                fc=\"white\",\n                marker=\"o\",\n                s=15,\n                zorder=100,\n            )\n            ax.axvline(\n                x=self.sub_max,\n                color=substrate_line_color,\n                linewidth=substrate_linewidth,\n                linestyle=substrate_linestyle,\n            )\n            ax.axvspan(\n                xlim[0],\n                self.sub_max,\n                color=substrate_line_color,\n                alpha=0.05,\n            )\n            ax.scatter(\n                [self.sub_max],\n                [self.sub_y],\n                ec=substrate_line_color,\n                fc=\"white\",\n                marker=\"o\",\n                s=15,\n                zorder=100,\n            )\n\n        ax.plot(\n            self.x_plot,\n            self.y_plot,\n            color=color,\n            linewidth=linewidth,\n            linestyle=linestyle,\n        )\n        ax.set_xlim(xlim[0], xlim[1])\n        y_min, y_max = ax.get_ylim()\n        new_y = max(abs(y_min), abs(y_max))\n        ax.set_ylim(-new_y, new_y)\n\n        if add_labels:\n            sub_formula = self.substrate_structure.composition.reduced_formula\n            film_formula = self.film_structure.composition.reduced_formula\n\n            latex_sub_formula = []\n            for i in sub_formula:\n                if i.isdigit():\n                    latex_sub_formula.append(\"$_{\" + f\"{i}\" + \"}$\")\n                else:\n                    latex_sub_formula.append(i)\n\n            latex_sub_formula = \"\".join(latex_sub_formula)\n\n            latex_film_formula = []\n            for i in film_formula:\n                if i.isdigit():\n                    latex_film_formula.append(\"$_{\" + f\"{i}\" + \"}$\")\n                else:\n                    latex_film_formula.append(i)\n\n            latex_film_formula = \"\".join(latex_film_formula)\n\n            sub_annotation = \"\\n\".join(\n                [latex_sub_formula, f\"{self.sub_diff:.3f} eV\"]\n            )\n\n            film_annotation = \"\\n\".join(\n                [latex_film_formula, f\"{self.film_diff:.3f} eV\"]\n            )\n\n            bbox_dict = dict(\n                boxstyle=\"round,pad=0.3\",\n                fc=\"white\",\n                ec=\"black\",\n                lw=1,\n            )\n\n            ax.annotate(\n                sub_annotation,\n                xy=((xlim[0] + self.sub_max) / 2, 0.90 * new_y),\n                xycoords=\"data\",\n                ha=\"center\",\n                va=\"top\",\n                bbox=bbox_dict,\n                fontsize=label_fontsize,\n            )\n\n            ax.annotate(\n                film_annotation,\n                xy=((xlim[1] + self.film_min) / 2, 0.90 * new_y),\n                xycoords=\"data\",\n                ha=\"center\",\n                va=\"top\",\n                bbox=bbox_dict,\n                fontsize=label_fontsize,\n            )\n</code></pre>"},{"location":"dos/","title":"Density of States","text":""},{"location":"dos/#dospy","title":"dos.py","text":""},{"location":"dos/#vaspvis.dos.Dos","title":"<code>Dos</code>","text":"<p>This class contains all the methods for contructing density of states plots from the outputs of VASP calculations.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files.</p> required <code>spin</code> <code>str</code> <p>Which spin direction to parse ('up' or 'down')</p> <code>'up'</code> <code>combination_method</code> <code>str</code> <p>If the spin option is 'both', the combination method can either be additive or substractive by passing 'add' or 'sub'. It spin is passed as 'up' or 'down' this option is ignored.</p> <code>'add'</code> Source code in <code>vaspvis/dos.py</code> <pre><code>class Dos:\n    \"\"\"\n    This class contains all the methods for contructing density of states plots from the outputs of VASP calculations.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files.\n        spin (str): Which spin direction to parse ('up' or 'down')\n        combination_method (str): If the spin option is 'both', the combination method can either be additive or substractive\n            by passing 'add' or 'sub'. It spin is passed as 'up' or 'down' this option is ignored.\n    \"\"\"\n\n    def __init__(\n        self,\n        folder,\n        spin=\"up\",\n        soc_axis=None,\n        combination_method=\"add\",\n        sp_method=\"percentage\",\n        shift_efermi=0,\n    ):\n        self.folder = folder\n        self.spin = spin\n        self.soc_axis = soc_axis\n        self.combination_method = combination_method\n        self.sp_method = sp_method\n        self.incar = Incar.from_file(os.path.join(folder, \"INCAR\"))\n        if \"LORBIT\" in self.incar:\n            if self.incar[\"LORBIT\"] &gt;= 11:\n                self.lorbit = True\n            else:\n                self.lorbit = False\n        else:\n            self.lorbit = False\n\n        if self.lorbit:\n            if os.path.isfile(\n                os.path.join(folder, \"dos.npy\")\n            ) and os.path.isfile(os.path.join(folder, \"projected_dos.npy\")):\n                with open(os.path.join(folder, \"dos.npy\"), \"rb\") as dos_file:\n                    dos = np.load(dos_file)\n                with open(\n                    os.path.join(folder, \"projected_dos.npy\"), \"rb\"\n                ) as projected_dos_file:\n                    projected_dos = np.load(projected_dos_file)\n\n                self.doscar = {\n                    \"total\": dos,\n                    \"projected\": projected_dos,\n                }\n            else:\n                if self._check_f_error():\n                    self._fix_doscar()\n\n                self.doscar = VaspDoscar.parse_doscar(\n                    os.path.join(folder, \"DOSCAR\")\n                )\n                np.save(os.path.join(folder, \"dos.npy\"), self.doscar[\"total\"])\n                np.save(\n                    os.path.join(folder, \"projected_dos.npy\"),\n                    self.doscar[\"projected\"],\n                )\n        else:\n            if os.path.isfile(os.path.join(folder, \"dos.npy\")):\n                with open(os.path.join(folder, \"dos.npy\"), \"rb\") as dos_file:\n                    dos = np.load(dos_file)\n\n                self.doscar = {\n                    \"total\": dos,\n                }\n            else:\n                self.doscar = VaspDoscar.parse_doscar(\n                    os.path.join(folder, \"DOSCAR\")\n                )\n                np.save(os.path.join(folder, \"dos.npy\"), self.doscar[\"total\"])\n\n        self.efermi = (\n            float(\n                os.popen(f'grep E-fermi {os.path.join(folder, \"OUTCAR\")}')\n                .read()\n                .split()[2]\n            )\n            + shift_efermi\n        )\n        self.poscar = Poscar.from_file(\n            os.path.join(folder, \"POSCAR\"),\n            check_for_POTCAR=False,\n            read_velocities=False,\n        )\n        self.forbitals = self._check_f_orb()\n        self.color_dict = {\n            0: \"#FF0000\",\n            1: \"#0000FF\",\n            2: \"#008000\",\n            3: \"#800080\",\n            4: \"#E09200\",\n            5: \"#FF5C77\",\n            6: \"#778392\",\n            7: \"#07C589\",\n            8: \"#40BAF2\",\n            9: \"#FF0000\",\n            10: \"#0000FF\",\n            11: \"#008000\",\n            12: \"#800080\",\n            13: \"#E09200\",\n            14: \"#FF5C77\",\n            15: \"#778392\",\n        }\n        self.orbital_labels = {\n            0: \"s\",\n            1: \"p_{y}\",\n            2: \"p_{x}\",\n            3: \"p_{z}\",\n            4: \"d_{xy}\",\n            5: \"d_{yz}\",\n            6: \"d_{z^{2}}\",\n            7: \"d_{xz}\",\n            8: \"d_{x^{2}-y^{2}}\",\n            9: \"f_{y^{3}x^{2}}\",\n            10: \"f_{xyz}\",\n            11: \"f_{yz^{2}}\",\n            12: \"f_{z^{3}}\",\n            13: \"f_{xz^{2}}\",\n            14: \"f_{zx^{3}}\",\n            15: \"f_{x^{3}}\",\n        }\n        self.spd_relations = {\n            \"s\": 0,\n            \"p\": 1,\n            \"d\": 2,\n            \"f\": 3,\n        }\n\n        if \"LSORBIT\" in self.incar:\n            if self.incar[\"LSORBIT\"]:\n                self.lsorbit = True\n            else:\n                self.lsorbit = False\n        else:\n            self.lsorbit = False\n\n        if \"ISPIN\" in self.incar:\n            if self.incar[\"ISPIN\"] == 2:\n                self.ispin = True\n            else:\n                self.ispin = False\n        else:\n            self.ispin = False\n\n        self.spin_dict = {\"up\": Spin.up, \"down\": Spin.down}\n\n        self.tdos_array = self._load_tdos()\n\n        if self.lorbit:\n            self.pdos_array = self._load_pdos()\n\n            if self.lsorbit and self.soc_axis is not None:\n                if self.spin == \"both\":\n                    if self.sp_method == \"absolute\":\n                        self.tdos_array[:, 1] = self.pdos_array.sum(\n                            axis=1\n                        ).sum(axis=1)\n                    elif self.sp_method == \"percentage\":\n                        if self.combination_method == \"add\":\n                            raise BaseException(\n                                \"If using combination_method='add' and spin orbit coupling is applied, just set spin='up'\"\n                            )\n                        else:\n                            self.tdos_array[:, 1] = (\n                                self.pdos_array[0].sum(axis=1).sum(axis=1)\n                                - self.pdos_array[1].sum(axis=1).sum(axis=1)\n                            ) / (\n                                self.pdos_array[0].sum(axis=1).sum(axis=1)\n                                + self.pdos_array[1].sum(axis=1).sum(axis=1)\n                            )\n                elif self.spin == \"up\":\n                    self.tdos_array[:, 1] = self.pdos_array.sum(axis=1).sum(\n                        axis=1\n                    )\n                elif self.spin == \"down\":\n                    self.tdos_array[:, 1] = self.pdos_array.sum(axis=1).sum(\n                        axis=1\n                    )\n\n    def _check_f_orb(self):\n        f_elements = [\n            \"La\",\n            \"Ac\",\n            \"Ce\",\n            \"Tb\",\n            \"Th\",\n            \"Pr\",\n            \"Dy\",\n            \"Pa\",\n            \"Nd\",\n            \"Ho\",\n            \"U\",\n            \"Pm\",\n            \"Er\",\n            \"Np\",\n            \"Sm\",\n            \"Tm\",\n            \"Pu\",\n            \"Eu\",\n            \"Yb\",\n            \"Am\",\n            \"Gd\",\n            \"Lu\",\n        ]\n        f = False\n        for element in self.poscar.site_symbols:\n            if element in f_elements:\n                f = True\n\n        return f\n\n    def _check_f_error(self):\n        with open(os.path.join(self.folder, \"DOSCAR\"), \"rb\") as f:\n            f.seek(-2, os.SEEK_END)\n            while f.read(1) != b\"\\n\":\n                f.seek(-2, os.SEEK_CUR)\n            last_line = f.readline().decode()\n\n        last_line_len = len(last_line.split())\n\n        if last_line_len == 28:\n            return True\n        else:\n            return False\n\n    def _fix_doscar(self):\n        doscar = []\n        with open(os.path.join(self.folder, \"DOSCAR\")) as f:\n            for line in f:\n                split_line = line.split()\n                doscar.append(split_line)\n\n        num_atoms = int(doscar[0][1])\n        nedos = int(doscar[5][2])\n        nedos_f = 2 * nedos\n        start_inds = nedos + 7\n\n        top_file = []\n\n        with open(os.path.join(self.folder, \"DOSCAR\")) as f:\n            count = 0\n            for line in f:\n                top_file.append(line)\n                count += 1\n                if count == start_inds:\n                    break\n\n        a = np.c_[[np.arange(0, nedos_f - 1, 2), np.arange(1, nedos_f, 2)]].T\n        a = np.c_[[a for _ in range(num_atoms)]]\n        b = np.array([1] + [nedos_f for _ in range(num_atoms - 1)])\n        c = np.arange(num_atoms)\n        d = np.arange(num_atoms)\n        d[0] = 1\n        inds = a + (b * c)[:, None, None] + c[:, None, None]\n        inds += start_inds\n\n        new_list = []\n\n        for i, ind in enumerate(inds):\n            inbetween_ind = np.max(ind) + 1\n            for j in ind:\n                new_list.append(\"\\t\" + \"  \".join(doscar[j[0]] + doscar[j[1]]))\n\n            if i != inds.shape[0] - 1:\n                new_list.append(\"\\t\" + \"    \".join(doscar[inbetween_ind]))\n\n        new_doscar = \"\".join([\"\".join(top_file), \"\\n\".join(new_list)])\n\n        os.rename(\n            os.path.join(self.folder, \"DOSCAR\"),\n            os.path.join(self.folder, \"DOSCAR_old\"),\n        )\n\n        with open(os.path.join(self.folder, \"DOSCAR\"), \"w\") as x:\n            x.write(new_doscar)\n\n    def _load_tdos(self):\n        \"\"\"\n        This function loads the total density of states into a dictionary\n\n        Returns:\n            tdos_dict (dict[str][np.ndarray]): Dictionary that consists or the\n                energies and densities of the system.\n        \"\"\"\n\n        tdos = self.doscar[\"total\"]\n        tdos[:, 0] = tdos[:, 0] - self.efermi\n\n        if self.spin == \"up\":\n            tdos = tdos[:, :2]\n        elif self.spin == \"down\":\n            tdos = tdos[:, [0, 2]]\n            tdos[:, 1] = -tdos[:, 1]\n        elif self.spin == \"both\":\n            tdos_up = tdos[:, 1]\n            tdos_down = tdos[:, 2]\n            if self.combination_method == \"add\":\n                tdos = np.c_[tdos[:, 0], tdos_up + tdos_down]\n            if self.combination_method == \"sub\":\n                if self.sp_method == \"percentage\":\n                    tdos = np.c_[\n                        tdos[:, 0],\n                        (tdos_up - tdos_down) / (tdos_up + tdos_down),\n                    ]\n                elif self.sp_method == \"absolute\":\n                    tdos = np.c_[tdos[:, 0], tdos_up - tdos_down]\n\n        return tdos\n\n    def _load_pdos(self):\n        \"\"\"\n        This function loads the projected density of states into a dictionary\n        of the form:\n        atom index --&gt; orbital projections\n\n        Returns:\n            pdos_dict (dict[int][pd.DataFrame]): Dictionary that contains a data frame\n                with the orbital weights for each atom index.\n        \"\"\"\n\n        pdos = self.doscar[\"projected\"]\n        pdos = np.transpose(pdos, axes=(1, 0, 2))\n\n        if self.spin == \"up\":\n            if not self.forbitals:\n                if self.lsorbit:\n                    if self.soc_axis is None:\n                        pdos = pdos[:, :, [(j * 4) + 1 for j in range(9)]]\n                    elif self.soc_axis == \"x\":\n                        pdos = pdos[:, :, [(j * 4) + 2 for j in range(9)]]\n                    elif self.soc_axis == \"y\":\n                        pdos = pdos[:, :, [(j * 4) + 3 for j in range(9)]]\n                    elif self.soc_axis == \"z\":\n                        pdos = pdos[:, :, [(j * 4) + 4 for j in range(9)]]\n\n                    if self.soc_axis is not None:\n                        pdos_up = np.zeros(pdos.shape)\n                        pdos_up[np.where(pdos &gt; 0)] = pdos[np.where(pdos &gt; 0)]\n                        pdos = pdos_up\n\n                elif self.ispin and not self.lsorbit:\n                    pdos = pdos[:, :, [(j * 2) + 1 for j in range(9)]]\n                else:\n                    pdos = pdos[:, :, 1:]\n            else:\n                if self.lsorbit:\n                    if self.soc_axis is None:\n                        pdos = pdos[:, :, [(j * 4) + 1 for j in range(16)]]\n                    if self.soc_axis == \"x\":\n                        pdos = pdos[:, :, [(j * 4) + 2 for j in range(16)]]\n                    if self.soc_axis == \"y\":\n                        pdos = pdos[:, :, [(j * 4) + 3 for j in range(16)]]\n                    if self.soc_axis == \"z\":\n                        pdos = pdos[:, :, [(j * 4) + 4 for j in range(16)]]\n\n                    if self.soc_axis is not None:\n                        pdos_up = np.zeros(pdos.shape)\n                        pdos_up[np.where(pdos &gt; 0)] = pdos[np.where(pdos &gt; 0)]\n                        pdos = pdos_up\n\n                elif self.ispin and not self.lsorbit:\n                    pdos = pdos[:, :, [(j * 2) + 1 for j in range(16)]]\n                else:\n                    pdos = pdos[:, :, 1:]\n        if self.spin == \"down\":\n            if not self.forbitals:\n                if self.lsorbit:\n                    if self.soc_axis is None:\n                        raise (\n                            \"You have selected spin='down' for a SOC calculation, but soc_axis has not been selected. Please set soc_axis to 'x', 'y', or 'z' for this function to work.\"\n                        )\n                    elif self.soc_axis == \"x\":\n                        pdos = pdos[:, :, [(j * 4) + 2 for j in range(9)]]\n                    elif self.soc_axis == \"y\":\n                        pdos = pdos[:, :, [(j * 4) + 3 for j in range(9)]]\n                    elif self.soc_axis == \"z\":\n                        pdos = pdos[:, :, [(j * 4) + 4 for j in range(9)]]\n\n                    if self.soc_axis is not None:\n                        pdos_down = np.zeros(pdos.shape)\n                        pdos_down[np.where(pdos &lt; 0)] = pdos[\n                            np.where(pdos &lt; 0)\n                        ]\n                        pdos = pdos_down\n\n                elif self.ispin and not self.lsorbit:\n                    pdos = -pdos[:, :, [(j * 2) + 2 for j in range(9)]]\n            else:\n                if self.lsorbit:\n                    if self.soc_axis is None:\n                        raise (\n                            \"You have selected spin='down' for a SOC calculation, but soc_axis has not been selected. Please set soc_axis to 'x', 'y', or 'z' for this function to work.\"\n                        )\n                    if self.soc_axis == \"x\":\n                        pdos = pdos[:, :, [(j * 4) + 2 for j in range(16)]]\n                    if self.soc_axis == \"y\":\n                        pdos = pdos[:, :, [(j * 4) + 3 for j in range(16)]]\n                    if self.soc_axis == \"z\":\n                        pdos = pdos[:, :, [(j * 4) + 4 for j in range(16)]]\n\n                    if self.soc_axis is not None:\n                        pdos_down = np.zeros(pdos.shape)\n                        pdos_down[np.where(pdos &lt; 0)] = pdos[\n                            np.where(pdos &lt; 0)\n                        ]\n                        pdos = pdos_down\n\n                elif self.ispin and not self.lsorbit:\n                    pdos = -pdos[:, :, [(j * 2) + 2 for j in range(16)]]\n        if self.spin == \"both\":\n            if not self.forbitals:\n                if self.lsorbit:\n                    if self.soc_axis is None:\n                        raise (\n                            \"You have selected spin='down' for a SOC calculation, but soc_axis has not been selected. Please set soc_axis to 'x', 'y', or 'z' for this function to work.\"\n                        )\n                    elif self.soc_axis == \"x\":\n                        pdos = pdos[:, :, [(j * 4) + 2 for j in range(9)]]\n                    elif self.soc_axis == \"y\":\n                        pdos = pdos[:, :, [(j * 4) + 3 for j in range(9)]]\n                    elif self.soc_axis == \"z\":\n                        pdos = pdos[:, :, [(j * 4) + 4 for j in range(9)]]\n\n                    if self.soc_axis is not None:\n                        pdos_up = np.zeros(pdos.shape)\n                        pdos_up[np.where(pdos &gt; 0)] = pdos[np.where(pdos &gt; 0)]\n                        pdos_down = np.zeros(pdos.shape)\n                        pdos_down[np.where(pdos &lt; 0)] = -pdos[\n                            np.where(pdos &lt; 0)\n                        ]\n\n                elif self.ispin and not self.lsorbit:\n                    pdos_up = pdos[:, :, [(j * 2) + 1 for j in range(9)]]\n                    pdos_down = pdos[:, :, [(j * 2) + 2 for j in range(9)]]\n            else:\n                if self.lsorbit:\n                    if self.soc_axis is None:\n                        raise (\n                            \"You have selected spin='down' for a SOC calculation, but soc_axis has not been selected. Please set soc_axis to 'x', 'y', or 'z' for this function to work.\"\n                        )\n                    if self.soc_axis == \"x\":\n                        pdos = pdos[:, :, [(j * 4) + 2 for j in range(16)]]\n                    if self.soc_axis == \"y\":\n                        pdos = pdos[:, :, [(j * 4) + 3 for j in range(16)]]\n                    if self.soc_axis == \"z\":\n                        pdos = pdos[:, :, [(j * 4) + 4 for j in range(16)]]\n\n                    if self.soc_axis is not None:\n                        pdos_up = np.zeros(pdos.shape)\n                        pdos_up[np.where(pdos &gt; 0)] = pdos[np.where(pdos &gt; 0)]\n                        pdos_down = np.zeros(pdos.shape)\n                        pdos_down[np.where(pdos &lt; 0)] = -pdos[\n                            np.where(pdos &lt; 0)\n                        ]\n\n                elif self.ispin and not self.lsorbit:\n                    pdos_up = pdos[:, :, [(j * 2) + 1 for j in range(16)]]\n                    pdos_down = pdos[:, :, [(j * 2) + 2 for j in range(16)]]\n\n            if self.combination_method == \"add\":\n                pdos = pdos_up + pdos_down\n            if self.combination_method == \"sub\":\n                if self.sp_method == \"percentage\":\n                    pdos = np.array([pdos_up, pdos_down])\n                    #  pdos = (pdos_up - pdos_down) / (pdos_up + pdos_down)\n                elif self.sp_method == \"absolute\":\n                    pdos = pdos_up - pdos_down\n\n        return pdos\n\n    def _sum_spd(self, spd):\n        \"\"\"\n        This function sums the weights of the s, p, and d orbitals for each atom\n        and creates a dictionary of the form:\n        band index --&gt; s,p,d orbital weights\n\n        Returns:\n            spd_dict (dict([str][pd.DataFrame])): Dictionary that contains the summed weights for the s, p, and d orbitals for each band\n        \"\"\"\n\n        if not self.forbitals:\n            spd_indices = [\n                np.array([False for _ in range(9)]) for i in range(3)\n            ]\n            spd_indices[0][0] = True\n            spd_indices[1][1:4] = True\n            spd_indices[2][4:] = True\n        else:\n            spd_indices = [\n                np.array([False for _ in range(16)]) for i in range(4)\n            ]\n            spd_indices[0][0] = True\n            spd_indices[1][1:4] = True\n            spd_indices[2][4:9] = True\n            spd_indices[3][9:] = True\n\n        if (\n            self.spin == \"both\"\n            and self.combination_method == \"sub\"\n            and self.sp_method == \"percentage\"\n        ):\n            orbital_contributions_up = np.sum(self.pdos_array[0], axis=1)\n            orbital_contributions_down = np.sum(self.pdos_array[1], axis=1)\n\n            spd_contributions_up = np.transpose(\n                np.array(\n                    [\n                        np.sum(orbital_contributions_up[:, ind], axis=1)\n                        for ind in spd_indices\n                    ]\n                ),\n                axes=[1, 0],\n            )\n            spd_contributions_down = np.transpose(\n                np.array(\n                    [\n                        np.sum(orbital_contributions_down[:, ind], axis=1)\n                        for ind in spd_indices\n                    ]\n                ),\n                axes=[1, 0],\n            )\n\n            spd_contributions_up = spd_contributions_up[\n                :, [self.spd_relations[orb] for orb in spd]\n            ]\n            spd_contributions_down = spd_contributions_down[\n                :, [self.spd_relations[orb] for orb in spd]\n            ]\n\n            #  spd_contributions = (spd_contributions_up - spd_contributions_down) / (spd_contributions_up + spd_contributions_down)\n            spd_contributions = np.array(\n                [spd_contributions_up, spd_contributions_down]\n            )\n\n        else:\n            orbital_contributions = np.sum(self.pdos_array, axis=1)\n\n            spd_contributions = np.transpose(\n                np.array(\n                    [\n                        np.sum(orbital_contributions[:, ind], axis=1)\n                        for ind in spd_indices\n                    ]\n                ),\n                axes=[1, 0],\n            )\n\n            spd_contributions = spd_contributions[\n                :, [self.spd_relations[orb] for orb in spd]\n            ]\n\n        return spd_contributions\n\n    def _sum_orbitals(self, orbitals):\n        \"\"\"\n        This function finds the weights of desired orbitals for all atoms and\n            returns a dictionary of the form:\n            band index --&gt; orbital index\n\n        Parameters:\n            orbitals (list): List of desired orbitals.\n                0 = s\n                1 = py\n                2 = pz\n                3 = px\n                4 = dxy\n                5 = dyz\n                6 = dz2\n                7 = dxz\n                8 = dx2-y2\n                9 = fy3x2\n                10 = fxyz\n                11 = fyz2\n                12 = fz3\n                13 = fxz2\n                14 = fzx3\n                15 = fx3\n\n        Returns:\n            orbital_dict (dict[str][pd.DataFrame]): Dictionary that contains the projected weights of the selected orbitals.\n        \"\"\"\n        if (\n            self.spin == \"both\"\n            and self.combination_method == \"sub\"\n            and self.sp_method == \"percentage\"\n        ):\n            orbital_contributions_up = self.pdos_array[0].sum(axis=1)\n            orbital_contributions_down = self.pdos_array[1].sum(axis=1)\n\n            orbital_contributions_up = orbital_contributions_up[:, orbitals]\n            orbital_contributions_down = orbital_contributions_down[\n                :, orbitals\n            ]\n\n            #  orbital_contributions = (orbital_contributions_up - orbital_contributions_down) / (orbital_contributions_up + orbital_contributions_down)\n            orbital_contributions = np.array(\n                [orbital_contributions_up, orbital_contributions_down]\n            )\n        else:\n            orbital_contributions = self.pdos_array.sum(axis=1)\n            orbital_contributions = orbital_contributions[:, orbitals]\n\n        return orbital_contributions\n\n    def _sum_atoms(self, atoms, spd=False):\n        \"\"\"\n        This function finds the weights of desired atoms for all orbitals and\n            returns a dictionary of the form:\n            band index --&gt; atom index\n\n        Parameters:\n            atoms (list): List of desired atoms where atom 0 is the first atom in\n                the POSCAR file.\n\n        Returns:\n            atom_dict (dict[str][pd.DataFrame]): Dictionary that contains the projected\n                weights of the selected atoms.\n        \"\"\"\n\n        if spd:\n            if not self.forbitals:\n                spd_indices = [\n                    np.array([False for _ in range(9)]) for i in range(3)\n                ]\n                spd_indices[0][0] = True\n                spd_indices[1][1:4] = True\n                spd_indices[2][4:] = True\n            else:\n                spd_indices = [\n                    np.array([False for _ in range(16)]) for i in range(4)\n                ]\n                spd_indices[0][0] = True\n                spd_indices[1][1:4] = True\n                spd_indices[2][4:9] = True\n                spd_indices[3][9:] = True\n\n            if (\n                self.spin == \"both\"\n                and self.combination_method == \"sub\"\n                and self.sp_method == \"percentage\"\n            ):\n                atoms_spd_up = self.pdos_array[0]\n                atoms_spd_down = self.pdos_array[1]\n                atoms_spd_up = np.transpose(\n                    np.array(\n                        [\n                            np.sum(atoms_spd_up[:, :, ind], axis=2)\n                            for ind in spd_indices\n                        ]\n                    ),\n                    axes=(1, 2, 0),\n                )\n                atoms_spd_down = np.transpose(\n                    np.array(\n                        [\n                            np.sum(atoms_spd_down[:, :, ind], axis=2)\n                            for ind in spd_indices\n                        ]\n                    ),\n                    axes=(1, 2, 0),\n                )\n                #  atoms_spd = (atoms_spd_up - atoms_spd_down) / (atoms_spd_up + atoms_spd_down)\n                atoms_spd = np.array([atoms_spd_up, atoms_spd_down])\n            else:\n                atoms_spd = np.transpose(\n                    np.array(\n                        [\n                            np.sum(self.pdos_array[:, :, ind], axis=2)\n                            for ind in spd_indices\n                        ]\n                    ),\n                    axes=(1, 2, 0),\n                )\n\n            return atoms_spd\n        else:\n            if (\n                self.spin == \"both\"\n                and self.combination_method == \"sub\"\n                and self.sp_method == \"percentage\"\n            ):\n                atoms_array_up = self.pdos_array[0].sum(axis=2)\n                atoms_array_down = self.pdos_array[1].sum(axis=2)\n                #  atoms_array = (atoms_array_up - atoms_array_down) / (atoms_array_up + atoms_array_down)\n                if atoms is not None:\n                    atoms_array_up = atoms_array_up[:, atoms]\n                    atoms_array_down = atoms_array_down[:, atoms]\n\n                atoms_array = np.array([atoms_array_up, atoms_array_down])\n            else:\n                atoms_array = self.pdos_array.sum(axis=2)\n\n                if atoms is not None:\n                    atoms_array = atoms_array[:, atoms]\n\n            return atoms_array\n\n    def _sum_elements(\n        self, elements, orbitals=False, spd=False, spd_options=None\n    ):\n        \"\"\"\n        This function sums the weights of the orbitals of specific elements within the\n        calculated structure and returns a dictionary of the form:\n        band index --&gt; element label --&gt; orbital weights for orbitals = True\n        band index --&gt; element label for orbitals = False\n        This is useful for structures with many elements because manually entering indicies is\n        not practical for large structures.\n\n        Parameters:\n            elements (list): List of element symbols to sum the weights of.\n            orbitals (bool): Determines whether or not to inclue orbitals or not\n                (True = keep orbitals, False = sum orbitals together )\n            spd (bool): Determines whether or not to sum the s, p, and d orbitals\n\n\n        Returns:\n            element_dict (dict([str][str][pd.DataFrame])): Dictionary that contains the summed weights for each orbital for a given element in the structure.\n        \"\"\"\n\n        poscar = self.poscar\n        natoms = poscar.natoms\n        symbols = poscar.site_symbols\n\n        if (\n            self.spin == \"both\"\n            and self.combination_method == \"sub\"\n            and self.sp_method == \"percentage\"\n        ):\n            pdos_array_up = self.pdos_array[0]\n            pdos_array_down = self.pdos_array[1]\n\n            element_list = np.hstack(\n                [\n                    [symbols[i] for j in range(natoms[i])]\n                    for i in range(len(symbols))\n                ]\n            )\n\n            element_indices = [\n                np.where(np.isin(element_list, element))[0]\n                for element in elements\n            ]\n\n            element_orbitals_up = np.transpose(\n                np.array(\n                    [\n                        np.sum(pdos_array_up[:, ind, :], axis=1)\n                        for ind in element_indices\n                    ]\n                ),\n                axes=(1, 0, 2),\n            )\n            element_orbitals_down = np.transpose(\n                np.array(\n                    [\n                        np.sum(pdos_array_down[:, ind, :], axis=1)\n                        for ind in element_indices\n                    ]\n                ),\n                axes=(1, 0, 2),\n            )\n\n            if orbitals:\n                #  element_orbitals = (element_orbitals_up - element_orbitals_down) / (element_orbitals_up + element_orbitals_down)\n                element_orbitals = np.array(\n                    [element_orbitals_up, element_orbitals_down]\n                )\n                return element_orbitals\n            elif spd:\n                if not self.forbitals:\n                    spd_indices = [\n                        np.array([False for _ in range(9)]) for i in range(3)\n                    ]\n                    spd_indices[0][0] = True\n                    spd_indices[1][1:4] = True\n                    spd_indices[2][4:] = True\n                else:\n                    spd_indices = [\n                        np.array([False for _ in range(16)]) for i in range(4)\n                    ]\n                    spd_indices[0][0] = True\n                    spd_indices[1][1:4] = True\n                    spd_indices[2][4:9] = True\n                    spd_indices[3][9:] = True\n\n                element_spd_up = np.transpose(\n                    np.array(\n                        [\n                            np.sum(element_orbitals_up[:, :, ind], axis=2)\n                            for ind in spd_indices\n                        ]\n                    ),\n                    axes=(1, 2, 0),\n                )\n\n                element_spd_down = np.transpose(\n                    np.array(\n                        [\n                            np.sum(element_orbitals_down[:, :, ind], axis=2)\n                            for ind in spd_indices\n                        ]\n                    ),\n                    axes=(1, 2, 0),\n                )\n\n                #  element_spd = (element_spd_up - element_spd_down) / (element_spd_up + element_spd_down)\n                element_spd = np.array([element_spd_up, element_spd_down])\n\n                return element_spd\n            else:\n                element_array_up = np.sum(element_orbitals_up, axis=2)\n                element_array_down = np.sum(element_orbitals_down, axis=2)\n\n                #  element_array = (element_array_up - element_array_down) / (element_array_up + element_array_down)\n                element_array = np.array(\n                    [element_array_up, element_array_down]\n                )\n\n                return element_array\n        else:\n            pdos_array = self.pdos_array\n\n            element_list = np.hstack(\n                [\n                    [symbols[i] for j in range(natoms[i])]\n                    for i in range(len(symbols))\n                ]\n            )\n\n            element_indices = [\n                np.where(np.isin(element_list, element))[0]\n                for element in elements\n            ]\n\n            element_orbitals = np.transpose(\n                np.array(\n                    [\n                        np.sum(pdos_array[:, ind, :], axis=1)\n                        for ind in element_indices\n                    ]\n                ),\n                axes=(1, 0, 2),\n            )\n\n            if orbitals:\n                return element_orbitals\n            elif spd:\n                if not self.forbitals:\n                    spd_indices = [\n                        np.array([False for _ in range(9)]) for i in range(3)\n                    ]\n                    spd_indices[0][0] = True\n                    spd_indices[1][1:4] = True\n                    spd_indices[2][4:] = True\n                else:\n                    spd_indices = [\n                        np.array([False for _ in range(16)]) for i in range(4)\n                    ]\n                    spd_indices[0][0] = True\n                    spd_indices[1][1:4] = True\n                    spd_indices[2][4:9] = True\n                    spd_indices[3][9:] = True\n\n                element_spd = np.transpose(\n                    np.array(\n                        [\n                            np.sum(element_orbitals[:, :, ind], axis=2)\n                            for ind in spd_indices\n                        ]\n                    ),\n                    axes=(1, 2, 0),\n                )\n\n                return element_spd\n            else:\n                element_array = np.sum(element_orbitals, axis=2)\n\n                return element_array\n\n    def _smear(self, dos, sigma):\n        \"\"\"\n        This function applied a 1D gaussian filter to the density of states\n\n        Parameters:\n            dos (np.ndarray): Array of densities.\n            sigma (float): Standard deviation used in the gaussian filter.\n\n\n        Returns:\n            _smeared_dos (np.ndarray): Array of _smeared densities.\n        \"\"\"\n\n        diff = np.diff(self.tdos_array[:, 0])\n        avgdiff = np.mean(diff)\n        _smeared_dos = gaussian_filter1d(dos, sigma / avgdiff)\n\n        return _smeared_dos\n\n    def _set_density_lims(\n        self,\n        ax,\n        tdensity,\n        tenergy,\n        erange,\n        energyaxis,\n        spin,\n        partial=False,\n        is_dict=False,\n        idx=None,\n        multiple=False,\n        log_scale=False,\n    ):\n        energy_in_plot_index = np.where(\n            (tenergy &gt;= erange[0]) &amp; (tenergy &lt;= erange[1])\n        )[0]\n\n        tdensity = tdensity[energy_in_plot_index]\n\n        if len(np.squeeze(tdensity).shape) == 1:\n            density_in_plot = np.squeeze(tdensity)\n        else:\n            if spin == \"up\" or spin == \"both\":\n                max_index = np.argmax(np.max(tdensity, axis=0))\n                density_in_plot = tdensity[:, max_index]\n            else:\n                min_index = np.argmin(np.min(tdensity, axis=0))\n                density_in_plot = tdensity[:, min_index]\n\n        if len(ax.lines) == 0:\n            if energyaxis == \"y\":\n                ax.set_ylim(erange)\n                if spin == \"up\" or spin == \"both\":\n                    ax.set_xlim(0, np.max(density_in_plot) * 1.1)\n                    if log_scale:\n                        ax.set_xlim(\n                            np.min(density_in_plot),\n                            np.max(density_in_plot)\n                            + np.abs(np.max(density_in_plot) * 0.1),\n                        )\n                    else:\n                        ax.set_xlim(0, np.max(density_in_plot) * 1.1)\n                elif spin == \"down\":\n                    ax.set_xlim(np.min(density_in_plot) * 1.1, 0)\n            elif energyaxis == \"x\":\n                ax.set_xlim(erange)\n                if spin == \"up\" or spin == \"both\":\n                    if log_scale:\n                        ax.set_ylim(\n                            np.min(density_in_plot),\n                            np.max(density_in_plot)\n                            + np.abs(np.max(density_in_plot) * 0.1),\n                        )\n                    else:\n                        ax.set_ylim(0, np.max(density_in_plot) * 1.1)\n                elif spin == \"down\":\n                    ax.set_ylim(np.min(density_in_plot) * 1.1, 0)\n        elif len(ax.lines) &gt; 0:\n            if energyaxis == \"y\":\n                ax.set_ylim(erange)\n                xlims = ax.get_xlim()\n                if xlims[0] == 0:\n                    if spin == \"up\" or spin == \"both\":\n                        ax.set_xlim(0, np.max(density_in_plot) * 1.1)\n                    elif spin == \"down\":\n                        ax.set_xlim(np.min(density_in_plot) * 1.1, xlims[1])\n                if xlims[1] == 0:\n                    if spin == \"up\" or spin == \"both\":\n                        ax.set_xlim(xlims[0], np.max(density_in_plot) * 1.1)\n                    elif spin == \"down\":\n                        ax.set_xlim(np.min(density_in_plot) * 1.1, 0)\n            elif energyaxis == \"x\":\n                ax.set_xlim(erange)\n                ylims = ax.get_ylim()\n                if ylims[0] == 0:\n                    if spin == \"up\" or spin == \"both\":\n                        ax.set_ylim(0, np.max(density_in_plot) * 1.1)\n                    elif spin == \"down\":\n                        ax.set_ylim(np.min(density_in_plot) * 1.1, ylims[1])\n                if ylims[1] == 0:\n                    if spin == \"up\" or spin == \"both\":\n                        ax.set_ylim(ylims[0], np.max(density_in_plot) * 1.1)\n                    elif spin == \"down\":\n                        ax.set_ylim(np.min(density_in_plot) * 1.1, 0)\n\n    def _sum_layers(self, layers, atol=None, custom_layer_inds=None):\n        from vaspvis.utils import group_layers\n\n        if custom_layer_inds is None:\n            groups, _ = group_layers(self.poscar.structure, atol=atol)\n        else:\n            groups = custom_layer_inds\n        atom_densities = self._sum_atoms(atoms=None)\n\n        if (\n            self.spin == \"both\"\n            and self.combination_method == \"sub\"\n            and self.sp_method == \"percentage\"\n        ):\n            densities_up = np.vstack(\n                [\n                    np.sum(np.vstack(atom_densities[0, :, [group]]), axis=1)\n                    for group in groups\n                ]\n            )\n            densities_down = np.vstack(\n                [\n                    np.sum(np.vstack(atom_densities[1, :, [group]]), axis=1)\n                    for group in groups\n                ]\n            )\n            summed_layers_up = np.sum(densities_up[layers], axis=0)\n            summed_layers_down = np.sum(densities_down[layers], axis=0)\n            summed_layers = np.array([summed_layers_up, summed_layers_down])\n        else:\n            densities = np.vstack(\n                [\n                    np.sum(np.vstack(atom_densities[:, [group]]), axis=1)\n                    for group in groups\n                ]\n            )\n            summed_layers = np.sum(densities[layers], axis=0)\n\n        return summed_layers\n\n    def _add_legend(self, ax, names, colors, fontsize=10, markersize=4):\n        legend_lines = []\n        legend_labels = []\n        for name, color in zip(names, colors):\n            legend_lines.append(\n                plt.Line2D(\n                    [0],\n                    [0],\n                    marker=\"o\",\n                    markersize=markersize,\n                    linestyle=\"\",\n                    color=color,\n                )\n            )\n            legend_labels.append(f\"${name}$\")\n\n        leg = ax.get_legend()\n\n        if leg is None:\n            handles = legend_lines\n            labels = legend_labels\n        else:\n            handles = [l._legmarker for l in leg.legendHandles]\n            labels = [text._text for text in leg.texts]\n            handles.extend(legend_lines)\n            labels.extend(legend_labels)\n\n        ax.legend(\n            handles,\n            labels,\n            ncol=1,\n            loc=\"upper left\",\n            fontsize=fontsize,\n            bbox_to_anchor=(1, 1),\n            borderaxespad=0,\n            frameon=False,\n            handletextpad=0.1,\n        )\n\n    def _plot_projected_general(\n        self,\n        ax,\n        energy,\n        projected_data,\n        colors,\n        sigma,\n        erange,\n        linewidth,\n        alpha_line,\n        alpha,\n        fill,\n        energyaxis,\n        total,\n    ):\n        energy_in_plot_index = np.where(\n            (energy &gt;= erange[0] - 0.5) &amp; (energy &lt;= erange[1] + 0.5)\n        )[0]\n        energy = energy[energy_in_plot_index]\n\n        if (\n            self.spin == \"both\"\n            and self.combination_method == \"sub\"\n            and self.sp_method == \"percentage\"\n        ):\n            projected_data_up = projected_data[0]\n            projected_data_down = projected_data[1]\n\n            projected_data_up = projected_data_up[energy_in_plot_index]\n            projected_data_down = projected_data_down[energy_in_plot_index]\n\n            unique_colors = np.unique(colors)\n\n            if len(unique_colors) == len(colors):\n                plot_colors = colors\n            else:\n                unique_inds = [np.isin(colors, c) for c in unique_colors]\n                projected_data_up = np.c_[\n                    [\n                        np.sum(projected_data_up[:, i], axis=1)\n                        for i in unique_inds\n                    ]\n                ].transpose()\n                projected_data_down = np.c_[\n                    [\n                        np.sum(projected_data_down[:, i], axis=1)\n                        for i in unique_inds\n                    ]\n                ].transpose()\n                plot_colors = unique_colors\n\n            projected_data = (projected_data_up - projected_data_down) / (\n                projected_data_up + projected_data_down\n            )\n            projected_data[np.isnan(projected_data)] = 1e-9\n\n            if sigma &gt; 0:\n                for i in range(projected_data.shape[-1]):\n                    projected_data[:, i] = self._smear(\n                        projected_data[:, i],\n                        sigma=sigma,\n                    )\n        else:\n            projected_data = projected_data[energy_in_plot_index]\n\n            unique_colors = np.unique(colors)\n\n            if len(unique_colors) == len(colors):\n                plot_colors = colors\n            else:\n                unique_inds = [np.isin(colors, c) for c in unique_colors]\n                projected_data = np.c_[\n                    [np.sum(projected_data[:, i], axis=1) for i in unique_inds]\n                ].transpose()\n                plot_colors = unique_colors\n\n            if sigma &gt; 0:\n                for i in range(projected_data.shape[-1]):\n                    projected_data[:, i] = self._smear(\n                        projected_data[:, i],\n                        sigma=sigma,\n                    )\n\n        if total:\n            self.plot_plain(\n                ax=ax,\n                linewidth=linewidth,\n                fill=fill,\n                alpha=alpha,\n                alpha_line=alpha_line,\n                sigma=sigma,\n                energyaxis=energyaxis,\n                erange=erange,\n            )\n        else:\n            self._set_density_lims(\n                ax=ax,\n                tdensity=projected_data,\n                tenergy=energy,\n                erange=erange,\n                energyaxis=energyaxis,\n                spin=self.spin,\n                partial=True,\n            )\n\n        for i in range(projected_data.shape[-1]):\n\n            pdensity = projected_data[:, i]\n\n            if energyaxis == \"y\":\n                ax.plot(\n                    pdensity,\n                    energy,\n                    color=plot_colors[i],\n                    linewidth=linewidth,\n                    alpha=alpha_line,\n                )\n\n                if fill:\n                    ax.fill_betweenx(\n                        energy,\n                        pdensity,\n                        0,\n                        color=plot_colors[i],\n                        alpha=alpha,\n                    )\n\n            if energyaxis == \"x\":\n                ax.plot(\n                    energy,\n                    pdensity,\n                    color=plot_colors[i],\n                    linewidth=linewidth,\n                    alpha=alpha_line,\n                )\n\n                if fill:\n                    ax.fill_between(\n                        energy,\n                        pdensity,\n                        0,\n                        color=plot_colors[i],\n                        alpha=alpha,\n                    )\n\n    def plot_plain(\n        self,\n        ax,\n        linewidth=1.5,\n        fill=True,\n        alpha=0.3,\n        alpha_line=1.0,\n        sigma=0.05,\n        energyaxis=\"y\",\n        color=\"black\",\n        erange=[-6, 6],\n        log_scale=False,\n    ):\n        \"\"\"\n        This function plots the total density of states\n\n        Parameters:\n            ax (matplotlib.pyplot.axis): Axis to append the tick labels\n            linewidth (float): Linewidth of lines\n            fill (bool): Determines wether or not to fill underneath the plot\n            alpha (float): Alpha value for the fill\n            alpha_line (float): Alpha value for the line\n            sigma (float): Standard deviation for gaussian filter\n            energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n            color (str): Color of line\n            erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        \"\"\"\n\n        tdos_array = self.tdos_array\n        energy_in_plot_index = np.where(\n            (tdos_array[:, 0] &gt;= erange[0] - 0.5)\n            &amp; (tdos_array[:, 0] &lt;= erange[1] + 0.5)\n        )[0]\n        tdos_array = tdos_array[energy_in_plot_index]\n\n        if sigma &gt; 0:\n            tdensity = self._smear(tdos_array[:, 1], sigma=sigma)\n        else:\n            tdensity = tdos_array[:, 1]\n\n        if log_scale:\n            tdensity = np.log10(tdensity)\n            neg_inf_loc = np.isin(tdensity, -np.inf)\n            min_val = np.min(tdensity[np.logical_not(neg_inf_loc)])\n            tdensity[neg_inf_loc] = min_val\n\n        self._set_density_lims(\n            ax=ax,\n            tdensity=tdensity,\n            tenergy=tdos_array[:, 0],\n            erange=erange,\n            energyaxis=energyaxis,\n            spin=self.spin,\n            log_scale=log_scale,\n        )\n\n        if energyaxis == \"y\":\n            ax.plot(\n                tdensity,\n                tdos_array[:, 0],\n                linewidth=linewidth,\n                color=color,\n                alpha=alpha_line,\n            )\n\n            if fill:\n                ax.fill_betweenx(\n                    tdos_array[:, 0],\n                    tdensity,\n                    0,\n                    alpha=alpha,\n                    color=color,\n                )\n\n        if energyaxis == \"x\":\n            ax.plot(\n                tdos_array[:, 0],\n                tdensity,\n                linewidth=linewidth,\n                color=color,\n                alpha=alpha_line,\n            )\n\n            if fill:\n                ax.fill_between(\n                    tdos_array[:, 0],\n                    tdensity,\n                    0,\n                    color=color,\n                    alpha=alpha,\n                )\n\n    def plot_ldos(\n        self,\n        ax,\n        layers,\n        linewidth=1.5,\n        fill=False,\n        alpha=0.3,\n        alpha_line=1.0,\n        sigma=0.05,\n        energyaxis=\"x\",\n        color=\"black\",\n        log_scale=False,\n        erange=[-6, 6],\n        atol=None,\n        custom_layer_inds=None,\n        linestyle=\"-\",\n    ):\n        \"\"\"\n        This function plots the total density of states\n\n        Parameters:\n            ax (matplotlib.pyplot.axis): Axis to append the tick labels\n            linewidth (float): Linewidth of lines\n            fill (bool): Determines wether or not to fill underneath the plot\n            alpha (float): Alpha value for the fill\n            alpha_line (float): Alpha value for the line\n            sigma (float): Standard deviation for gaussian filter\n            energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n            color (str): Color of line\n            erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        \"\"\"\n\n        #  tdos_array = self._sum_layers(layers=layers)\n        tdos_array = self.tdos_array\n\n        tdensity = self._sum_layers(\n            layers=layers, atol=atol, custom_layer_inds=custom_layer_inds\n        )\n\n        if (\n            self.spin == \"both\"\n            and self.combination_method == \"sub\"\n            and self.sp_method == \"percentage\"\n        ):\n            tdensity = (tdensity[0] - tdensity[1]) / (\n                tdensity[0] + tdensity[1]\n            )\n            tdensity[np.isnan(tdensity)] = 1e-9\n\n        if sigma &gt; 0:\n            tdensity = self._smear(tdensity, sigma=sigma)\n\n        if log_scale:\n            tdensity = np.log10(tdensity)\n            neg_inf_loc = np.isin(tdensity, -np.inf)\n            min_val = np.min(tdensity[np.logical_not(neg_inf_loc)])\n            tdensity[neg_inf_loc] = min_val\n\n        self._set_density_lims(\n            ax=ax,\n            tdensity=tdensity,\n            tenergy=tdos_array[:, 0],\n            erange=erange,\n            energyaxis=energyaxis,\n            spin=self.spin,\n            log_scale=log_scale,\n        )\n\n        if energyaxis == \"y\":\n            ax.plot(\n                tdensity,\n                tdos_array[:, 0],\n                linewidth=linewidth,\n                color=color,\n                alpha=alpha_line,\n                linestyle=linestyle,\n            )\n\n            if fill:\n                ax.fill_betweenx(\n                    tdos_array[:, 0],\n                    tdensity,\n                    0,\n                    alpha=alpha,\n                    color=color,\n                )\n\n        if energyaxis == \"x\":\n            ax.plot(\n                tdos_array[:, 0],\n                tdensity,\n                linewidth=linewidth,\n                color=color,\n                alpha=alpha_line,\n                linestyle=linestyle,\n            )\n\n            if fill:\n                ax.fill_between(\n                    tdos_array[:, 0],\n                    tdensity,\n                    0,\n                    color=color,\n                    alpha=alpha,\n                )\n\n    def plot_spd(\n        self,\n        ax,\n        orbitals=\"spd\",\n        fill=True,\n        alpha=0.3,\n        alpha_line=1.0,\n        linewidth=1.5,\n        sigma=0.05,\n        energyaxis=\"y\",\n        color_list=None,\n        legend=True,\n        total=True,\n        erange=[-6, 6],\n    ):\n        \"\"\"\n        This function plots the total density of states with the projected\n        density of states for the total projections of the s, p, and d orbitals.\n\n        Parameters:\n            ax (matplotlib.pyplot.axis): Axis to plot on\n            order (list): Order to plot the projected bands in. This feature helps to\n                avoid situations where one projection completely convers the other.\n            fill (bool): Determines wether or not to fill underneath the plot\n            alpha (float): Alpha value for the fill\n            alpha_line (float): Alpha value for the line\n            linewidth (float): Linewidth of lines\n            sigma (float): Standard deviation for gaussian filter\n            energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n            color_dict (dict[str][str]): This option allow the colors of the s, p, and d\n                orbitals to be specified. Should be in the form of:\n                {'s': &lt;s color&gt;, 'p': &lt;p color&gt;, 'd': &lt;d color&gt;}\n            legend (bool): Determines whether to draw the legend or not\n            total (bool): Determines wheth to draw the total density of states or not\n            erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        \"\"\"\n\n        projected_data = self._sum_spd(spd=orbitals)\n\n        if color_list is None:\n            color_list = [\n                self.color_dict[0],\n                self.color_dict[1],\n                self.color_dict[2],\n                self.color_dict[4],\n            ]\n            colors = np.array([color_list[i] for i in range(len(orbitals))])\n        else:\n            colors = color_list\n\n        self._plot_projected_general(\n            ax=ax,\n            energy=self.tdos_array[:, 0],\n            projected_data=projected_data,\n            colors=colors,\n            sigma=sigma,\n            erange=erange,\n            linewidth=linewidth,\n            alpha_line=alpha_line,\n            alpha=alpha,\n            fill=fill,\n            energyaxis=energyaxis,\n            total=total,\n        )\n\n        if legend:\n            self._add_legend(ax, names=[i for i in orbitals], colors=colors)\n\n    def plot_atom_orbitals(\n        self,\n        ax,\n        atom_orbital_dict,\n        fill=True,\n        alpha=0.3,\n        alpha_line=1.0,\n        linewidth=1.5,\n        sigma=0.05,\n        energyaxis=\"y\",\n        color_list=None,\n        legend=True,\n        total=True,\n        erange=[-6, 6],\n    ):\n        \"\"\"\n        This function plots the total density of states with the projected\n        density of states for the projections or orbitals on individual atoms.\n\n        Parameters:\n            ax (matplotlib.pyplot.axis): Axis to plot on\n            atom_orbital_pairs (list[list]): List of atoms orbitals pairs in the form of\n                [[atom index, orbital index], [atom index, orbital index], ..]\n            fill (bool): Determines wether or not to fill underneath the plot\n            alpha (float): Alpha value for the fill\n            alpha_line (float): Alpha value for the line\n            linewidth (float): Linewidth of lines\n            sigma (float): Standard deviation for gaussian filter\n            energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n            color_list (list): List of colors that is the same length as the atom orbitals list\n            legend (bool): Determines whether to draw the legend or not\n            total (bool): Determines wheth to draw the total density of states or not\n            erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        \"\"\"\n\n        atom_indices = list(atom_orbital_dict.keys())\n        orbital_indices = list(atom_orbital_dict.values())\n        number_orbitals = [len(i) for i in orbital_indices]\n        atom_indices = np.repeat(atom_indices, number_orbitals)\n        orbital_symbols_long = np.hstack(\n            [[self.orbital_labels[o] for o in orb] for orb in orbital_indices]\n        )\n        orbital_indices_long = np.hstack(orbital_indices)\n        indices = np.vstack([atom_indices, orbital_indices_long]).T\n\n        projected_data = self.pdos_array\n\n        if (\n            self.spin == \"both\"\n            and self.combination_method == \"sub\"\n            and self.sp_method == \"percentage\"\n        ):\n            projected_data_up = np.transpose(\n                np.array(\n                    [projected_data[0, :, ind[0], ind[1]] for ind in indices]\n                ),\n                axes=(1, 0),\n            )\n            projected_data_down = np.transpose(\n                np.array(\n                    [projected_data[1, :, ind[0], ind[1]] for ind in indices]\n                ),\n                axes=(1, 0),\n            )\n            projected_data = np.array([projected_data_up, projected_data_down])\n        else:\n            projected_data = np.transpose(\n                np.array(\n                    [projected_data[:, ind[0], ind[1]] for ind in indices]\n                ),\n                axes=(1, 0),\n            )\n\n        if color_list is None:\n            colors = np.array(\n                [self.color_dict[i] for i in range(len(orbital_indices_long))]\n            )\n        else:\n            colors = color_list\n\n        self._plot_projected_general(\n            ax=ax,\n            energy=self.tdos_array[:, 0],\n            projected_data=projected_data,\n            colors=colors,\n            sigma=sigma,\n            erange=erange,\n            linewidth=linewidth,\n            alpha_line=alpha_line,\n            alpha=alpha,\n            fill=fill,\n            energyaxis=energyaxis,\n            total=total,\n        )\n\n        if legend:\n            self._add_legend(\n                ax,\n                names=[\n                    f\"{i[0]}({i[1]})\"\n                    for i in zip(atom_indices, orbital_symbols_long)\n                ],\n                colors=colors,\n            )\n\n    def plot_orbitals(\n        self,\n        ax,\n        orbitals,\n        fill=True,\n        alpha=0.3,\n        alpha_line=1.0,\n        linewidth=1.5,\n        sigma=0.05,\n        energyaxis=\"y\",\n        color_list=None,\n        legend=True,\n        total=True,\n        erange=[-6, 6],\n    ):\n        \"\"\"\n        This function plots the total density of states with the projected\n        density of states for the projections onto given orbitals\n\n        Parameters:\n            ax (matplotlib.pyplot.axis): Axis to plot on\n            orbitals (list): List of orbitals to project onto\n            fill (bool): Determines wether or not to fill underneath the plot\n            alpha (float): Alpha value for the fill\n            alpha_line (float): Alpha value for the line\n            linewidth (float): Linewidth of lines\n            sigma (float): Standard deviation for gaussian filter\n            energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n            color_dict (dict[str][str]): This option allow the colors of each orbital\n                specified. Should be in the form of:\n                {'orbital index': &lt;color&gt;, 'orbital index': &lt;color&gt;, ...}\n            legend (bool): Determines whether to draw the legend or not\n            total (bool): Determines wheth to draw the total density of states or not\n            erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        \"\"\"\n        if color_list is None:\n            colors = np.array([self.color_dict[i] for i in orbitals])\n        else:\n            colors = color_list\n\n        projected_data = self._sum_orbitals(orbitals=orbitals)\n\n        self._plot_projected_general(\n            ax=ax,\n            energy=self.tdos_array[:, 0],\n            projected_data=projected_data,\n            colors=colors,\n            sigma=sigma,\n            erange=erange,\n            linewidth=linewidth,\n            alpha_line=alpha_line,\n            alpha=alpha,\n            fill=fill,\n            energyaxis=energyaxis,\n            total=total,\n        )\n\n        if legend:\n            self._add_legend(\n                ax,\n                names=[self.orbital_labels[i] for i in orbitals],\n                colors=colors,\n            )\n\n    def plot_atoms(\n        self,\n        ax,\n        atoms,\n        fill=True,\n        alpha=0.3,\n        alpha_line=1.0,\n        linewidth=1.5,\n        sigma=0.05,\n        energyaxis=\"y\",\n        color_list=None,\n        legend=True,\n        total=True,\n        erange=[-6, 6],\n        sum_atoms=False,\n    ):\n        \"\"\"\n        This function plots the total density of states with the projected density of states on the given atoms.\n\n        Parameters:\n            ax (matplotlib.pyplot.axis): Axis to plot on\n            atoms (list): Index of atoms to plot\n            fill (bool): Determines wether or not to fill underneath the plot\n            alpha (float): Alpha value for the fill\n            alpha_line (float): Alpha value for the line\n            color_list (list): Optional list of colors of the same length as the atoms list.\n            linewidth (float): Linewidth of lines\n            sigma (float): Standard deviation for gaussian filter\n            energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n            legend (bool): Determines whether to draw the legend or not\n            total (bool): Determines wheth to draw the total density of states or not\n            erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        \"\"\"\n\n        if color_list is None:\n            colors = np.array([self.color_dict[i] for i in range(len(atoms))])\n        else:\n            colors = color_list\n\n        projected_data = self._sum_atoms(atoms=atoms)\n\n        #  if sum_atoms:\n        #  if self.spin == 'both' and self.combination_method == 'sub' and self.sp_method == 'percentage':\n        #  projected_data_up = np.sum(projected_data[0], axis=1).reshape(-1,1)\n        #  projected_data_up = np.sum(projected_data[1], axis=1).reshape(-1,1)\n        #  colors = [colors[0]]\n        #  else:\n        #  projected_data = np.sum(projected_data, axis=1).reshape(-1,1)\n        #  colors = [colors[0]]\n\n        self._plot_projected_general(\n            ax=ax,\n            energy=self.tdos_array[:, 0],\n            projected_data=projected_data,\n            colors=colors,\n            sigma=sigma,\n            erange=erange,\n            linewidth=linewidth,\n            alpha_line=alpha_line,\n            alpha=alpha,\n            fill=fill,\n            energyaxis=energyaxis,\n            total=total,\n        )\n\n        if legend:\n            self._add_legend(ax, names=atoms, colors=colors)\n\n    def plot_atom_spd(\n        self,\n        ax,\n        atom_spd_dict,\n        fill=True,\n        alpha=0.3,\n        alpha_line=1.0,\n        linewidth=1.5,\n        sigma=0.05,\n        energyaxis=\"y\",\n        color_list=None,\n        legend=True,\n        total=True,\n        erange=[-6, 6],\n    ):\n        \"\"\"\n        This function plots the total density of states with the projected\n        density of states onto the s, p, and d orbitals of specified atoms.\n        This is useful for supercells where there are many atoms of the same\n        atom and it is inconvienient to manually list each index in the POSCAR.\n\n        Parameters:\n            ax (matplotlib.pyplot.axis): Axis to plot on\n            atoms (list): List of atom symbols to project onto\n            order (list): Order to plot the projected bands in. This feature helps to\n                avoid situations where one projection completely convers the other.\n            fill (bool): Determines wether or not to fill underneath the plot\n            alpha (float): Alpha value for the fill\n            alpha_line (float): Alpha value for the line\n            linewidth (float): Linewidth of lines\n            sigma (float): Standard deviation for gaussian filter\n            energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n            color_dict (dict[str][str]): This option allow the colors of each atom\n                specified. Should be in the form of:\n                {'atom index': &lt;color&gt;, 'atom index': &lt;color&gt;, ...}\n            legend (bool): Determines whether to draw the legend or not\n            total (bool): Determines wheth to draw the total density of states or not\n            erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        \"\"\"\n\n        atom_indices = list(atom_spd_dict.keys())\n        orbital_symbols = list(atom_spd_dict.values())\n        number_orbitals = [len(i) for i in orbital_symbols]\n        atom_indices = np.repeat(atom_indices, number_orbitals)\n        orbital_symbols_long = np.hstack(\n            [[o for o in orb] for orb in orbital_symbols]\n        )\n        orbital_indices = np.hstack(\n            [[self.spd_relations[o] for o in orb] for orb in orbital_symbols]\n        )\n        indices = np.vstack([atom_indices, orbital_indices]).T\n\n        projected_data = self._sum_atoms(atoms=atom_indices, spd=True)\n\n        if (\n            self.spin == \"both\"\n            and self.combination_method == \"sub\"\n            and self.sp_method == \"percentage\"\n        ):\n            projected_data_up = np.transpose(\n                np.array(\n                    [projected_data[0, :, ind[0], ind[1]] for ind in indices]\n                ),\n                axes=(1, 0),\n            )\n            projected_data_down = np.transpose(\n                np.array(\n                    [projected_data[1, :, ind[0], ind[1]] for ind in indices]\n                ),\n                axes=(1, 0),\n            )\n            projected_data = np.array([projected_data_up, projected_data_down])\n        else:\n            projected_data = np.transpose(\n                np.array(\n                    [projected_data[:, ind[0], ind[1]] for ind in indices]\n                ),\n                axes=(1, 0),\n            )\n\n        if color_list is None:\n            colors = np.array(\n                [self.color_dict[i] for i in range(len(orbital_symbols_long))]\n            )\n        else:\n            colors = color_list\n\n        self._plot_projected_general(\n            ax=ax,\n            energy=self.tdos_array[:, 0],\n            projected_data=projected_data,\n            colors=colors,\n            sigma=sigma,\n            erange=erange,\n            linewidth=linewidth,\n            alpha_line=alpha_line,\n            alpha=alpha,\n            fill=fill,\n            energyaxis=energyaxis,\n            total=total,\n        )\n\n        if legend:\n            self._add_legend(\n                ax,\n                names=[\n                    f\"{i[0]}({i[1]})\"\n                    for i in zip(atom_indices, orbital_symbols_long)\n                ],\n                colors=colors,\n            )\n\n    def plot_elements(\n        self,\n        ax,\n        elements,\n        fill=True,\n        alpha=0.3,\n        alpha_line=1.0,\n        linewidth=1.5,\n        sigma=0.05,\n        energyaxis=\"y\",\n        color_list=None,\n        legend=True,\n        total=True,\n        erange=[-6, 6],\n    ):\n        \"\"\"\n        This function plots the total density of states with the projected\n        density of states for the projection onto specified elements. This is\n        useful for supercells where there are many atoms of the same element and\n        it is inconvienient to manually list each index in the POSCAR.\n\n        Parameters:\n            ax (matplotlib.pyplot.axis): Axis to plot on\n            elements (list): List of element symbols to project onto\n            fill (bool): Determines wether or not to fill underneath the plot\n            alpha (float): Alpha value for the fill\n            alpha_line (float): Alpha value for the line\n            linewidth (float): Linewidth of lines\n            sigma (float): Standard deviation for gaussian filter\n            energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n            color_list (list): List of colors that is the same length at the elements list\n            legend (bool): Determines whether to draw the legend or not\n            total (bool): Determines wheth to draw the total density of states or not\n            erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        \"\"\"\n\n        if color_list is None:\n            colors = np.array(\n                [self.color_dict[i] for i in range(len(elements))]\n            )\n        else:\n            colors = color_list\n\n        projected_data = self._sum_elements(elements=elements)\n\n        self._plot_projected_general(\n            ax=ax,\n            energy=self.tdos_array[:, 0],\n            projected_data=projected_data,\n            colors=colors,\n            sigma=sigma,\n            erange=erange,\n            linewidth=linewidth,\n            alpha_line=alpha_line,\n            alpha=alpha,\n            fill=fill,\n            energyaxis=energyaxis,\n            total=total,\n        )\n\n        if legend:\n            self._add_legend(ax, names=elements, colors=colors)\n\n    def plot_element_orbitals(\n        self,\n        ax,\n        element_orbital_dict,\n        fill=True,\n        alpha=0.3,\n        alpha_line=1.0,\n        linewidth=1.5,\n        sigma=0.05,\n        energyaxis=\"y\",\n        color_list=None,\n        legend=True,\n        total=True,\n        erange=[-6, 6],\n    ):\n        \"\"\"\n        This function plots the total density of states with the projected\n        density of states onto the chosen orbitals of specified elements. This is\n        useful for supercells where there are many atoms of the same element and\n        it is inconvienient to manually list each index in the POSCAR.\n\n        Parameters:\n            ax (matplotlib.pyplot.axis): Axis to plot on\n            element_orbital_pairs (list[list]): List of element orbital pairs in the form of\n                [[element symbol, orbital index], [element symbol, orbital index], ..]\n            fill (bool): Determines wether or not to fill underneath the plot\n            alpha (float): Alpha value for the fill\n            alpha_line (float): Alpha value for the line\n            linewidth (float): Linewidth of lines\n            sigma (float): Standard deviation for gaussian filter\n            energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n            color_list (list): List of colors that is the same length as the element orbitals list\n            legend (bool): Determines whether to draw the legend or not\n            total (bool): Determines wheth to draw the total density of states or not\n            erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        \"\"\"\n\n        element_symbols = list(element_orbital_dict.keys())\n        orbital_indices = list(element_orbital_dict.values())\n        number_orbitals = [len(i) for i in orbital_indices]\n        element_symbols_long = np.repeat(element_symbols, number_orbitals)\n        element_indices = np.repeat(\n            range(len(element_symbols)), number_orbitals\n        )\n        orbital_symbols_long = np.hstack(\n            [[self.orbital_labels[o] for o in orb] for orb in orbital_indices]\n        )\n        orbital_indices_long = np.hstack(orbital_indices)\n        indices = np.vstack([element_indices, orbital_indices_long]).T\n\n        projected_data = self._sum_elements(\n            elements=element_symbols, orbitals=True\n        )\n\n        if (\n            self.spin == \"both\"\n            and self.combination_method == \"sub\"\n            and self.sp_method == \"percentage\"\n        ):\n            projected_data_up = np.transpose(\n                np.array(\n                    [projected_data[0, :, ind[0], ind[1]] for ind in indices]\n                ),\n                axes=(1, 0),\n            )\n            projected_data_down = np.transpose(\n                np.array(\n                    [projected_data[1, :, ind[0], ind[1]] for ind in indices]\n                ),\n                axes=(1, 0),\n            )\n            projected_data = np.array([projected_data_up, projected_data_down])\n        else:\n            projected_data = np.transpose(\n                np.array(\n                    [projected_data[:, ind[0], ind[1]] for ind in indices]\n                ),\n                axes=(1, 0),\n            )\n\n        if color_list is None:\n            colors = np.array(\n                [self.color_dict[i] for i in range(len(orbital_indices_long))]\n            )\n        else:\n            colors = color_list\n\n        self._plot_projected_general(\n            ax=ax,\n            energy=self.tdos_array[:, 0],\n            projected_data=projected_data,\n            colors=colors,\n            sigma=sigma,\n            erange=erange,\n            linewidth=linewidth,\n            alpha_line=alpha_line,\n            alpha=alpha,\n            fill=fill,\n            energyaxis=energyaxis,\n            total=total,\n        )\n\n        if legend:\n            self._add_legend(\n                ax,\n                names=[\n                    f\"{i[0]}({i[1]})\"\n                    for i in zip(element_symbols_long, orbital_symbols_long)\n                ],\n                colors=colors,\n            )\n\n    def plot_element_spd(\n        self,\n        ax,\n        element_spd_dict,\n        fill=True,\n        alpha=0.3,\n        alpha_line=1.0,\n        linewidth=1.5,\n        sigma=0.05,\n        energyaxis=\"y\",\n        color_list=None,\n        legend=True,\n        total=True,\n        erange=[-6, 6],\n    ):\n        \"\"\"\n        This function plots the total density of states with the projected\n        density of states onto the s, p, and d orbitals of specified elements.\n        This is useful for supercells where there are many atoms of the same\n        element and it is inconvienient to manually list each index in the POSCAR.\n\n        Parameters:\n            ax (matplotlib.pyplot.axis): Axis to plot on\n            elements (list): List of element symbols to project onto\n            order (list): Order to plot the projected bands in. This feature helps to\n                avoid situations where one projection completely convers the other.\n            fill (bool): Determines wether or not to fill underneath the plot\n            alpha (float): Alpha value for the fill\n            alpha_line (float): Alpha value for the line\n            linewidth (float): Linewidth of lines\n            sigma (float): Standard deviation for gaussian filter\n            energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n            color_dict (dict[str][str]): This option allow the colors of each element\n                specified. Should be in the form of:\n                {'element index': &lt;color&gt;, 'element index': &lt;color&gt;, ...}\n            legend (bool): Determines whether to draw the legend or not\n            total (bool): Determines wheth to draw the total density of states or not\n            erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        \"\"\"\n        element_symbols = list(element_spd_dict.keys())\n        orbital_symbols = list(element_spd_dict.values())\n        number_orbitals = [len(i) for i in orbital_symbols]\n        element_symbols_long = np.repeat(element_symbols, number_orbitals)\n        element_indices = np.repeat(\n            range(len(element_symbols)), number_orbitals\n        )\n        orbital_symbols_long = np.hstack(\n            [[o for o in orb] for orb in orbital_symbols]\n        )\n        orbital_indices = np.hstack(\n            [[self.spd_relations[o] for o in orb] for orb in orbital_symbols]\n        )\n        indices = np.vstack([element_indices, orbital_indices]).T\n\n        projected_data = self._sum_elements(elements=element_symbols, spd=True)\n\n        if (\n            self.spin == \"both\"\n            and self.combination_method == \"sub\"\n            and self.sp_method == \"percentage\"\n        ):\n            projected_data_up = np.transpose(\n                np.array(\n                    [projected_data[0, :, ind[0], ind[1]] for ind in indices]\n                ),\n                axes=(1, 0),\n            )\n            projected_data_down = np.transpose(\n                np.array(\n                    [projected_data[1, :, ind[0], ind[1]] for ind in indices]\n                ),\n                axes=(1, 0),\n            )\n            projected_data = np.array([projected_data_up, projected_data_down])\n        else:\n            projected_data = np.transpose(\n                np.array(\n                    [projected_data[:, ind[0], ind[1]] for ind in indices]\n                ),\n                axes=(1, 0),\n            )\n\n        if color_list is None:\n            colors = np.array(\n                [self.color_dict[i] for i in range(len(orbital_symbols_long))]\n            )\n        else:\n            colors = color_list\n\n        self._plot_projected_general(\n            ax=ax,\n            energy=self.tdos_array[:, 0],\n            projected_data=projected_data,\n            colors=colors,\n            sigma=sigma,\n            erange=erange,\n            linewidth=linewidth,\n            alpha_line=alpha_line,\n            alpha=alpha,\n            fill=fill,\n            energyaxis=energyaxis,\n            total=total,\n        )\n\n        if legend:\n            self._add_legend(\n                ax,\n                names=[\n                    f\"{i[0]}({i[1]})\"\n                    for i in zip(element_symbols_long, orbital_symbols_long)\n                ],\n                colors=colors,\n            )\n\n    def plot_layers(\n        self,\n        ax,\n        cmap=\"magma\",\n        sigma_energy=0.05,\n        sigma_layers=0.75,\n        energyaxis=\"y\",\n        erange=[-6, 6],\n        lrange=None,\n        antialiased=False,\n        fontsize=6,\n        interface_layer=None,\n        show_interface_line=False,\n        interface_line_color=\"white\",\n        interface_line_width=2,\n        interface_line_style=\"--\",\n        log_scale=False,\n        contour=False,\n        levels=10,\n        min_cutoff=1e-7,\n        max_cutoff=None,\n        atol=None,\n        custom_layer_inds=None,\n        custom_cbar_label=None,\n        cbar_orientation=\"vertical\",\n        show_bounds=False,\n        set_bounds=None,\n    ):\n        \"\"\"\n        This function plots a layer by layer heat map of the density\n        of states.\n\n        Parameters:\n            ax (matplotlib.pyplot.axis): Axis to plot on\n            cmap (str): Color map to use in the heat map\n            sigma_energy (float): Variance for a gaussian blur with respect to the energy\n                This will help smooth out spikey looking density of states\n            sigma_layers (float): Variance for a gaussian blur with respect to the layers\n                This will help smooth out the the pixelation that can occur between the summed\n                dos with respect to the layers.\n            energyaxis (str): Axis to plot the energy on. ('x' or 'y')\n            erange (list): Upper and lower energy bounds for the plot.\n            lrange (list): Upper and lower bounds of the layers included in the plot.\n            antialiased (bool): Determines if antialiasing is used or not.\n            fontsize (float): Fontsize of all the text in the group.\n            interface_layer (float or None): If a value is provided, then the axis labels will be\n                shifted accordingly so that the defined interface layer is zero.\n            show_interface_line (bool): If True, then a line will be drawn\n                on the plot to identify the interface layer defined by interface_layer.\n            interface_line_color (str): Color of the line drawn on the plot to mark the\n                interface.\n            interface_line_width (float): Line with of the line marking the interface.\n            interface_line_style (str): Style of the line marking the interface.\n            log_scale (bool): Determines if the color map is applied in log scale of not.\n                Recommended in order to accurately view the band gap and smaller features.\n            contour (bool): Determines if the color map is plotted as a contour plot instead\n                of a heatmap.\n            levels (int): Number of levels used in the contour plot.\n            min_cutoff (float): Minimum dos value used to determine the cut off for the plot.\n                This can be adjusted to better visualize the band gap of the material.\n            atol (float or None): Tolarence used in the grouping of the layers.\n                This value is automatically calculated if None and is usually on the order of\n                1e-3.\n            custom_layer_inds (list or None): If the structure being calculated has relaxed\n                atomic positions, sometimes the layer grouping algorithm can behave non-idealy.\n                If this is the case, the user can input a list of list that contain the\n                atomic indices in each layers of the material.\n            custom_cbar_label (str or None): Custom label for the colorbar\n        \"\"\"\n        from vaspvis.utils import group_layers\n        import matplotlib.colors as colors\n\n        energy = self.tdos_array[:, 0]\n\n        ind = np.where(\n            (erange[0] - 0.1 &lt;= energy) &amp; (energy &lt;= erange[-1] + 0.1)\n        )\n        if custom_layer_inds is None:\n            groups, _ = group_layers(self.poscar.structure, atol=atol)\n        else:\n            groups = custom_layer_inds\n\n        atom_index = range(len(groups))\n        energies = energy[ind]\n\n        atom_densities = self._sum_atoms(atoms=None)\n\n        if (\n            self.spin == \"both\"\n            and self.combination_method == \"sub\"\n            and self.sp_method == \"percentage\"\n        ):\n            atom_densities_up = atom_densities[0, ind].squeeze()\n            atom_densities_down = atom_densities[1, ind].squeeze()\n            densities_up = np.vstack(\n                [\n                    np.sum(np.vstack(atom_densities_up[:, [group]]), axis=1)\n                    for group in groups\n                ]\n            )\n            densities_down = np.vstack(\n                [\n                    np.sum(np.vstack(atom_densities_down[:, [group]]), axis=1)\n                    for group in groups\n                ]\n            )\n            densities = (densities_up - densities_down) / (\n                densities_up + densities_down\n            )\n            densities[np.isnan(densities)] = 1e-9\n        else:\n            atom_densities = atom_densities[ind]\n            densities = np.vstack(\n                [\n                    np.sum(np.vstack(atom_densities[:, [group]]), axis=1)\n                    for group in groups\n                ]\n            )\n\n        densities = np.transpose(densities)\n\n        if lrange is not None:\n            atom_index = atom_index[lrange[0] : lrange[1] + 1]\n            densities = densities[:, lrange[0] : lrange[1] + 1]\n\n        if sigma_energy &gt; 0:\n            for i in range(densities.shape[-1]):\n                densities[:, i] = self._smear(\n                    densities[:, i],\n                    sigma=sigma_energy,\n                )\n        if sigma_layers &gt; 0:\n            densities = gaussian_filter(densities, sigma=sigma_layers)\n\n        f = interp2d(atom_index, energies, densities, kind=\"cubic\")\n        atom_index = np.arange(np.min(atom_index), np.max(atom_index), 0.1)\n        densities = f(atom_index, energies)\n\n        if log_scale:\n            if np.min(densities) &lt;= 0:\n                neg_zero_loc = np.where(densities &lt;= 0)\n                pos_loc = np.where(densities &gt; 0)\n                min_val = np.min(densities[pos_loc])\n                if min_val &lt; min_cutoff:\n                    min_val = min_cutoff\n                    too_small_loc = np.where(densities &lt; min_cutoff)\n                    densities[too_small_loc] = min_cutoff\n                else:\n                    densities[neg_zero_loc] = min_val\n            else:\n                min_val = np.min(densities)\n                if min_val &lt; min_cutoff:\n                    min_val = min_cutoff\n\n            if max_cutoff is not None:\n                max_val = max_cutoff\n            else:\n                max_val = np.max(densities)\n\n            norm = colors.LogNorm(vmin=min_val, vmax=max_val)\n        else:\n            if self.combination_method == \"sub\" and self.spin == \"both\":\n                if set_bounds is None:\n                    norm_val = np.max(\n                        np.abs([np.min(densities), np.max(densities)])\n                    )\n                else:\n                    norm_val = set_bounds\n\n                norm = colors.Normalize(vmin=-norm_val, vmax=norm_val)\n            else:\n                if max_cutoff is not None:\n                    max_val = max_cutoff\n                else:\n                    max_val = np.max(densities)\n\n                if min_cutoff is not None:\n                    min_val = min_cutoff\n                else:\n                    min_val = np.min(densities)\n\n                norm = colors.Normalize(vmin=min_val, vmax=max_val)\n\n        if log_scale:\n            lev_exp = np.arange(\n                np.floor(np.log10(densities.min()) - 1),\n                np.ceil(np.log10(densities.max()) + 1),\n            )\n            if len(lev_exp) &gt;= levels:\n                pass\n            else:\n                if int(levels / len(lev_exp)) &gt;= 3:\n                    lev_exp = np.arange(\n                        np.floor(np.log10(densities.min()) - 1),\n                        np.ceil(np.log10(densities.max()) + 1),\n                        0.25,\n                    )\n                else:\n                    lev_exp = np.arange(\n                        np.floor(np.log10(densities.min()) - 1),\n                        np.ceil(np.log10(densities.max()) + 1),\n                        0.5,\n                    )\n            levels = np.power(10, lev_exp)\n\n        if interface_layer is not None:\n            atom_index -= int(interface_layer)\n\n        if energyaxis == \"y\":\n\n            if contour:\n                im = ax.contourf(\n                    atom_index,\n                    energies,\n                    densities,\n                    cmap=cmap,\n                    levels=levels,\n                    norm=norm,\n                )\n            else:\n                im = ax.pcolormesh(\n                    atom_index,\n                    energies,\n                    densities,\n                    cmap=cmap,\n                    shading=\"gouraud\",\n                    norm=norm,\n                    antialiased=antialiased,\n                )\n            ax.xaxis.set_major_locator(MaxNLocator(integer=True))\n\n            if interface_layer is not None and show_interface_line:\n                ax.axvline(\n                    x=0,\n                    color=interface_line_color,\n                    linestyle=interface_line_style,\n                    linewidth=interface_line_width,\n                )\n\n        if energyaxis == \"x\":\n            if contour:\n                im = ax.contourf(\n                    energies,\n                    atom_index,\n                    densities,\n                    cmap=cmap,\n                    levels=levels,\n                    norm=norm,\n                )\n            else:\n                im = ax.pcolormesh(\n                    energies,\n                    atom_index,\n                    np.transpose(densities),\n                    cmap=cmap,\n                    shading=\"gouraud\",\n                    norm=norm,\n                    antialiased=antialiased,\n                )\n            ax.yaxis.set_major_locator(MaxNLocator(integer=True))\n\n            if interface_layer is not None and show_interface_line:\n                ax.axhline(\n                    y=0,\n                    color=interface_line_color,\n                    linestyle=interface_line_style,\n                    linewidth=interface_line_width,\n                )\n\n        fig = plt.gcf()\n        cbar = fig.colorbar(im, ax=ax, orientation=cbar_orientation)\n        cbar.ax.tick_params(labelsize=fontsize)\n        if custom_cbar_label is None:\n            if self.combination_method == \"sub\" and self.spin == \"both\":\n                cbar.set_label(\"Spin Polarization\", fontsize=fontsize)\n                min_val = im.norm.vmin\n                max_val = im.norm.vmax\n                cbar.set_ticks([min_val, max_val])\n                if not show_bounds:\n                    cbar.set_ticklabels([\"Down\", \"Up\"])\n            else:\n                cbar.set_label(\"Density of States\", fontsize=fontsize)\n        else:\n            cbar.set_label(custom_cbar_label, fontsize=fontsize)\n\n    def plot_structure(self, ax, rotation=[90, 90, 90]):\n        structure = self.poscar.structure\n        atoms = AseAtomsAdaptor().get_atoms(structure)\n        atoms = plot_atoms(\n            atoms,\n            ax,\n            radii=0.5,\n            rotation=(f\"{rotation[0]}x,{rotation[1]}y,{rotation[2]}z\"),\n            show_unit_cell=0,\n        )\n</code></pre>"},{"location":"dos/#vaspvis.dos.Dos.plot_atom_orbitals","title":"<code>plot_atom_orbitals(ax, atom_orbital_dict, fill=True, alpha=0.3, alpha_line=1.0, linewidth=1.5, sigma=0.05, energyaxis='y', color_list=None, legend=True, total=True, erange=[-6, 6])</code>","text":"<p>This function plots the total density of states with the projected density of states for the projections or orbitals on individual atoms.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>axis</code> <p>Axis to plot on</p> required <code>atom_orbital_pairs</code> <code>list[list]</code> <p>List of atoms orbitals pairs in the form of [[atom index, orbital index], [atom index, orbital index], ..]</p> required <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>alpha_line</code> <code>float</code> <p>Alpha value for the line</p> <code>1.0</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'y'</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the atom orbitals list</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines whether to draw the legend or not</p> <code>True</code> <code>total</code> <code>bool</code> <p>Determines wheth to draw the total density of states or not</p> <code>True</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> Source code in <code>vaspvis/dos.py</code> <pre><code>def plot_atom_orbitals(\n    self,\n    ax,\n    atom_orbital_dict,\n    fill=True,\n    alpha=0.3,\n    alpha_line=1.0,\n    linewidth=1.5,\n    sigma=0.05,\n    energyaxis=\"y\",\n    color_list=None,\n    legend=True,\n    total=True,\n    erange=[-6, 6],\n):\n    \"\"\"\n    This function plots the total density of states with the projected\n    density of states for the projections or orbitals on individual atoms.\n\n    Parameters:\n        ax (matplotlib.pyplot.axis): Axis to plot on\n        atom_orbital_pairs (list[list]): List of atoms orbitals pairs in the form of\n            [[atom index, orbital index], [atom index, orbital index], ..]\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        alpha_line (float): Alpha value for the line\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color_list (list): List of colors that is the same length as the atom orbitals list\n        legend (bool): Determines whether to draw the legend or not\n        total (bool): Determines wheth to draw the total density of states or not\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n    \"\"\"\n\n    atom_indices = list(atom_orbital_dict.keys())\n    orbital_indices = list(atom_orbital_dict.values())\n    number_orbitals = [len(i) for i in orbital_indices]\n    atom_indices = np.repeat(atom_indices, number_orbitals)\n    orbital_symbols_long = np.hstack(\n        [[self.orbital_labels[o] for o in orb] for orb in orbital_indices]\n    )\n    orbital_indices_long = np.hstack(orbital_indices)\n    indices = np.vstack([atom_indices, orbital_indices_long]).T\n\n    projected_data = self.pdos_array\n\n    if (\n        self.spin == \"both\"\n        and self.combination_method == \"sub\"\n        and self.sp_method == \"percentage\"\n    ):\n        projected_data_up = np.transpose(\n            np.array(\n                [projected_data[0, :, ind[0], ind[1]] for ind in indices]\n            ),\n            axes=(1, 0),\n        )\n        projected_data_down = np.transpose(\n            np.array(\n                [projected_data[1, :, ind[0], ind[1]] for ind in indices]\n            ),\n            axes=(1, 0),\n        )\n        projected_data = np.array([projected_data_up, projected_data_down])\n    else:\n        projected_data = np.transpose(\n            np.array(\n                [projected_data[:, ind[0], ind[1]] for ind in indices]\n            ),\n            axes=(1, 0),\n        )\n\n    if color_list is None:\n        colors = np.array(\n            [self.color_dict[i] for i in range(len(orbital_indices_long))]\n        )\n    else:\n        colors = color_list\n\n    self._plot_projected_general(\n        ax=ax,\n        energy=self.tdos_array[:, 0],\n        projected_data=projected_data,\n        colors=colors,\n        sigma=sigma,\n        erange=erange,\n        linewidth=linewidth,\n        alpha_line=alpha_line,\n        alpha=alpha,\n        fill=fill,\n        energyaxis=energyaxis,\n        total=total,\n    )\n\n    if legend:\n        self._add_legend(\n            ax,\n            names=[\n                f\"{i[0]}({i[1]})\"\n                for i in zip(atom_indices, orbital_symbols_long)\n            ],\n            colors=colors,\n        )\n</code></pre>"},{"location":"dos/#vaspvis.dos.Dos.plot_atom_spd","title":"<code>plot_atom_spd(ax, atom_spd_dict, fill=True, alpha=0.3, alpha_line=1.0, linewidth=1.5, sigma=0.05, energyaxis='y', color_list=None, legend=True, total=True, erange=[-6, 6])</code>","text":"<p>This function plots the total density of states with the projected density of states onto the s, p, and d orbitals of specified atoms. This is useful for supercells where there are many atoms of the same atom and it is inconvienient to manually list each index in the POSCAR.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>axis</code> <p>Axis to plot on</p> required <code>atoms</code> <code>list</code> <p>List of atom symbols to project onto</p> required <code>order</code> <code>list</code> <p>Order to plot the projected bands in. This feature helps to avoid situations where one projection completely convers the other.</p> required <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>alpha_line</code> <code>float</code> <p>Alpha value for the line</p> <code>1.0</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'y'</code> <code>color_dict</code> <code>dict[str][str]</code> <p>This option allow the colors of each atom specified. Should be in the form of: {'atom index': , 'atom index': , ...} required <code>legend</code> <code>bool</code> <p>Determines whether to draw the legend or not</p> <code>True</code> <code>total</code> <code>bool</code> <p>Determines wheth to draw the total density of states or not</p> <code>True</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> Source code in <code>vaspvis/dos.py</code> <pre><code>def plot_atom_spd(\n    self,\n    ax,\n    atom_spd_dict,\n    fill=True,\n    alpha=0.3,\n    alpha_line=1.0,\n    linewidth=1.5,\n    sigma=0.05,\n    energyaxis=\"y\",\n    color_list=None,\n    legend=True,\n    total=True,\n    erange=[-6, 6],\n):\n    \"\"\"\n    This function plots the total density of states with the projected\n    density of states onto the s, p, and d orbitals of specified atoms.\n    This is useful for supercells where there are many atoms of the same\n    atom and it is inconvienient to manually list each index in the POSCAR.\n\n    Parameters:\n        ax (matplotlib.pyplot.axis): Axis to plot on\n        atoms (list): List of atom symbols to project onto\n        order (list): Order to plot the projected bands in. This feature helps to\n            avoid situations where one projection completely convers the other.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        alpha_line (float): Alpha value for the line\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color_dict (dict[str][str]): This option allow the colors of each atom\n            specified. Should be in the form of:\n            {'atom index': &lt;color&gt;, 'atom index': &lt;color&gt;, ...}\n        legend (bool): Determines whether to draw the legend or not\n        total (bool): Determines wheth to draw the total density of states or not\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n    \"\"\"\n\n    atom_indices = list(atom_spd_dict.keys())\n    orbital_symbols = list(atom_spd_dict.values())\n    number_orbitals = [len(i) for i in orbital_symbols]\n    atom_indices = np.repeat(atom_indices, number_orbitals)\n    orbital_symbols_long = np.hstack(\n        [[o for o in orb] for orb in orbital_symbols]\n    )\n    orbital_indices = np.hstack(\n        [[self.spd_relations[o] for o in orb] for orb in orbital_symbols]\n    )\n    indices = np.vstack([atom_indices, orbital_indices]).T\n\n    projected_data = self._sum_atoms(atoms=atom_indices, spd=True)\n\n    if (\n        self.spin == \"both\"\n        and self.combination_method == \"sub\"\n        and self.sp_method == \"percentage\"\n    ):\n        projected_data_up = np.transpose(\n            np.array(\n                [projected_data[0, :, ind[0], ind[1]] for ind in indices]\n            ),\n            axes=(1, 0),\n        )\n        projected_data_down = np.transpose(\n            np.array(\n                [projected_data[1, :, ind[0], ind[1]] for ind in indices]\n            ),\n            axes=(1, 0),\n        )\n        projected_data = np.array([projected_data_up, projected_data_down])\n    else:\n        projected_data = np.transpose(\n            np.array(\n                [projected_data[:, ind[0], ind[1]] for ind in indices]\n            ),\n            axes=(1, 0),\n        )\n\n    if color_list is None:\n        colors = np.array(\n            [self.color_dict[i] for i in range(len(orbital_symbols_long))]\n        )\n    else:\n        colors = color_list\n\n    self._plot_projected_general(\n        ax=ax,\n        energy=self.tdos_array[:, 0],\n        projected_data=projected_data,\n        colors=colors,\n        sigma=sigma,\n        erange=erange,\n        linewidth=linewidth,\n        alpha_line=alpha_line,\n        alpha=alpha,\n        fill=fill,\n        energyaxis=energyaxis,\n        total=total,\n    )\n\n    if legend:\n        self._add_legend(\n            ax,\n            names=[\n                f\"{i[0]}({i[1]})\"\n                for i in zip(atom_indices, orbital_symbols_long)\n            ],\n            colors=colors,\n        )\n</code></pre>"},{"location":"dos/#vaspvis.dos.Dos.plot_atoms","title":"<code>plot_atoms(ax, atoms, fill=True, alpha=0.3, alpha_line=1.0, linewidth=1.5, sigma=0.05, energyaxis='y', color_list=None, legend=True, total=True, erange=[-6, 6], sum_atoms=False)</code>","text":"<p>This function plots the total density of states with the projected density of states on the given atoms.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>axis</code> <p>Axis to plot on</p> required <code>atoms</code> <code>list</code> <p>Index of atoms to plot</p> required <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>alpha_line</code> <code>float</code> <p>Alpha value for the line</p> <code>1.0</code> <code>color_list</code> <code>list</code> <p>Optional list of colors of the same length as the atoms list.</p> <code>None</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'y'</code> <code>legend</code> <code>bool</code> <p>Determines whether to draw the legend or not</p> <code>True</code> <code>total</code> <code>bool</code> <p>Determines wheth to draw the total density of states or not</p> <code>True</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> Source code in <code>vaspvis/dos.py</code> <pre><code>def plot_atoms(\n    self,\n    ax,\n    atoms,\n    fill=True,\n    alpha=0.3,\n    alpha_line=1.0,\n    linewidth=1.5,\n    sigma=0.05,\n    energyaxis=\"y\",\n    color_list=None,\n    legend=True,\n    total=True,\n    erange=[-6, 6],\n    sum_atoms=False,\n):\n    \"\"\"\n    This function plots the total density of states with the projected density of states on the given atoms.\n\n    Parameters:\n        ax (matplotlib.pyplot.axis): Axis to plot on\n        atoms (list): Index of atoms to plot\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        alpha_line (float): Alpha value for the line\n        color_list (list): Optional list of colors of the same length as the atoms list.\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        legend (bool): Determines whether to draw the legend or not\n        total (bool): Determines wheth to draw the total density of states or not\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n    \"\"\"\n\n    if color_list is None:\n        colors = np.array([self.color_dict[i] for i in range(len(atoms))])\n    else:\n        colors = color_list\n\n    projected_data = self._sum_atoms(atoms=atoms)\n\n    #  if sum_atoms:\n    #  if self.spin == 'both' and self.combination_method == 'sub' and self.sp_method == 'percentage':\n    #  projected_data_up = np.sum(projected_data[0], axis=1).reshape(-1,1)\n    #  projected_data_up = np.sum(projected_data[1], axis=1).reshape(-1,1)\n    #  colors = [colors[0]]\n    #  else:\n    #  projected_data = np.sum(projected_data, axis=1).reshape(-1,1)\n    #  colors = [colors[0]]\n\n    self._plot_projected_general(\n        ax=ax,\n        energy=self.tdos_array[:, 0],\n        projected_data=projected_data,\n        colors=colors,\n        sigma=sigma,\n        erange=erange,\n        linewidth=linewidth,\n        alpha_line=alpha_line,\n        alpha=alpha,\n        fill=fill,\n        energyaxis=energyaxis,\n        total=total,\n    )\n\n    if legend:\n        self._add_legend(ax, names=atoms, colors=colors)\n</code></pre>"},{"location":"dos/#vaspvis.dos.Dos.plot_element_orbitals","title":"<code>plot_element_orbitals(ax, element_orbital_dict, fill=True, alpha=0.3, alpha_line=1.0, linewidth=1.5, sigma=0.05, energyaxis='y', color_list=None, legend=True, total=True, erange=[-6, 6])</code>","text":"<p>This function plots the total density of states with the projected density of states onto the chosen orbitals of specified elements. This is useful for supercells where there are many atoms of the same element and it is inconvienient to manually list each index in the POSCAR.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>axis</code> <p>Axis to plot on</p> required <code>element_orbital_pairs</code> <code>list[list]</code> <p>List of element orbital pairs in the form of [[element symbol, orbital index], [element symbol, orbital index], ..]</p> required <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>alpha_line</code> <code>float</code> <p>Alpha value for the line</p> <code>1.0</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'y'</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the element orbitals list</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines whether to draw the legend or not</p> <code>True</code> <code>total</code> <code>bool</code> <p>Determines wheth to draw the total density of states or not</p> <code>True</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> Source code in <code>vaspvis/dos.py</code> <pre><code>def plot_element_orbitals(\n    self,\n    ax,\n    element_orbital_dict,\n    fill=True,\n    alpha=0.3,\n    alpha_line=1.0,\n    linewidth=1.5,\n    sigma=0.05,\n    energyaxis=\"y\",\n    color_list=None,\n    legend=True,\n    total=True,\n    erange=[-6, 6],\n):\n    \"\"\"\n    This function plots the total density of states with the projected\n    density of states onto the chosen orbitals of specified elements. This is\n    useful for supercells where there are many atoms of the same element and\n    it is inconvienient to manually list each index in the POSCAR.\n\n    Parameters:\n        ax (matplotlib.pyplot.axis): Axis to plot on\n        element_orbital_pairs (list[list]): List of element orbital pairs in the form of\n            [[element symbol, orbital index], [element symbol, orbital index], ..]\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        alpha_line (float): Alpha value for the line\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color_list (list): List of colors that is the same length as the element orbitals list\n        legend (bool): Determines whether to draw the legend or not\n        total (bool): Determines wheth to draw the total density of states or not\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n    \"\"\"\n\n    element_symbols = list(element_orbital_dict.keys())\n    orbital_indices = list(element_orbital_dict.values())\n    number_orbitals = [len(i) for i in orbital_indices]\n    element_symbols_long = np.repeat(element_symbols, number_orbitals)\n    element_indices = np.repeat(\n        range(len(element_symbols)), number_orbitals\n    )\n    orbital_symbols_long = np.hstack(\n        [[self.orbital_labels[o] for o in orb] for orb in orbital_indices]\n    )\n    orbital_indices_long = np.hstack(orbital_indices)\n    indices = np.vstack([element_indices, orbital_indices_long]).T\n\n    projected_data = self._sum_elements(\n        elements=element_symbols, orbitals=True\n    )\n\n    if (\n        self.spin == \"both\"\n        and self.combination_method == \"sub\"\n        and self.sp_method == \"percentage\"\n    ):\n        projected_data_up = np.transpose(\n            np.array(\n                [projected_data[0, :, ind[0], ind[1]] for ind in indices]\n            ),\n            axes=(1, 0),\n        )\n        projected_data_down = np.transpose(\n            np.array(\n                [projected_data[1, :, ind[0], ind[1]] for ind in indices]\n            ),\n            axes=(1, 0),\n        )\n        projected_data = np.array([projected_data_up, projected_data_down])\n    else:\n        projected_data = np.transpose(\n            np.array(\n                [projected_data[:, ind[0], ind[1]] for ind in indices]\n            ),\n            axes=(1, 0),\n        )\n\n    if color_list is None:\n        colors = np.array(\n            [self.color_dict[i] for i in range(len(orbital_indices_long))]\n        )\n    else:\n        colors = color_list\n\n    self._plot_projected_general(\n        ax=ax,\n        energy=self.tdos_array[:, 0],\n        projected_data=projected_data,\n        colors=colors,\n        sigma=sigma,\n        erange=erange,\n        linewidth=linewidth,\n        alpha_line=alpha_line,\n        alpha=alpha,\n        fill=fill,\n        energyaxis=energyaxis,\n        total=total,\n    )\n\n    if legend:\n        self._add_legend(\n            ax,\n            names=[\n                f\"{i[0]}({i[1]})\"\n                for i in zip(element_symbols_long, orbital_symbols_long)\n            ],\n            colors=colors,\n        )\n</code></pre>"},{"location":"dos/#vaspvis.dos.Dos.plot_element_spd","title":"<code>plot_element_spd(ax, element_spd_dict, fill=True, alpha=0.3, alpha_line=1.0, linewidth=1.5, sigma=0.05, energyaxis='y', color_list=None, legend=True, total=True, erange=[-6, 6])</code>","text":"<p>This function plots the total density of states with the projected density of states onto the s, p, and d orbitals of specified elements. This is useful for supercells where there are many atoms of the same element and it is inconvienient to manually list each index in the POSCAR.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>axis</code> <p>Axis to plot on</p> required <code>elements</code> <code>list</code> <p>List of element symbols to project onto</p> required <code>order</code> <code>list</code> <p>Order to plot the projected bands in. This feature helps to avoid situations where one projection completely convers the other.</p> required <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>alpha_line</code> <code>float</code> <p>Alpha value for the line</p> <code>1.0</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'y'</code> <code>color_dict</code> <code>dict[str][str]</code> <p>This option allow the colors of each element specified. Should be in the form of: {'element index': , 'element index': , ...} required <code>legend</code> <code>bool</code> <p>Determines whether to draw the legend or not</p> <code>True</code> <code>total</code> <code>bool</code> <p>Determines wheth to draw the total density of states or not</p> <code>True</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> Source code in <code>vaspvis/dos.py</code> <pre><code>def plot_element_spd(\n    self,\n    ax,\n    element_spd_dict,\n    fill=True,\n    alpha=0.3,\n    alpha_line=1.0,\n    linewidth=1.5,\n    sigma=0.05,\n    energyaxis=\"y\",\n    color_list=None,\n    legend=True,\n    total=True,\n    erange=[-6, 6],\n):\n    \"\"\"\n    This function plots the total density of states with the projected\n    density of states onto the s, p, and d orbitals of specified elements.\n    This is useful for supercells where there are many atoms of the same\n    element and it is inconvienient to manually list each index in the POSCAR.\n\n    Parameters:\n        ax (matplotlib.pyplot.axis): Axis to plot on\n        elements (list): List of element symbols to project onto\n        order (list): Order to plot the projected bands in. This feature helps to\n            avoid situations where one projection completely convers the other.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        alpha_line (float): Alpha value for the line\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color_dict (dict[str][str]): This option allow the colors of each element\n            specified. Should be in the form of:\n            {'element index': &lt;color&gt;, 'element index': &lt;color&gt;, ...}\n        legend (bool): Determines whether to draw the legend or not\n        total (bool): Determines wheth to draw the total density of states or not\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n    \"\"\"\n    element_symbols = list(element_spd_dict.keys())\n    orbital_symbols = list(element_spd_dict.values())\n    number_orbitals = [len(i) for i in orbital_symbols]\n    element_symbols_long = np.repeat(element_symbols, number_orbitals)\n    element_indices = np.repeat(\n        range(len(element_symbols)), number_orbitals\n    )\n    orbital_symbols_long = np.hstack(\n        [[o for o in orb] for orb in orbital_symbols]\n    )\n    orbital_indices = np.hstack(\n        [[self.spd_relations[o] for o in orb] for orb in orbital_symbols]\n    )\n    indices = np.vstack([element_indices, orbital_indices]).T\n\n    projected_data = self._sum_elements(elements=element_symbols, spd=True)\n\n    if (\n        self.spin == \"both\"\n        and self.combination_method == \"sub\"\n        and self.sp_method == \"percentage\"\n    ):\n        projected_data_up = np.transpose(\n            np.array(\n                [projected_data[0, :, ind[0], ind[1]] for ind in indices]\n            ),\n            axes=(1, 0),\n        )\n        projected_data_down = np.transpose(\n            np.array(\n                [projected_data[1, :, ind[0], ind[1]] for ind in indices]\n            ),\n            axes=(1, 0),\n        )\n        projected_data = np.array([projected_data_up, projected_data_down])\n    else:\n        projected_data = np.transpose(\n            np.array(\n                [projected_data[:, ind[0], ind[1]] for ind in indices]\n            ),\n            axes=(1, 0),\n        )\n\n    if color_list is None:\n        colors = np.array(\n            [self.color_dict[i] for i in range(len(orbital_symbols_long))]\n        )\n    else:\n        colors = color_list\n\n    self._plot_projected_general(\n        ax=ax,\n        energy=self.tdos_array[:, 0],\n        projected_data=projected_data,\n        colors=colors,\n        sigma=sigma,\n        erange=erange,\n        linewidth=linewidth,\n        alpha_line=alpha_line,\n        alpha=alpha,\n        fill=fill,\n        energyaxis=energyaxis,\n        total=total,\n    )\n\n    if legend:\n        self._add_legend(\n            ax,\n            names=[\n                f\"{i[0]}({i[1]})\"\n                for i in zip(element_symbols_long, orbital_symbols_long)\n            ],\n            colors=colors,\n        )\n</code></pre>"},{"location":"dos/#vaspvis.dos.Dos.plot_elements","title":"<code>plot_elements(ax, elements, fill=True, alpha=0.3, alpha_line=1.0, linewidth=1.5, sigma=0.05, energyaxis='y', color_list=None, legend=True, total=True, erange=[-6, 6])</code>","text":"<p>This function plots the total density of states with the projected density of states for the projection onto specified elements. This is useful for supercells where there are many atoms of the same element and it is inconvienient to manually list each index in the POSCAR.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>axis</code> <p>Axis to plot on</p> required <code>elements</code> <code>list</code> <p>List of element symbols to project onto</p> required <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>alpha_line</code> <code>float</code> <p>Alpha value for the line</p> <code>1.0</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'y'</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length at the elements list</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines whether to draw the legend or not</p> <code>True</code> <code>total</code> <code>bool</code> <p>Determines wheth to draw the total density of states or not</p> <code>True</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> Source code in <code>vaspvis/dos.py</code> <pre><code>def plot_elements(\n    self,\n    ax,\n    elements,\n    fill=True,\n    alpha=0.3,\n    alpha_line=1.0,\n    linewidth=1.5,\n    sigma=0.05,\n    energyaxis=\"y\",\n    color_list=None,\n    legend=True,\n    total=True,\n    erange=[-6, 6],\n):\n    \"\"\"\n    This function plots the total density of states with the projected\n    density of states for the projection onto specified elements. This is\n    useful for supercells where there are many atoms of the same element and\n    it is inconvienient to manually list each index in the POSCAR.\n\n    Parameters:\n        ax (matplotlib.pyplot.axis): Axis to plot on\n        elements (list): List of element symbols to project onto\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        alpha_line (float): Alpha value for the line\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color_list (list): List of colors that is the same length at the elements list\n        legend (bool): Determines whether to draw the legend or not\n        total (bool): Determines wheth to draw the total density of states or not\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n    \"\"\"\n\n    if color_list is None:\n        colors = np.array(\n            [self.color_dict[i] for i in range(len(elements))]\n        )\n    else:\n        colors = color_list\n\n    projected_data = self._sum_elements(elements=elements)\n\n    self._plot_projected_general(\n        ax=ax,\n        energy=self.tdos_array[:, 0],\n        projected_data=projected_data,\n        colors=colors,\n        sigma=sigma,\n        erange=erange,\n        linewidth=linewidth,\n        alpha_line=alpha_line,\n        alpha=alpha,\n        fill=fill,\n        energyaxis=energyaxis,\n        total=total,\n    )\n\n    if legend:\n        self._add_legend(ax, names=elements, colors=colors)\n</code></pre>"},{"location":"dos/#vaspvis.dos.Dos.plot_layers","title":"<code>plot_layers(ax, cmap='magma', sigma_energy=0.05, sigma_layers=0.75, energyaxis='y', erange=[-6, 6], lrange=None, antialiased=False, fontsize=6, interface_layer=None, show_interface_line=False, interface_line_color='white', interface_line_width=2, interface_line_style='--', log_scale=False, contour=False, levels=10, min_cutoff=1e-07, max_cutoff=None, atol=None, custom_layer_inds=None, custom_cbar_label=None, cbar_orientation='vertical', show_bounds=False, set_bounds=None)</code>","text":"<p>This function plots a layer by layer heat map of the density of states.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>axis</code> <p>Axis to plot on</p> required <code>cmap</code> <code>str</code> <p>Color map to use in the heat map</p> <code>'magma'</code> <code>sigma_energy</code> <code>float</code> <p>Variance for a gaussian blur with respect to the energy This will help smooth out spikey looking density of states</p> <code>0.05</code> <code>sigma_layers</code> <code>float</code> <p>Variance for a gaussian blur with respect to the layers This will help smooth out the the pixelation that can occur between the summed dos with respect to the layers.</p> <code>0.75</code> <code>energyaxis</code> <code>str</code> <p>Axis to plot the energy on. ('x' or 'y')</p> <code>'y'</code> <code>erange</code> <code>list</code> <p>Upper and lower energy bounds for the plot.</p> <code>[-6, 6]</code> <code>lrange</code> <code>list</code> <p>Upper and lower bounds of the layers included in the plot.</p> <code>None</code> <code>antialiased</code> <code>bool</code> <p>Determines if antialiasing is used or not.</p> <code>False</code> <code>fontsize</code> <code>float</code> <p>Fontsize of all the text in the group.</p> <code>6</code> <code>interface_layer</code> <code>float or None</code> <p>If a value is provided, then the axis labels will be shifted accordingly so that the defined interface layer is zero.</p> <code>None</code> <code>show_interface_line</code> <code>bool</code> <p>If True, then a line will be drawn on the plot to identify the interface layer defined by interface_layer.</p> <code>False</code> <code>interface_line_color</code> <code>str</code> <p>Color of the line drawn on the plot to mark the interface.</p> <code>'white'</code> <code>interface_line_width</code> <code>float</code> <p>Line with of the line marking the interface.</p> <code>2</code> <code>interface_line_style</code> <code>str</code> <p>Style of the line marking the interface.</p> <code>'--'</code> <code>log_scale</code> <code>bool</code> <p>Determines if the color map is applied in log scale of not. Recommended in order to accurately view the band gap and smaller features.</p> <code>False</code> <code>contour</code> <code>bool</code> <p>Determines if the color map is plotted as a contour plot instead of a heatmap.</p> <code>False</code> <code>levels</code> <code>int</code> <p>Number of levels used in the contour plot.</p> <code>10</code> <code>min_cutoff</code> <code>float</code> <p>Minimum dos value used to determine the cut off for the plot. This can be adjusted to better visualize the band gap of the material.</p> <code>1e-07</code> <code>atol</code> <code>float or None</code> <p>Tolarence used in the grouping of the layers. This value is automatically calculated if None and is usually on the order of 1e-3.</p> <code>None</code> <code>custom_layer_inds</code> <code>list or None</code> <p>If the structure being calculated has relaxed atomic positions, sometimes the layer grouping algorithm can behave non-idealy. If this is the case, the user can input a list of list that contain the atomic indices in each layers of the material.</p> <code>None</code> <code>custom_cbar_label</code> <code>str or None</code> <p>Custom label for the colorbar</p> <code>None</code> Source code in <code>vaspvis/dos.py</code> <pre><code>def plot_layers(\n    self,\n    ax,\n    cmap=\"magma\",\n    sigma_energy=0.05,\n    sigma_layers=0.75,\n    energyaxis=\"y\",\n    erange=[-6, 6],\n    lrange=None,\n    antialiased=False,\n    fontsize=6,\n    interface_layer=None,\n    show_interface_line=False,\n    interface_line_color=\"white\",\n    interface_line_width=2,\n    interface_line_style=\"--\",\n    log_scale=False,\n    contour=False,\n    levels=10,\n    min_cutoff=1e-7,\n    max_cutoff=None,\n    atol=None,\n    custom_layer_inds=None,\n    custom_cbar_label=None,\n    cbar_orientation=\"vertical\",\n    show_bounds=False,\n    set_bounds=None,\n):\n    \"\"\"\n    This function plots a layer by layer heat map of the density\n    of states.\n\n    Parameters:\n        ax (matplotlib.pyplot.axis): Axis to plot on\n        cmap (str): Color map to use in the heat map\n        sigma_energy (float): Variance for a gaussian blur with respect to the energy\n            This will help smooth out spikey looking density of states\n        sigma_layers (float): Variance for a gaussian blur with respect to the layers\n            This will help smooth out the the pixelation that can occur between the summed\n            dos with respect to the layers.\n        energyaxis (str): Axis to plot the energy on. ('x' or 'y')\n        erange (list): Upper and lower energy bounds for the plot.\n        lrange (list): Upper and lower bounds of the layers included in the plot.\n        antialiased (bool): Determines if antialiasing is used or not.\n        fontsize (float): Fontsize of all the text in the group.\n        interface_layer (float or None): If a value is provided, then the axis labels will be\n            shifted accordingly so that the defined interface layer is zero.\n        show_interface_line (bool): If True, then a line will be drawn\n            on the plot to identify the interface layer defined by interface_layer.\n        interface_line_color (str): Color of the line drawn on the plot to mark the\n            interface.\n        interface_line_width (float): Line with of the line marking the interface.\n        interface_line_style (str): Style of the line marking the interface.\n        log_scale (bool): Determines if the color map is applied in log scale of not.\n            Recommended in order to accurately view the band gap and smaller features.\n        contour (bool): Determines if the color map is plotted as a contour plot instead\n            of a heatmap.\n        levels (int): Number of levels used in the contour plot.\n        min_cutoff (float): Minimum dos value used to determine the cut off for the plot.\n            This can be adjusted to better visualize the band gap of the material.\n        atol (float or None): Tolarence used in the grouping of the layers.\n            This value is automatically calculated if None and is usually on the order of\n            1e-3.\n        custom_layer_inds (list or None): If the structure being calculated has relaxed\n            atomic positions, sometimes the layer grouping algorithm can behave non-idealy.\n            If this is the case, the user can input a list of list that contain the\n            atomic indices in each layers of the material.\n        custom_cbar_label (str or None): Custom label for the colorbar\n    \"\"\"\n    from vaspvis.utils import group_layers\n    import matplotlib.colors as colors\n\n    energy = self.tdos_array[:, 0]\n\n    ind = np.where(\n        (erange[0] - 0.1 &lt;= energy) &amp; (energy &lt;= erange[-1] + 0.1)\n    )\n    if custom_layer_inds is None:\n        groups, _ = group_layers(self.poscar.structure, atol=atol)\n    else:\n        groups = custom_layer_inds\n\n    atom_index = range(len(groups))\n    energies = energy[ind]\n\n    atom_densities = self._sum_atoms(atoms=None)\n\n    if (\n        self.spin == \"both\"\n        and self.combination_method == \"sub\"\n        and self.sp_method == \"percentage\"\n    ):\n        atom_densities_up = atom_densities[0, ind].squeeze()\n        atom_densities_down = atom_densities[1, ind].squeeze()\n        densities_up = np.vstack(\n            [\n                np.sum(np.vstack(atom_densities_up[:, [group]]), axis=1)\n                for group in groups\n            ]\n        )\n        densities_down = np.vstack(\n            [\n                np.sum(np.vstack(atom_densities_down[:, [group]]), axis=1)\n                for group in groups\n            ]\n        )\n        densities = (densities_up - densities_down) / (\n            densities_up + densities_down\n        )\n        densities[np.isnan(densities)] = 1e-9\n    else:\n        atom_densities = atom_densities[ind]\n        densities = np.vstack(\n            [\n                np.sum(np.vstack(atom_densities[:, [group]]), axis=1)\n                for group in groups\n            ]\n        )\n\n    densities = np.transpose(densities)\n\n    if lrange is not None:\n        atom_index = atom_index[lrange[0] : lrange[1] + 1]\n        densities = densities[:, lrange[0] : lrange[1] + 1]\n\n    if sigma_energy &gt; 0:\n        for i in range(densities.shape[-1]):\n            densities[:, i] = self._smear(\n                densities[:, i],\n                sigma=sigma_energy,\n            )\n    if sigma_layers &gt; 0:\n        densities = gaussian_filter(densities, sigma=sigma_layers)\n\n    f = interp2d(atom_index, energies, densities, kind=\"cubic\")\n    atom_index = np.arange(np.min(atom_index), np.max(atom_index), 0.1)\n    densities = f(atom_index, energies)\n\n    if log_scale:\n        if np.min(densities) &lt;= 0:\n            neg_zero_loc = np.where(densities &lt;= 0)\n            pos_loc = np.where(densities &gt; 0)\n            min_val = np.min(densities[pos_loc])\n            if min_val &lt; min_cutoff:\n                min_val = min_cutoff\n                too_small_loc = np.where(densities &lt; min_cutoff)\n                densities[too_small_loc] = min_cutoff\n            else:\n                densities[neg_zero_loc] = min_val\n        else:\n            min_val = np.min(densities)\n            if min_val &lt; min_cutoff:\n                min_val = min_cutoff\n\n        if max_cutoff is not None:\n            max_val = max_cutoff\n        else:\n            max_val = np.max(densities)\n\n        norm = colors.LogNorm(vmin=min_val, vmax=max_val)\n    else:\n        if self.combination_method == \"sub\" and self.spin == \"both\":\n            if set_bounds is None:\n                norm_val = np.max(\n                    np.abs([np.min(densities), np.max(densities)])\n                )\n            else:\n                norm_val = set_bounds\n\n            norm = colors.Normalize(vmin=-norm_val, vmax=norm_val)\n        else:\n            if max_cutoff is not None:\n                max_val = max_cutoff\n            else:\n                max_val = np.max(densities)\n\n            if min_cutoff is not None:\n                min_val = min_cutoff\n            else:\n                min_val = np.min(densities)\n\n            norm = colors.Normalize(vmin=min_val, vmax=max_val)\n\n    if log_scale:\n        lev_exp = np.arange(\n            np.floor(np.log10(densities.min()) - 1),\n            np.ceil(np.log10(densities.max()) + 1),\n        )\n        if len(lev_exp) &gt;= levels:\n            pass\n        else:\n            if int(levels / len(lev_exp)) &gt;= 3:\n                lev_exp = np.arange(\n                    np.floor(np.log10(densities.min()) - 1),\n                    np.ceil(np.log10(densities.max()) + 1),\n                    0.25,\n                )\n            else:\n                lev_exp = np.arange(\n                    np.floor(np.log10(densities.min()) - 1),\n                    np.ceil(np.log10(densities.max()) + 1),\n                    0.5,\n                )\n        levels = np.power(10, lev_exp)\n\n    if interface_layer is not None:\n        atom_index -= int(interface_layer)\n\n    if energyaxis == \"y\":\n\n        if contour:\n            im = ax.contourf(\n                atom_index,\n                energies,\n                densities,\n                cmap=cmap,\n                levels=levels,\n                norm=norm,\n            )\n        else:\n            im = ax.pcolormesh(\n                atom_index,\n                energies,\n                densities,\n                cmap=cmap,\n                shading=\"gouraud\",\n                norm=norm,\n                antialiased=antialiased,\n            )\n        ax.xaxis.set_major_locator(MaxNLocator(integer=True))\n\n        if interface_layer is not None and show_interface_line:\n            ax.axvline(\n                x=0,\n                color=interface_line_color,\n                linestyle=interface_line_style,\n                linewidth=interface_line_width,\n            )\n\n    if energyaxis == \"x\":\n        if contour:\n            im = ax.contourf(\n                energies,\n                atom_index,\n                densities,\n                cmap=cmap,\n                levels=levels,\n                norm=norm,\n            )\n        else:\n            im = ax.pcolormesh(\n                energies,\n                atom_index,\n                np.transpose(densities),\n                cmap=cmap,\n                shading=\"gouraud\",\n                norm=norm,\n                antialiased=antialiased,\n            )\n        ax.yaxis.set_major_locator(MaxNLocator(integer=True))\n\n        if interface_layer is not None and show_interface_line:\n            ax.axhline(\n                y=0,\n                color=interface_line_color,\n                linestyle=interface_line_style,\n                linewidth=interface_line_width,\n            )\n\n    fig = plt.gcf()\n    cbar = fig.colorbar(im, ax=ax, orientation=cbar_orientation)\n    cbar.ax.tick_params(labelsize=fontsize)\n    if custom_cbar_label is None:\n        if self.combination_method == \"sub\" and self.spin == \"both\":\n            cbar.set_label(\"Spin Polarization\", fontsize=fontsize)\n            min_val = im.norm.vmin\n            max_val = im.norm.vmax\n            cbar.set_ticks([min_val, max_val])\n            if not show_bounds:\n                cbar.set_ticklabels([\"Down\", \"Up\"])\n        else:\n            cbar.set_label(\"Density of States\", fontsize=fontsize)\n    else:\n        cbar.set_label(custom_cbar_label, fontsize=fontsize)\n</code></pre>"},{"location":"dos/#vaspvis.dos.Dos.plot_ldos","title":"<code>plot_ldos(ax, layers, linewidth=1.5, fill=False, alpha=0.3, alpha_line=1.0, sigma=0.05, energyaxis='x', color='black', log_scale=False, erange=[-6, 6], atol=None, custom_layer_inds=None, linestyle='-')</code>","text":"<p>This function plots the total density of states</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>axis</code> <p>Axis to append the tick labels</p> required <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>False</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>alpha_line</code> <code>float</code> <p>Alpha value for the line</p> <code>1.0</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'x'</code> <code>color</code> <code>str</code> <p>Color of line</p> <code>'black'</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> Source code in <code>vaspvis/dos.py</code> <pre><code>def plot_ldos(\n    self,\n    ax,\n    layers,\n    linewidth=1.5,\n    fill=False,\n    alpha=0.3,\n    alpha_line=1.0,\n    sigma=0.05,\n    energyaxis=\"x\",\n    color=\"black\",\n    log_scale=False,\n    erange=[-6, 6],\n    atol=None,\n    custom_layer_inds=None,\n    linestyle=\"-\",\n):\n    \"\"\"\n    This function plots the total density of states\n\n    Parameters:\n        ax (matplotlib.pyplot.axis): Axis to append the tick labels\n        linewidth (float): Linewidth of lines\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        alpha_line (float): Alpha value for the line\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color (str): Color of line\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n    \"\"\"\n\n    #  tdos_array = self._sum_layers(layers=layers)\n    tdos_array = self.tdos_array\n\n    tdensity = self._sum_layers(\n        layers=layers, atol=atol, custom_layer_inds=custom_layer_inds\n    )\n\n    if (\n        self.spin == \"both\"\n        and self.combination_method == \"sub\"\n        and self.sp_method == \"percentage\"\n    ):\n        tdensity = (tdensity[0] - tdensity[1]) / (\n            tdensity[0] + tdensity[1]\n        )\n        tdensity[np.isnan(tdensity)] = 1e-9\n\n    if sigma &gt; 0:\n        tdensity = self._smear(tdensity, sigma=sigma)\n\n    if log_scale:\n        tdensity = np.log10(tdensity)\n        neg_inf_loc = np.isin(tdensity, -np.inf)\n        min_val = np.min(tdensity[np.logical_not(neg_inf_loc)])\n        tdensity[neg_inf_loc] = min_val\n\n    self._set_density_lims(\n        ax=ax,\n        tdensity=tdensity,\n        tenergy=tdos_array[:, 0],\n        erange=erange,\n        energyaxis=energyaxis,\n        spin=self.spin,\n        log_scale=log_scale,\n    )\n\n    if energyaxis == \"y\":\n        ax.plot(\n            tdensity,\n            tdos_array[:, 0],\n            linewidth=linewidth,\n            color=color,\n            alpha=alpha_line,\n            linestyle=linestyle,\n        )\n\n        if fill:\n            ax.fill_betweenx(\n                tdos_array[:, 0],\n                tdensity,\n                0,\n                alpha=alpha,\n                color=color,\n            )\n\n    if energyaxis == \"x\":\n        ax.plot(\n            tdos_array[:, 0],\n            tdensity,\n            linewidth=linewidth,\n            color=color,\n            alpha=alpha_line,\n            linestyle=linestyle,\n        )\n\n        if fill:\n            ax.fill_between(\n                tdos_array[:, 0],\n                tdensity,\n                0,\n                color=color,\n                alpha=alpha,\n            )\n</code></pre>"},{"location":"dos/#vaspvis.dos.Dos.plot_orbitals","title":"<code>plot_orbitals(ax, orbitals, fill=True, alpha=0.3, alpha_line=1.0, linewidth=1.5, sigma=0.05, energyaxis='y', color_list=None, legend=True, total=True, erange=[-6, 6])</code>","text":"<p>This function plots the total density of states with the projected density of states for the projections onto given orbitals</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>axis</code> <p>Axis to plot on</p> required <code>orbitals</code> <code>list</code> <p>List of orbitals to project onto</p> required <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>alpha_line</code> <code>float</code> <p>Alpha value for the line</p> <code>1.0</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'y'</code> <code>color_dict</code> <code>dict[str][str]</code> <p>This option allow the colors of each orbital specified. Should be in the form of: {'orbital index': , 'orbital index': , ...} required <code>legend</code> <code>bool</code> <p>Determines whether to draw the legend or not</p> <code>True</code> <code>total</code> <code>bool</code> <p>Determines wheth to draw the total density of states or not</p> <code>True</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> Source code in <code>vaspvis/dos.py</code> <pre><code>def plot_orbitals(\n    self,\n    ax,\n    orbitals,\n    fill=True,\n    alpha=0.3,\n    alpha_line=1.0,\n    linewidth=1.5,\n    sigma=0.05,\n    energyaxis=\"y\",\n    color_list=None,\n    legend=True,\n    total=True,\n    erange=[-6, 6],\n):\n    \"\"\"\n    This function plots the total density of states with the projected\n    density of states for the projections onto given orbitals\n\n    Parameters:\n        ax (matplotlib.pyplot.axis): Axis to plot on\n        orbitals (list): List of orbitals to project onto\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        alpha_line (float): Alpha value for the line\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color_dict (dict[str][str]): This option allow the colors of each orbital\n            specified. Should be in the form of:\n            {'orbital index': &lt;color&gt;, 'orbital index': &lt;color&gt;, ...}\n        legend (bool): Determines whether to draw the legend or not\n        total (bool): Determines wheth to draw the total density of states or not\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n    \"\"\"\n    if color_list is None:\n        colors = np.array([self.color_dict[i] for i in orbitals])\n    else:\n        colors = color_list\n\n    projected_data = self._sum_orbitals(orbitals=orbitals)\n\n    self._plot_projected_general(\n        ax=ax,\n        energy=self.tdos_array[:, 0],\n        projected_data=projected_data,\n        colors=colors,\n        sigma=sigma,\n        erange=erange,\n        linewidth=linewidth,\n        alpha_line=alpha_line,\n        alpha=alpha,\n        fill=fill,\n        energyaxis=energyaxis,\n        total=total,\n    )\n\n    if legend:\n        self._add_legend(\n            ax,\n            names=[self.orbital_labels[i] for i in orbitals],\n            colors=colors,\n        )\n</code></pre>"},{"location":"dos/#vaspvis.dos.Dos.plot_plain","title":"<code>plot_plain(ax, linewidth=1.5, fill=True, alpha=0.3, alpha_line=1.0, sigma=0.05, energyaxis='y', color='black', erange=[-6, 6], log_scale=False)</code>","text":"<p>This function plots the total density of states</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>axis</code> <p>Axis to append the tick labels</p> required <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>alpha_line</code> <code>float</code> <p>Alpha value for the line</p> <code>1.0</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'y'</code> <code>color</code> <code>str</code> <p>Color of line</p> <code>'black'</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> Source code in <code>vaspvis/dos.py</code> <pre><code>def plot_plain(\n    self,\n    ax,\n    linewidth=1.5,\n    fill=True,\n    alpha=0.3,\n    alpha_line=1.0,\n    sigma=0.05,\n    energyaxis=\"y\",\n    color=\"black\",\n    erange=[-6, 6],\n    log_scale=False,\n):\n    \"\"\"\n    This function plots the total density of states\n\n    Parameters:\n        ax (matplotlib.pyplot.axis): Axis to append the tick labels\n        linewidth (float): Linewidth of lines\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        alpha_line (float): Alpha value for the line\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color (str): Color of line\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n    \"\"\"\n\n    tdos_array = self.tdos_array\n    energy_in_plot_index = np.where(\n        (tdos_array[:, 0] &gt;= erange[0] - 0.5)\n        &amp; (tdos_array[:, 0] &lt;= erange[1] + 0.5)\n    )[0]\n    tdos_array = tdos_array[energy_in_plot_index]\n\n    if sigma &gt; 0:\n        tdensity = self._smear(tdos_array[:, 1], sigma=sigma)\n    else:\n        tdensity = tdos_array[:, 1]\n\n    if log_scale:\n        tdensity = np.log10(tdensity)\n        neg_inf_loc = np.isin(tdensity, -np.inf)\n        min_val = np.min(tdensity[np.logical_not(neg_inf_loc)])\n        tdensity[neg_inf_loc] = min_val\n\n    self._set_density_lims(\n        ax=ax,\n        tdensity=tdensity,\n        tenergy=tdos_array[:, 0],\n        erange=erange,\n        energyaxis=energyaxis,\n        spin=self.spin,\n        log_scale=log_scale,\n    )\n\n    if energyaxis == \"y\":\n        ax.plot(\n            tdensity,\n            tdos_array[:, 0],\n            linewidth=linewidth,\n            color=color,\n            alpha=alpha_line,\n        )\n\n        if fill:\n            ax.fill_betweenx(\n                tdos_array[:, 0],\n                tdensity,\n                0,\n                alpha=alpha,\n                color=color,\n            )\n\n    if energyaxis == \"x\":\n        ax.plot(\n            tdos_array[:, 0],\n            tdensity,\n            linewidth=linewidth,\n            color=color,\n            alpha=alpha_line,\n        )\n\n        if fill:\n            ax.fill_between(\n                tdos_array[:, 0],\n                tdensity,\n                0,\n                color=color,\n                alpha=alpha,\n            )\n</code></pre>"},{"location":"dos/#vaspvis.dos.Dos.plot_spd","title":"<code>plot_spd(ax, orbitals='spd', fill=True, alpha=0.3, alpha_line=1.0, linewidth=1.5, sigma=0.05, energyaxis='y', color_list=None, legend=True, total=True, erange=[-6, 6])</code>","text":"<p>This function plots the total density of states with the projected density of states for the total projections of the s, p, and d orbitals.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>axis</code> <p>Axis to plot on</p> required <code>order</code> <code>list</code> <p>Order to plot the projected bands in. This feature helps to avoid situations where one projection completely convers the other.</p> required <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>alpha_line</code> <code>float</code> <p>Alpha value for the line</p> <code>1.0</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'y'</code> <code>color_dict</code> <code>dict[str][str]</code> <p>This option allow the colors of the s, p, and d orbitals to be specified. Should be in the form of: {'s': , 'p': <p>, 'd': } required <code>legend</code> <code>bool</code> <p>Determines whether to draw the legend or not</p> <code>True</code> <code>total</code> <code>bool</code> <p>Determines wheth to draw the total density of states or not</p> <code>True</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> Source code in <code>vaspvis/dos.py</code> <pre><code>def plot_spd(\n    self,\n    ax,\n    orbitals=\"spd\",\n    fill=True,\n    alpha=0.3,\n    alpha_line=1.0,\n    linewidth=1.5,\n    sigma=0.05,\n    energyaxis=\"y\",\n    color_list=None,\n    legend=True,\n    total=True,\n    erange=[-6, 6],\n):\n    \"\"\"\n    This function plots the total density of states with the projected\n    density of states for the total projections of the s, p, and d orbitals.\n\n    Parameters:\n        ax (matplotlib.pyplot.axis): Axis to plot on\n        order (list): Order to plot the projected bands in. This feature helps to\n            avoid situations where one projection completely convers the other.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        alpha_line (float): Alpha value for the line\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color_dict (dict[str][str]): This option allow the colors of the s, p, and d\n            orbitals to be specified. Should be in the form of:\n            {'s': &lt;s color&gt;, 'p': &lt;p color&gt;, 'd': &lt;d color&gt;}\n        legend (bool): Determines whether to draw the legend or not\n        total (bool): Determines wheth to draw the total density of states or not\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n    \"\"\"\n\n    projected_data = self._sum_spd(spd=orbitals)\n\n    if color_list is None:\n        color_list = [\n            self.color_dict[0],\n            self.color_dict[1],\n            self.color_dict[2],\n            self.color_dict[4],\n        ]\n        colors = np.array([color_list[i] for i in range(len(orbitals))])\n    else:\n        colors = color_list\n\n    self._plot_projected_general(\n        ax=ax,\n        energy=self.tdos_array[:, 0],\n        projected_data=projected_data,\n        colors=colors,\n        sigma=sigma,\n        erange=erange,\n        linewidth=linewidth,\n        alpha_line=alpha_line,\n        alpha=alpha,\n        fill=fill,\n        energyaxis=energyaxis,\n        total=total,\n    )\n\n    if legend:\n        self._add_legend(ax, names=[i for i in orbitals], colors=colors)\n</code></pre>"},{"location":"standard/","title":"Standardized Plots","text":""},{"location":"standard/#standardpy","title":"standard.py","text":"<p>This module contains standardized plots as well as more complex plots, such as band structures and density of states put together, and spin projected plots.</p>"},{"location":"standard/#vaspvis.standard.band_atom_orbitals","title":"<code>band_atom_orbitals(folder, atom_orbital_dict, output='band_atom_orbitals.png', spin='up', display_order=None, scale_factor=5, color_list=None, legend=True, linewidth=0.75, band_color='black', figsize=(4, 3), erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, unfold=False, M=None, high_symm_points=None, fontsize=12, heatmap=False, bins=800, sigma=2, cmap='hot', vlinecolor='black', cbar=True, cbar_orientation='horizontal', powernorm=True, gamma=0.5, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None)</code>","text":"<p>This function generates a projected band structure on specific [atom, orbital] pairs.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>atom_orbital_dict</code> <code>dict[int</code> <p>list]): A dictionary that contains the individual atoms and the corresponding orbitals to project onto. For example, if the user wants to project onto the s, py, pz, and px orbitals of the first atom and the s orbital of the second atom then the dictionary would be {0:[0,1,2,3], 1:[0]}</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_atom_orbitals.png'</code> <code>spin</code> <code>str</code> <p>Choose which spin direction to parse. ('up' or 'down')</p> <code>'up'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot.</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background.</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure.</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches. (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot. [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_atom_orbitals(\n    folder,\n    atom_orbital_dict,\n    output=\"band_atom_orbitals.png\",\n    spin=\"up\",\n    display_order=None,\n    scale_factor=5,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    figsize=(4, 3),\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=12,\n    heatmap=False,\n    bins=800,\n    sigma=2,\n    cmap=\"hot\",\n    vlinecolor=\"black\",\n    cbar=True,\n    cbar_orientation=\"horizontal\",\n    powernorm=True,\n    gamma=0.5,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n):\n    \"\"\"\n    This function generates a projected band structure on specific [atom, orbital] pairs.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        atom_orbital_dict (dict[int:list]): A dictionary that contains the individual atoms and the corresponding\n            orbitals to project onto. For example, if the user wants to project onto the s, py, pz, and px orbitals\n            of the first atom and the s orbital of the second atom then the dictionary would be {0:[0,1,2,3], 1:[0]}\n        output (str): File name of the resulting plot.\n        spin (str): Choose which spin direction to parse. ('up' or 'down')\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot.\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background.\n        band_color (string): Color of the plain band structure.\n        figsize (list / tuple): Desired size of the image in inches. (width, height)\n        erange (list / tuple): Range of energy to show in the plot. [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    band = Band(\n        folder=folder,\n        spin=spin,\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    if heatmap:\n        legend = False\n        if cbar:\n            if cbar_orientation == \"horizontal\":\n                fig, (ax, cax) = plt.subplots(\n                    nrows=2,\n                    figsize=figsize,\n                    gridspec_kw={\"height_ratios\": [1, 0.05]},\n                    dpi=400,\n                    constrained_layout=True,\n                )\n            elif cbar_orientation == \"vertical\":\n                fig, (ax, cax) = plt.subplots(\n                    ncols=2,\n                    figsize=figsize,\n                    gridspec_kw={\"width_ratios\": [1, 0.05]},\n                    dpi=400,\n                    constrained_layout=True,\n                )\n            else:\n                raise (\n                    \"This is not a valid orientation please choose either horizontal or vertical\"\n                )\n        else:\n            fig = plt.figure(figsize=(figsize), dpi=400)\n            ax = fig.add_subplot(111)\n    else:\n        fig = plt.figure(figsize=(figsize), dpi=400)\n        ax = fig.add_subplot(111)\n\n    _figure_setup(ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]])\n    band.plot_atom_orbitals(\n        ax=ax,\n        atom_orbital_dict=atom_orbital_dict,\n        display_order=display_order,\n        scale_factor=scale_factor,\n        color_list=color_list,\n        legend=legend,\n        linewidth=linewidth,\n        band_color=band_color,\n        erange=erange,\n        heatmap=heatmap,\n        bins=bins,\n        sigma=sigma,\n        cmap=cmap,\n        vlinecolor=vlinecolor,\n        powernorm=powernorm,\n        gamma=gamma,\n    )\n\n    if heatmap:\n        if cbar:\n            im = ax.collections[0]\n            min_val = im.norm.vmin\n            max_val = im.norm.vmax\n            cbar = fig.colorbar(im, cax=cax, orientation=cbar_orientation)\n            cbar.set_ticks([min_val, max_val])\n            cbar.set_ticklabels([\"min\", \"max\"])\n\n    if heatmap:\n        if not cbar:\n            fig.tight_layout(pad=0.4)\n    else:\n        fig.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_atom_orbitals_spin_polarized","title":"<code>band_atom_orbitals_spin_polarized(folder, atom_orbital_dict, output='band_atom_orbitals_sp.png', display_order=None, scale_factor=5, color_list=None, legend=True, linewidth=0.75, band_color='black', unprojected_band_color='gray', unprojected_linewidth=0.6, fontsize=12, annotations=['$\\\\uparrow$ ', '$\\\\downarrow$ '], annotation_xy=(0.02, 0.98), figsize=(4, 3), erange=[-6, 6], stack='vertical', kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, unfold=False, M=None, high_symm_points=None, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None)</code>","text":"<p>This function generates an atom orbital spin polarized band structure. This will plot two plots stacked on top or eachother or next to eachother. The top or left plot will project on the spin up bands and the bottom or right plot will project onto the spin down bands.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>atom_orbital_dict</code> <code>dict[int</code> <p>list]): A dictionary that contains the individual atoms and the corresponding orbitals to project onto. For example, if the user wants to project onto the s, py, pz, and px orbitals of the first atom and the s orbital of the second atom then the dictionary would be {0:[0,1,2,3], 1:[0]}</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_atom_orbitals_sp.png'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot.</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>unprojected_band_color</code> <code>str</code> <p>Color of the unprojected band</p> <code>'gray'</code> <code>unprojected_linewidth</code> <code>float</code> <p>Line width of the unprojected bands</p> <code>0.6</code> <code>annotations</code> <code>list</code> <p>Annotations to put on the top and bottom (left and right) figures. By default it will show the spin up and spin down arrows.</p> <code>['$\\\\uparrow$ ', '$\\\\downarrow$ ']</code> <code>annotation_xy</code> <code>list / tuple</code> <p>Fractional (x, y) coordinated of the annotation location</p> <code>(0.02, 0.98)</code> <code>stack</code> <code>str</code> <p>Determines how the plots are stacked (vertical or horizontal)</p> <code>'vertical'</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background.</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure.</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches. (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot. [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing. (fig, ax1, ax2)</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_atom_orbitals_spin_polarized(\n    folder,\n    atom_orbital_dict,\n    output=\"band_atom_orbitals_sp.png\",\n    display_order=None,\n    scale_factor=5,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    unprojected_band_color=\"gray\",\n    unprojected_linewidth=0.6,\n    fontsize=12,\n    annotations=[\"$\\\\uparrow$ \", \"$\\\\downarrow$ \"],\n    annotation_xy=(0.02, 0.98),\n    figsize=(4, 3),\n    erange=[-6, 6],\n    stack=\"vertical\",\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n):\n    \"\"\"\n    This function generates an atom orbital spin polarized band structure. This will plot two plots\n    stacked on top or eachother or next to eachother. The top or left plot will project on the\n    spin up bands and the bottom or right plot will project onto the spin down bands.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        atom_orbital_dict (dict[int:list]): A dictionary that contains the individual atoms and the corresponding\n            orbitals to project onto. For example, if the user wants to project onto the s, py, pz, and px orbitals\n            of the first atom and the s orbital of the second atom then the dictionary would be {0:[0,1,2,3], 1:[0]}\n        output (str): File name of the resulting plot.\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot.\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        unprojected_band_color (str): Color of the unprojected band\n        unprojected_linewidth (float): Line width of the unprojected bands\n        annotations (list): Annotations to put on the top and bottom (left and right) figures.\n            By default it will show the spin up and spin down arrows.\n        annotation_xy (list / tuple): Fractional (x, y) coordinated of the annotation location\n        stack (str): Determines how the plots are stacked (vertical or horizontal)\n        linewidth (float): Line width of the plain band structure plotted in the background.\n        band_color (string): Color of the plain band structure.\n        figsize (list / tuple): Desired size of the image in inches. (width, height)\n        erange (list / tuple): Range of energy to show in the plot. [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing. (fig, ax1, ax2)\n    \"\"\"\n\n    band_up = Band(\n        folder=folder,\n        spin=\"up\",\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    band_down = Band(\n        folder=folder,\n        spin=\"down\",\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    if stack == \"vertical\":\n        fig = plt.figure(figsize=(figsize[0], 2 * figsize[1]), dpi=400)\n        ax1 = fig.add_subplot(211)\n        ax2 = fig.add_subplot(212)\n        _figure_setup(ax=ax1, fontsize=fontsize, ylim=[erange[0], erange[1]])\n        _figure_setup(ax=ax2, fontsize=fontsize, ylim=[erange[0], erange[1]])\n    elif stack == \"horizontal\":\n        fig = plt.figure(figsize=(2 * figsize[0], figsize[1]), dpi=400)\n        ax1 = fig.add_subplot(121)\n        ax2 = fig.add_subplot(122)\n        _figure_setup(ax=ax1, fontsize=fontsize, ylim=[erange[0], erange[1]])\n        _figure_setup(ax=ax2, fontsize=fontsize, ylim=[erange[0], erange[1]])\n\n    bbox = dict(\n        boxstyle=\"round\", fc=\"white\", edgecolor=\"gray\", alpha=0.95, pad=0.3\n    )\n    ax1.annotate(\n        annotations[0],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize,\n    )\n    ax2.annotate(\n        annotations[1],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize,\n    )\n\n    band_up.plot_atom_orbitals(\n        ax=ax1,\n        atom_orbital_dict=atom_orbital_dict,\n        display_order=display_order,\n        scale_factor=scale_factor,\n        color_list=color_list,\n        legend=legend,\n        linewidth=linewidth,\n        band_color=band_color,\n        erange=erange,\n    )\n    band_down.plot_plain(\n        sp_scale_factor=0,\n        ax=ax1,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n        erange=erange,\n    )\n\n    band_down.plot_atom_orbitals(\n        ax=ax2,\n        atom_orbital_dict=atom_orbital_dict,\n        display_order=display_order,\n        scale_factor=scale_factor,\n        color_list=color_list,\n        legend=legend,\n        linewidth=linewidth,\n        band_color=band_color,\n        erange=erange,\n    )\n    band_up.plot_plain(\n        sp_scale_factor=0,\n        ax=ax2,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax1, ax2\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_atom_spd","title":"<code>band_atom_spd(folder, atom_spd_dict, output='band_atom_spd.png', spin='up', display_order=None, scale_factor=5, color_list=None, legend=True, linewidth=0.75, band_color='black', figsize=(4, 3), erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, unfold=False, M=None, high_symm_points=None, fontsize=12, heatmap=False, bins=800, sigma=2, cmap='hot', vlinecolor='black', cbar=True, cbar_orientation='horizontal', powernorm=True, gamma=0.5, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None)</code>","text":"<p>This function generates a s, p, d projected band structure on specific atoms.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>atom_spd_dict</code> <code>dict[int</code> <p>str]): A dictionary that contains the individual atoms and the orbitals to project onto. For example, if the user wants to project onto the s, p, d orbitals corresponding of the first atom and the p orbitals of the second atom then the dictionary would be {0:'spd', 1:'p'}</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_atom_spd.png'</code> <code>spin</code> <code>str</code> <p>Choose which spin direction to parse. ('up' or 'down')</p> <code>'up'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot.</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background.</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure.</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches. (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot. [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_atom_spd(\n    folder,\n    atom_spd_dict,\n    output=\"band_atom_spd.png\",\n    spin=\"up\",\n    display_order=None,\n    scale_factor=5,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    figsize=(4, 3),\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=12,\n    heatmap=False,\n    bins=800,\n    sigma=2,\n    cmap=\"hot\",\n    vlinecolor=\"black\",\n    cbar=True,\n    cbar_orientation=\"horizontal\",\n    powernorm=True,\n    gamma=0.5,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n):\n    \"\"\"\n    This function generates a s, p, d projected band structure on specific atoms.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        atom_spd_dict (dict[int:str]): A dictionary that contains the individual atoms and the\n            orbitals to project onto. For example, if the user wants to project onto the s, p, d orbitals corresponding\n            of the first atom and the p orbitals of the second atom then the dictionary would be {0:'spd', 1:'p'}\n        output (str): File name of the resulting plot.\n        spin (str): Choose which spin direction to parse. ('up' or 'down')\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot.\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background.\n        band_color (string): Color of the plain band structure.\n        figsize (list / tuple): Desired size of the image in inches. (width, height)\n        erange (list / tuple): Range of energy to show in the plot. [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    band = Band(\n        folder=folder,\n        spin=spin,\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    if heatmap:\n        legend = False\n        if cbar:\n            if cbar_orientation == \"horizontal\":\n                fig, (ax, cax) = plt.subplots(\n                    nrows=2,\n                    figsize=figsize,\n                    gridspec_kw={\"height_ratios\": [1, 0.05]},\n                    dpi=400,\n                    constrained_layout=True,\n                )\n            elif cbar_orientation == \"vertical\":\n                fig, (ax, cax) = plt.subplots(\n                    ncols=2,\n                    figsize=figsize,\n                    gridspec_kw={\"width_ratios\": [1, 0.05]},\n                    dpi=400,\n                    constrained_layout=True,\n                )\n            else:\n                raise (\n                    \"This is not a valid orientation please choose either horizontal or vertical\"\n                )\n        else:\n            fig = plt.figure(figsize=(figsize), dpi=400)\n            ax = fig.add_subplot(111)\n    else:\n        fig = plt.figure(figsize=(figsize), dpi=400)\n        ax = fig.add_subplot(111)\n\n    _figure_setup(ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]])\n    band.plot_atom_spd(\n        ax=ax,\n        atom_spd_dict=atom_spd_dict,\n        display_order=display_order,\n        scale_factor=scale_factor,\n        color_list=color_list,\n        legend=legend,\n        linewidth=linewidth,\n        band_color=band_color,\n        erange=erange,\n        heatmap=heatmap,\n        bins=bins,\n        sigma=sigma,\n        cmap=cmap,\n        vlinecolor=vlinecolor,\n        powernorm=powernorm,\n        gamma=gamma,\n    )\n\n    if heatmap:\n        if cbar:\n            im = ax.collections[0]\n            min_val = im.norm.vmin\n            max_val = im.norm.vmax\n            cbar = fig.colorbar(im, cax=cax, orientation=cbar_orientation)\n            cbar.set_ticks([min_val, max_val])\n            cbar.set_ticklabels([\"min\", \"max\"])\n\n    if heatmap:\n        if not cbar:\n            fig.tight_layout(pad=0.4)\n    else:\n        fig.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_atom_spd_spin_polarized","title":"<code>band_atom_spd_spin_polarized(folder, atom_spd_dict, output='band_atoms_spd_sp.png', display_order=None, scale_factor=5, color_list=None, legend=True, linewidth=0.75, band_color='black', unprojected_band_color='gray', unprojected_linewidth=0.6, fontsize=12, annotations=['$\\\\uparrow$ ', '$\\\\downarrow$ '], annotation_xy=(0.02, 0.98), figsize=(4, 3), erange=[-6, 6], stack='vertical', kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, unfold=False, M=None, high_symm_points=None, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None)</code>","text":"<p>This function generates a s, p, d spin polarized band structure on specific atoms. This will plot two plots stacked on top or eachother or next to eachother. The top or left plot will project on the spin up bands and the bottom or right plot will project onto the spin down bands.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>atom_spd_dict</code> <code>dict[int</code> <p>str]): A dictionary that contains the individual atoms and the corresponding orbitals to project onto. For example, if the user wants to project onto the s, p, d orbitals of the first atom and the p orbitals of the second atom then the dictionary would be {0:'spd', 1:'p'}</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_atoms_spd_sp.png'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot.</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>unprojected_band_color</code> <code>str</code> <p>Color of the unprojected band</p> <code>'gray'</code> <code>unprojected_linewidth</code> <code>float</code> <p>Line width of the unprojected bands</p> <code>0.6</code> <code>annotations</code> <code>list</code> <p>Annotations to put on the top and bottom (left and right) figures. By default it will show the spin up and spin down arrows.</p> <code>['$\\\\uparrow$ ', '$\\\\downarrow$ ']</code> <code>annotation_xy</code> <code>list / tuple</code> <p>Fractional (x, y) coordinated of the annotation location</p> <code>(0.02, 0.98)</code> <code>stack</code> <code>str</code> <p>Determines how the plots are stacked (vertical or horizontal)</p> <code>'vertical'</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background.</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure.</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches. (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot. [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing. (fig, ax1, ax2)</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_atom_spd_spin_polarized(\n    folder,\n    atom_spd_dict,\n    output=\"band_atoms_spd_sp.png\",\n    display_order=None,\n    scale_factor=5,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    unprojected_band_color=\"gray\",\n    unprojected_linewidth=0.6,\n    fontsize=12,\n    annotations=[\"$\\\\uparrow$ \", \"$\\\\downarrow$ \"],\n    annotation_xy=(0.02, 0.98),\n    figsize=(4, 3),\n    erange=[-6, 6],\n    stack=\"vertical\",\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n):\n    \"\"\"\n    This function generates a s, p, d spin polarized band structure on specific atoms. This will plot two plots\n    stacked on top or eachother or next to eachother. The top or left plot will project on the\n    spin up bands and the bottom or right plot will project onto the spin down bands.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        atom_spd_dict (dict[int:str]): A dictionary that contains the individual atoms and the corresponding\n            orbitals to project onto. For example, if the user wants to project onto the s, p, d orbitals\n            of the first atom and the p orbitals of the second atom then the dictionary would be {0:'spd', 1:'p'}\n        output (str): File name of the resulting plot.\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot.\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        unprojected_band_color (str): Color of the unprojected band\n        unprojected_linewidth (float): Line width of the unprojected bands\n        annotations (list): Annotations to put on the top and bottom (left and right) figures.\n            By default it will show the spin up and spin down arrows.\n        annotation_xy (list / tuple): Fractional (x, y) coordinated of the annotation location\n        stack (str): Determines how the plots are stacked (vertical or horizontal)\n        linewidth (float): Line width of the plain band structure plotted in the background.\n        band_color (string): Color of the plain band structure.\n        figsize (list / tuple): Desired size of the image in inches. (width, height)\n        erange (list / tuple): Range of energy to show in the plot. [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing. (fig, ax1, ax2)\n    \"\"\"\n\n    band_up = Band(\n        folder=folder,\n        spin=\"up\",\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    band_down = Band(\n        folder=folder,\n        spin=\"down\",\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    if stack == \"vertical\":\n        fig = plt.figure(figsize=(figsize[0], 2 * figsize[1]), dpi=400)\n        ax1 = fig.add_subplot(211)\n        ax2 = fig.add_subplot(212)\n        _figure_setup(ax=ax1, fontsize=fontsize, ylim=[erange[0], erange[1]])\n        _figure_setup(ax=ax2, fontsize=fontsize, ylim=[erange[0], erange[1]])\n    elif stack == \"horizontal\":\n        fig = plt.figure(figsize=(2 * figsize[0], figsize[1]), dpi=400)\n        ax1 = fig.add_subplot(121)\n        ax2 = fig.add_subplot(122)\n        _figure_setup(ax=ax1, fontsize=fontsize, ylim=[erange[0], erange[1]])\n        _figure_setup(ax=ax2, fontsize=fontsize, ylim=[erange[0], erange[1]])\n\n    bbox = dict(\n        boxstyle=\"round\", fc=\"white\", edgecolor=\"gray\", alpha=0.95, pad=0.3\n    )\n    ax1.annotate(\n        annotations[0],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize,\n    )\n    ax2.annotate(\n        annotations[1],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize,\n    )\n\n    band_up.plot_atom_spd(\n        ax=ax1,\n        atom_spd_dict=atom_spd_dict,\n        display_order=display_order,\n        scale_factor=scale_factor,\n        color_list=color_list,\n        legend=legend,\n        linewidth=linewidth,\n        band_color=band_color,\n        erange=erange,\n    )\n    band_down.plot_plain(\n        sp_scale_factor=0,\n        ax=ax1,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n        erange=erange,\n    )\n\n    band_down.plot_atom_spd(\n        ax=ax2,\n        atom_spd_dict=atom_spd_dict,\n        display_order=display_order,\n        scale_factor=scale_factor,\n        color_list=color_list,\n        legend=legend,\n        linewidth=linewidth,\n        band_color=band_color,\n        erange=erange,\n    )\n    band_up.plot_plain(\n        sp_scale_factor=0,\n        ax=ax2,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax1, ax2\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_atoms","title":"<code>band_atoms(folder, atoms, output='band_atoms.png', spin='up', display_order=None, scale_factor=5, color_list=None, legend=True, linewidth=0.75, band_color='black', figsize=(4, 3), erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, unfold=False, M=None, high_symm_points=None, fontsize=12, heatmap=False, bins=800, sigma=2, cmap='hot', vlinecolor='black', cbar=True, cbar_orientation='horizontal', powernorm=True, gamma=0.5, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None)</code>","text":"<p>This function generates a projected band structure on specific atoms in the POSCAR.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>atoms</code> <code>list</code> <p>List of atoms to project onto. The indices should be zero indexed (first atom is 0) and the atoms are in the same order as they are in the POSCAR</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_atoms.png'</code> <code>spin</code> <code>str</code> <p>Choose which spin direction to parse. ('up' or 'down')</p> <code>'up'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot.</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background.</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure.</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches. (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot. [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_atoms(\n    folder,\n    atoms,\n    output=\"band_atoms.png\",\n    spin=\"up\",\n    display_order=None,\n    scale_factor=5,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    figsize=(4, 3),\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=12,\n    heatmap=False,\n    bins=800,\n    sigma=2,\n    cmap=\"hot\",\n    vlinecolor=\"black\",\n    cbar=True,\n    cbar_orientation=\"horizontal\",\n    powernorm=True,\n    gamma=0.5,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n):\n    \"\"\"\n    This function generates a projected band structure on specific atoms in the POSCAR.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        atoms (list): List of atoms to project onto. The indices should be zero indexed (first atom is 0)\n            and the atoms are in the same order as they are in the POSCAR\n        output (str): File name of the resulting plot.\n        spin (str): Choose which spin direction to parse. ('up' or 'down')\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot.\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background.\n        band_color (string): Color of the plain band structure.\n        figsize (list / tuple): Desired size of the image in inches. (width, height)\n        erange (list / tuple): Range of energy to show in the plot. [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n    band = Band(\n        folder=folder,\n        spin=spin,\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    if heatmap:\n        legend = False\n        if cbar:\n            if cbar_orientation == \"horizontal\":\n                fig, (ax, cax) = plt.subplots(\n                    nrows=2,\n                    figsize=figsize,\n                    gridspec_kw={\"height_ratios\": [1, 0.05]},\n                    dpi=400,\n                    constrained_layout=True,\n                )\n            elif cbar_orientation == \"vertical\":\n                fig, (ax, cax) = plt.subplots(\n                    ncols=2,\n                    figsize=figsize,\n                    gridspec_kw={\"width_ratios\": [1, 0.05]},\n                    dpi=400,\n                    constrained_layout=True,\n                )\n            else:\n                raise (\n                    \"This is not a valid orientation please choose either horizontal or vertical\"\n                )\n        else:\n            fig = plt.figure(figsize=(figsize), dpi=400)\n            ax = fig.add_subplot(111)\n    else:\n        fig = plt.figure(figsize=(figsize), dpi=400)\n        ax = fig.add_subplot(111)\n\n    _figure_setup(ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]])\n    band.plot_atoms(\n        ax=ax,\n        atoms=atoms,\n        scale_factor=scale_factor,\n        color_list=color_list,\n        display_order=display_order,\n        legend=legend,\n        linewidth=linewidth,\n        band_color=band_color,\n        erange=erange,\n        heatmap=heatmap,\n        bins=bins,\n        sigma=sigma,\n        cmap=cmap,\n        vlinecolor=vlinecolor,\n        powernorm=powernorm,\n        gamma=gamma,\n    )\n\n    if heatmap:\n        if cbar:\n            im = ax.collections[0]\n            min_val = im.norm.vmin\n            max_val = im.norm.vmax\n            cbar = fig.colorbar(im, cax=cax, orientation=cbar_orientation)\n            cbar.set_ticks([min_val, max_val])\n            cbar.set_ticklabels([\"min\", \"max\"])\n\n    if heatmap:\n        if not cbar:\n            fig.tight_layout(pad=0.4)\n    else:\n        fig.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_atoms_spin_polarized","title":"<code>band_atoms_spin_polarized(folder, atoms, output='band_atoms_sp.png', display_order=None, scale_factor=5, color_list=None, legend=True, linewidth=0.75, band_color='black', unprojected_band_color='gray', figsize=(4, 3), erange=[-6, 6], stack='vertical', kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, unfold=False, M=None, high_symm_points=None, fontsize=12, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None)</code>","text":"<p>This function generates an atom spin polarized band structure. This will plot two plots stacked on top or eachother or next to eachother. The top or left plot will project on the spin up bands and the bottom or right plot will project onto the spin down bands.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>atoms</code> <code>list</code> <p>List of atoms to project onto. The indices should be zero indexed (first atom is 0) and the atoms are in the same order as they are in the POSCAR</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_atoms_sp.png'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot.</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>unprojected_band_color</code> <code>str</code> <p>Color of the unprojected band</p> <code>'gray'</code> <code>unprojected_linewidth</code> <code>float</code> <p>Line width of the unprojected bands</p> required <code>annotations</code> <code>list</code> <p>Annotations to put on the top and bottom (left and right) figures. By default it will show the spin up and spin down arrows.</p> required <code>annotation_xy</code> <code>list / tuple</code> <p>Fractional (x, y) coordinated of the annotation location</p> required <code>stack</code> <code>str</code> <p>Determines how the plots are stacked (vertical or horizontal)</p> <code>'vertical'</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background.</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure.</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches. (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot. [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing. (fig, ax1, ax2)</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_atoms_spin_polarized(\n    folder,\n    atoms,\n    output=\"band_atoms_sp.png\",\n    display_order=None,\n    scale_factor=5,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    unprojected_band_color=\"gray\",\n    figsize=(4, 3),\n    erange=[-6, 6],\n    stack=\"vertical\",\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n):\n    \"\"\"\n    This function generates an atom spin polarized band structure. This will plot two plots\n    stacked on top or eachother or next to eachother. The top or left plot will project on the\n    spin up bands and the bottom or right plot will project onto the spin down bands.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        atoms (list): List of atoms to project onto. The indices should be zero indexed (first atom is 0)\n            and the atoms are in the same order as they are in the POSCAR\n        output (str): File name of the resulting plot.\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot.\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        unprojected_band_color (str): Color of the unprojected band\n        unprojected_linewidth (float): Line width of the unprojected bands\n        annotations (list): Annotations to put on the top and bottom (left and right) figures.\n            By default it will show the spin up and spin down arrows.\n        annotation_xy (list / tuple): Fractional (x, y) coordinated of the annotation location\n        stack (str): Determines how the plots are stacked (vertical or horizontal)\n        linewidth (float): Line width of the plain band structure plotted in the background.\n        band_color (string): Color of the plain band structure.\n        figsize (list / tuple): Desired size of the image in inches. (width, height)\n        erange (list / tuple): Range of energy to show in the plot. [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing. (fig, ax1, ax2)\n    \"\"\"\n\n    band_up = Band(\n        folder=folder,\n        spin=\"up\",\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    band_down = Band(\n        folder=folder,\n        spin=\"down\",\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    if stack == \"vertical\":\n        fig = plt.figure(figsize=(figsize[0], 2 * figsize[1]), dpi=400)\n        ax1 = fig.add_subplot(211)\n        ax2 = fig.add_subplot(212)\n        _figure_setup(ax=ax1, fontsize=fontsize, ylim=[erange[0], erange[1]])\n        _figure_setup(ax=ax2, fontsize=fontsize, ylim=[erange[0], erange[1]])\n    elif stack == \"horizontal\":\n        fig = plt.figure(figsize=(2 * figsize[0], figsize[1]), dpi=400)\n        ax1 = fig.add_subplot(121)\n        ax2 = fig.add_subplot(122)\n        _figure_setup(ax=ax1, fontsize=fontsize, ylim=[erange[0], erange[1]])\n        _figure_setup(ax=ax2, fontsize=fontsize, ylim=[erange[0], erange[1]])\n\n    bbox = dict(boxstyle=\"round\", fc=\"white\")\n    ax1.annotate(\n        \"$\\\\uparrow$ \",\n        xy=(0.02, 0.98),\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n    )\n    ax2.annotate(\n        \"$\\\\downarrow$ \",\n        xy=(0.02, 0.98),\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n    )\n\n    band_up.plot_atoms(\n        ax=ax1,\n        atoms=atoms,\n        scale_factor=scale_factor,\n        color_list=color_list,\n        display_order=display_order,\n        legend=legend,\n        linewidth=linewidth,\n        band_color=band_color,\n        erange=erange,\n    )\n    band_up.plot_plain(\n        sp_scale_factor=0,\n        ax=ax1,\n        color=unprojected_band_color,\n        linewidth=0.5,\n        erange=erange,\n    )\n\n    band_down.plot_atoms(\n        ax=ax2,\n        atoms=atoms,\n        scale_factor=scale_factor,\n        color_list=color_list,\n        display_order=display_order,\n        legend=legend,\n        linewidth=linewidth,\n        band_color=band_color,\n        erange=erange,\n    )\n    band_down.plot_plain(\n        sp_scale_factor=0,\n        ax=ax2,\n        color=unprojected_band_color,\n        linewidth=0.5,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax1, ax2\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_dos_atom_orbitals","title":"<code>band_dos_atom_orbitals(band_folder, dos_folder, atom_orbital_dict, output='band_dos_atom_orbitals.png', spin='up', scale_factor=5, color_list=None, legend=True, linewidth=0.75, band_color='black', figsize=(6, 3), width_ratios=[7, 3], erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, display_order=None, unfold=False, M=None, high_symm_points=None, fontsize=12, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None, fill=True, alpha=0.3, sigma=0.05)</code>","text":"<p>This function generates an [atom, orbital] projected band structure next to a projected density of states of the same [atom, orbitals] pairs.</p> <p>Parameters:</p> Name Type Description Default <code>band_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the band structure</p> required <code>dos_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the density of states</p> required <code>atom_orbital_dict</code> <code>dict[int</code> <p>list]): A dictionary that contains the individual atoms and the corresponding orbitals to project onto. For example, if the user wants to project onto the s, py, pz, and px orbitals of the first atom and the s orbital of the second atom then the dictionary would be {0:[0,1,2,3], 1:[0]}</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_dos_atom_orbitals.png'</code> <code>spin</code> <code>str</code> <p>Choose which spin direction to parse. ('up' or 'down')</p> <code>'up'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(6, 3)</code> <code>width_ratios</code> <code>list / tuple</code> <p>Width ration of the band plot and dos plot.</p> <code>[7, 3]</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_dos_atom_orbitals(\n    band_folder,\n    dos_folder,\n    atom_orbital_dict,\n    output=\"band_dos_atom_orbitals.png\",\n    spin=\"up\",\n    scale_factor=5,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    figsize=(6, 3),\n    width_ratios=[7, 3],\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    display_order=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n    fill=True,\n    alpha=0.3,\n    sigma=0.05,\n):\n    \"\"\"\n    This function generates an [atom, orbital] projected band structure next to\n    a projected density of states of the same [atom, orbitals] pairs.\n\n    Parameters:\n        band_folder (str): This is the folder that contains the VASP files for the band structure\n        dos_folder (str): This is the folder that contains the VASP files for the density of states\n        atom_orbital_dict (dict[int:list]): A dictionary that contains the individual atoms and the\n            corresponding orbitals to project onto. For example, if the user wants to project onto the s, py, pz, and px orbitals\n            of the first atom and the s orbital of the second atom then the dictionary would be {0:[0,1,2,3], 1:[0]}\n        output (str): File name of the resulting plot.\n        spin (str): Choose which spin direction to parse. ('up' or 'down')\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background\n        band_color (string): Color of the plain band structure\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        width_ratios (list / tuple): Width ration of the band plot and dos plot.\n        erange (list / tuple): Range of energy to show in the plot [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        sigma (float): Standard deviation for gaussian filter\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    fig, ax = plt.subplots(\n        nrows=1,\n        ncols=2,\n        sharey=True,\n        figsize=figsize,\n        dpi=400,\n        gridspec_kw={\"width_ratios\": width_ratios},\n    )\n\n    ax1, ax2 = _figure_setup_band_dos(\n        ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]]\n    )\n\n    band = Band(\n        folder=band_folder,\n        spin=spin,\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    dos = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=spin)\n\n    band.plot_atom_orbitals(\n        ax=ax1,\n        scale_factor=scale_factor,\n        atom_orbital_dict=atom_orbital_dict,\n        color_list=color_list,\n        legend=False,\n        erange=erange,\n        display_order=display_order,\n        linewidth=linewidth,\n        band_color=band_color,\n    )\n\n    dos.plot_atom_orbitals(\n        ax=ax2,\n        atom_orbital_dict=atom_orbital_dict,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=legend,\n        total=True,\n        erange=erange,\n    )\n\n    fig.canvas.draw()\n    nbins = len(ax2.get_xticklabels())\n    ax2.xaxis.set_major_locator(MaxNLocator(nbins=nbins - 1, prune=\"lower\"))\n\n    plt.tight_layout(pad=0.4)\n    plt.subplots_adjust(wspace=0)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax1, ax2\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_dos_atom_orbitals_spin_polarized","title":"<code>band_dos_atom_orbitals_spin_polarized(band_folder, dos_folder, atom_orbital_dict, output='band_dos_atom_orbitals_sp.png', scale_factor=5, color_list=None, legend=True, linewidth=0.75, band_color='black', unprojected_band_color='gray', unprojected_linewidth=0.6, figsize=(8, 6), width_ratios=[7, 3], erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, display_order=None, unfold=False, M=None, high_symm_points=None, fontsize=8, annotations=['$\\\\uparrow$ ', '$\\\\downarrow$ '], annotation_xy=(0.0125, 0.98), save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None, fill=True, alpha=0.3, sigma=0.05, total=True)</code>","text":"<p>This function plots a spin polarized band structure projected onto specified [atom, orbital] pairs next to a spin polarized density of states projected onto the same [atom, orbital] pairs. The top figure highlights the spin up bands and the bottom figure highlights the spin down bands.</p> <p>Parameters:</p> Name Type Description Default <code>band_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the band structure</p> required <code>dos_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the density of states</p> required <code>atom_orbital_dict</code> <code>dict[int</code> <p>list]): A dictionary that contains the individual atoms and the corresponding orbitals to project onto. For example, if the user wants to project onto the s, py, pz, and px orbitals of the first atom and the s orbital of the second atom then the dictionary would be {0:[0,1,2,3], 1:[0]}</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_dos_atom_orbitals_sp.png'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure</p> <code>'black'</code> <code>unprojected_band_color</code> <code>str</code> <p>Color of the unprojected band</p> <code>'gray'</code> <code>unprojected_linewidth</code> <code>float</code> <p>Line width of the unprojected bands</p> <code>0.6</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(8, 6)</code> <code>width_ratios</code> <code>list / tuple</code> <p>Width ration of the band plot and dos plot.</p> <code>[7, 3]</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>8</code> <code>annotations</code> <code>list</code> <p>Annotations to put on the top and bottom (left and right) figures. By default it will show the spin up and spin down arrows.</p> <code>['$\\\\uparrow$ ', '$\\\\downarrow$ ']</code> <code>annotation_xy</code> <code>list / tuple</code> <p>Fractional (x, y) coordinated of the annotation location</p> <code>(0.0125, 0.98)</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_dos_atom_orbitals_spin_polarized(\n    band_folder,\n    dos_folder,\n    atom_orbital_dict,\n    output=\"band_dos_atom_orbitals_sp.png\",\n    scale_factor=5,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    unprojected_band_color=\"gray\",\n    unprojected_linewidth=0.6,\n    figsize=(8, 6),\n    width_ratios=[7, 3],\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    display_order=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=8,\n    annotations=[\"$\\\\uparrow$ \", \"$\\\\downarrow$ \"],\n    annotation_xy=(0.0125, 0.98),\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n    fill=True,\n    alpha=0.3,\n    sigma=0.05,\n    total=True,\n):\n    \"\"\"\n    This function plots a spin polarized band structure projected onto specified [atom, orbital] pairs next to a spin\n    polarized density of states projected onto the same [atom, orbital] pairs. The top figure highlights the spin up\n    bands and the bottom figure highlights the spin down bands.\n\n    Parameters:\n        band_folder (str): This is the folder that contains the VASP files for the band structure\n        dos_folder (str): This is the folder that contains the VASP files for the density of states\n        atom_orbital_dict (dict[int:list]): A dictionary that contains the individual atoms and the\n            corresponding orbitals to project onto. For example, if the user wants to project onto the s, py, pz, and px orbitals\n            of the first atom and the s orbital of the second atom then the dictionary would be {0:[0,1,2,3], 1:[0]}\n        output (str): File name of the resulting plot.\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background\n        band_color (string): Color of the plain band structure\n        unprojected_band_color (str): Color of the unprojected band\n        unprojected_linewidth (float): Line width of the unprojected bands\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        width_ratios (list / tuple): Width ration of the band plot and dos plot.\n        erange (list / tuple): Range of energy to show in the plot [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        annotations (list): Annotations to put on the top and bottom (left and right) figures.\n            By default it will show the spin up and spin down arrows.\n        annotation_xy (list / tuple): Fractional (x, y) coordinated of the annotation location\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        sigma (float): Standard deviation for gaussian filter\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    fig, ax = plt.subplots(\n        nrows=2,\n        ncols=2,\n        sharey=True,\n        figsize=figsize,\n        dpi=400,\n        gridspec_kw={\"width_ratios\": width_ratios},\n    )\n\n    (\n        ax_band_up,\n        ax_dos_up,\n        ax_band_down,\n        ax_dos_down,\n    ) = _figure_setup_band_dos_spin_polarized(\n        ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]]\n    )\n\n    band_up = Band(\n        folder=band_folder,\n        spin=\"up\",\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    band_down = Band(\n        folder=band_folder,\n        spin=\"down\",\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    dos_up = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=\"up\")\n    dos_down = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=\"down\")\n\n    bbox = dict(\n        boxstyle=\"round\", fc=\"white\", edgecolor=\"gray\", alpha=0.95, pad=0.3\n    )\n\n    ax_band_up.annotate(\n        annotations[0],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize + 1,\n    )\n    ax_band_down.annotate(\n        annotations[1],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize + 1,\n    )\n\n    band_up.plot_atom_orbitals(\n        ax=ax_band_up,\n        scale_factor=scale_factor,\n        atom_orbital_dict=atom_orbital_dict,\n        color_list=color_list,\n        legend=False,\n        linewidth=linewidth,\n        band_color=band_color,\n        display_order=display_order,\n        erange=erange,\n    )\n\n    band_down.plot_plain(\n        sp_scale_factor=0,\n        ax=ax_band_up,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n        erange=erange,\n    )\n\n    dos_up.plot_atom_orbitals(\n        ax=ax_dos_up,\n        atom_orbital_dict=atom_orbital_dict,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=legend,\n        total=total,\n        erange=erange,\n    )\n\n    dos_down.plot_atom_orbitals(\n        ax=ax_dos_up,\n        atom_orbital_dict=atom_orbital_dict,\n        fill=fill,\n        alpha=0.25 * alpha,\n        alpha_line=0.25 * alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=False,\n        total=total,\n        erange=erange,\n    )\n\n    band_down.plot_atom_orbitals(\n        ax=ax_band_down,\n        scale_factor=scale_factor,\n        atom_orbital_dict=atom_orbital_dict,\n        color_list=color_list,\n        legend=False,\n        linewidth=linewidth,\n        band_color=band_color,\n        display_order=display_order,\n        erange=erange,\n    )\n\n    band_up.plot_plain(\n        sp_scale_factor=0,\n        ax=ax_band_down,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n        erange=erange,\n    )\n\n    dos_down.plot_atom_orbitals(\n        ax=ax_dos_down,\n        atom_orbital_dict=atom_orbital_dict,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=legend,\n        total=total,\n        erange=erange,\n    )\n\n    dos_up.plot_atom_orbitals(\n        ax=ax_dos_down,\n        atom_orbital_dict=atom_orbital_dict,\n        fill=fill,\n        alpha=0.25 * alpha,\n        alpha_line=0.25 * alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=False,\n        total=total,\n        erange=erange,\n    )\n\n    fig.canvas.draw()\n    nbins = len(ax_dos_down.get_xticklabels())\n    ax_dos_down.xaxis.set_major_locator(\n        MaxNLocator(nbins=nbins - 1, prune=\"lower\")\n    )\n\n    plt.tight_layout(pad=0.4)\n    plt.subplots_adjust(wspace=0, hspace=0.05)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax_band_up, ax_dos_up, ax_band_down, ax_dos_down\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_dos_atom_spd","title":"<code>band_dos_atom_spd(band_folder, dos_folder, atom_spd_dict, output='band_dos_atom_spd.png', spin='up', scale_factor=5, color_list=None, legend=True, linewidth=0.75, band_color='black', figsize=(6, 3), width_ratios=[7, 3], erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, display_order=None, unfold=False, M=None, high_symm_points=None, fontsize=12, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None, fill=True, alpha=0.3, sigma=0.05)</code>","text":"<p>This function generates a s, p, d projected band structure on specific atoms next to a projected density of states on the s, p, d orbitals for the same atoms.</p> <p>Parameters:</p> Name Type Description Default <code>band_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the band structure</p> required <code>dos_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the density of states</p> required <code>atom_spd_dict</code> <code>dict[int</code> <p>str]): A dictionary that contains the individual atoms and the corresponding orbitals to project onto. For example, if the user wants to project onto the s, p, d orbitals of the first atom and the p orbitals of the second atom then the dictionary would be {0:'spd', 1:'p'}</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_dos_atom_spd.png'</code> <code>spin</code> <code>str</code> <p>Choose which spin direction to parse. ('up' or 'down')</p> <code>'up'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(6, 3)</code> <code>width_ratios</code> <code>list / tuple</code> <p>Width ration of the band plot and dos plot.</p> <code>[7, 3]</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_dos_atom_spd(\n    band_folder,\n    dos_folder,\n    atom_spd_dict,\n    output=\"band_dos_atom_spd.png\",\n    spin=\"up\",\n    scale_factor=5,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    figsize=(6, 3),\n    width_ratios=[7, 3],\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    display_order=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n    fill=True,\n    alpha=0.3,\n    sigma=0.05,\n):\n    \"\"\"\n    This function generates a s, p, d projected band structure on specific atoms next to a\n    projected density of states on the s, p, d orbitals for the same atoms.\n\n    Parameters:\n        band_folder (str): This is the folder that contains the VASP files for the band structure\n        dos_folder (str): This is the folder that contains the VASP files for the density of states\n        atom_spd_dict (dict[int:str]): A dictionary that contains the individual atoms and the corresponding\n            orbitals to project onto. For example, if the user wants to project onto the s, p, d orbitals\n            of the first atom and the p orbitals of the second atom then the dictionary would be {0:'spd', 1:'p'}\n        output (str): File name of the resulting plot.\n        spin (str): Choose which spin direction to parse. ('up' or 'down')\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background\n        band_color (string): Color of the plain band structure\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        width_ratios (list / tuple): Width ration of the band plot and dos plot.\n        erange (list / tuple): Range of energy to show in the plot [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        sigma (float): Standard deviation for gaussian filter\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    fig, ax = plt.subplots(\n        nrows=1,\n        ncols=2,\n        sharey=True,\n        figsize=figsize,\n        dpi=400,\n        gridspec_kw={\"width_ratios\": width_ratios},\n    )\n\n    ax1, ax2 = _figure_setup_band_dos(\n        ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]]\n    )\n\n    band = Band(\n        folder=band_folder,\n        spin=spin,\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    dos = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=spin)\n\n    band.plot_atom_spd(\n        ax=ax1,\n        atom_spd_dict=atom_spd_dict,\n        display_order=display_order,\n        scale_factor=scale_factor,\n        color_list=color_list,\n        legend=False,\n        linewidth=linewidth,\n        band_color=band_color,\n        erange=erange,\n    )\n\n    dos.plot_atom_spd(\n        ax=ax2,\n        atom_spd_dict=atom_spd_dict,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=legend,\n        total=True,\n        erange=erange,\n    )\n\n    fig.canvas.draw()\n    nbins = len(ax2.get_xticklabels())\n    ax2.xaxis.set_major_locator(MaxNLocator(nbins=nbins - 1, prune=\"lower\"))\n\n    plt.tight_layout(pad=0.4)\n    plt.subplots_adjust(wspace=0)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax1, ax2\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_dos_atom_spd_spin_polarized","title":"<code>band_dos_atom_spd_spin_polarized(band_folder, dos_folder, atom_spd_dict, output='band_dos_atom_spd_sp.png', scale_factor=5, color_list=None, legend=True, linewidth=0.75, band_color='black', unprojected_band_color='gray', unprojected_linewidth=0.6, figsize=(8, 6), width_ratios=[7, 3], erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, fontsize=8, annotations=['$\\\\uparrow$ ', '$\\\\downarrow$ '], annotation_xy=(0.0125, 0.98), save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None, fill=True, alpha=0.3, sigma=0.05)</code>","text":"<p>This function plots a spin polarized s, p, d projected band structure on a given atom next to a spin polarized s, p, d projected density of states on the same atom. The top figure highlights the spin up bands and the bottom figure highlights the spin down bands.</p> <p>Parameters:</p> Name Type Description Default <code>band_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the band structure</p> required <code>dos_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the density of states</p> required <code>atom_spd_dict</code> <code>dict[int</code> <p>str]): A dictionary that contains the individual atoms and the corresponding orbitals to project onto. For example, if the user wants to project onto the s, p, d orbitals of the first atom and the p orbitals of the second atom then the dictionary would be {0:'spd', 1:'p'}</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_dos_atom_spd_sp.png'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> required <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure</p> <code>'black'</code> <code>unprojected_band_color</code> <code>str</code> <p>Color of the unprojected band</p> <code>'gray'</code> <code>unprojected_linewidth</code> <code>float</code> <p>Line width of the unprojected bands</p> <code>0.6</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(8, 6)</code> <code>width_ratios</code> <code>list / tuple</code> <p>Width ration of the band plot and dos plot.</p> <code>[7, 3]</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> required <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> required <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> required <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>8</code> <code>annotations</code> <code>list</code> <p>Annotations to put on the top and bottom (left and right) figures. By default it will show the spin up and spin down arrows.</p> <code>['$\\\\uparrow$ ', '$\\\\downarrow$ ']</code> <code>annotation_xy</code> <code>list / tuple</code> <p>Fractional (x, y) coordinated of the annotation location</p> <code>(0.0125, 0.98)</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_dos_atom_spd_spin_polarized(\n    band_folder,\n    dos_folder,\n    atom_spd_dict,\n    output=\"band_dos_atom_spd_sp.png\",\n    scale_factor=5,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    unprojected_band_color=\"gray\",\n    unprojected_linewidth=0.6,\n    figsize=(8, 6),\n    width_ratios=[7, 3],\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    fontsize=8,\n    annotations=[\"$\\\\uparrow$ \", \"$\\\\downarrow$ \"],\n    annotation_xy=(0.0125, 0.98),\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n    fill=True,\n    alpha=0.3,\n    sigma=0.05,\n):\n    \"\"\"\n    This function plots a spin polarized s, p, d projected band structure on a given atom next to a spin polarized\n    s, p, d projected density of states on the same atom. The top figure highlights the spin up bands and the bottom\n    figure highlights the spin down bands.\n\n    Parameters:\n        band_folder (str): This is the folder that contains the VASP files for the band structure\n        dos_folder (str): This is the folder that contains the VASP files for the density of states\n        atom_spd_dict (dict[int:str]): A dictionary that contains the individual atoms and the corresponding\n            orbitals to project onto. For example, if the user wants to project onto the s, p, d orbitals\n            of the first atom and the p orbitals of the second atom then the dictionary would be {0:'spd', 1:'p'}\n        output (str): File name of the resulting plot.\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background\n        band_color (string): Color of the plain band structure\n        unprojected_band_color (str): Color of the unprojected band\n        unprojected_linewidth (float): Line width of the unprojected bands\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        width_ratios (list / tuple): Width ration of the band plot and dos plot.\n        erange (list / tuple): Range of energy to show in the plot [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        annotations (list): Annotations to put on the top and bottom (left and right) figures.\n            By default it will show the spin up and spin down arrows.\n        annotation_xy (list / tuple): Fractional (x, y) coordinated of the annotation location\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        sigma (float): Standard deviation for gaussian filter\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    fig, ax = plt.subplots(\n        nrows=2,\n        ncols=2,\n        sharey=True,\n        figsize=figsize,\n        dpi=400,\n        gridspec_kw={\"width_ratios\": width_ratios},\n    )\n\n    (\n        ax_band_up,\n        ax_dos_up,\n        ax_band_down,\n        ax_dos_down,\n    ) = _figure_setup_band_dos_spin_polarized(\n        ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]]\n    )\n\n    band_up = Band(\n        folder=band_folder,\n        spin=\"up\",\n        projected=True,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n    )\n\n    band_down = Band(\n        folder=band_folder,\n        spin=\"down\",\n        projected=True,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n    )\n\n    dos_up = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=\"up\")\n    dos_down = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=\"down\")\n\n    bbox = dict(\n        boxstyle=\"round\", fc=\"white\", edgecolor=\"gray\", alpha=0.95, pad=0.3\n    )\n\n    ax_band_up.annotate(\n        annotations[0],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize + 1,\n    )\n    ax_band_down.annotate(\n        annotations[1],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize + 1,\n    )\n\n    band_up.plot_atom_spd(\n        ax=ax_band_up,\n        atom_spd_dict=atom_spd_dict,\n        scale_factor=scale_factor,\n        color_list=color_list,\n        legend=False,\n        linewidth=linewidth,\n        band_color=band_color,\n    )\n\n    band_down.plot_plain(\n        sp_scale_factor=0,\n        ax=ax_band_up,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n    )\n\n    dos_up.plot_atom_spd(\n        ax=ax_dos_up,\n        atom_spd_dict=atom_spd_dict,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=legend,\n        total=True,\n        erange=erange,\n    )\n\n    dos_down.plot_atom_spd(\n        ax=ax_dos_up,\n        atom_spd_dict=atom_spd_dict,\n        fill=fill,\n        alpha=0.25 * alpha,\n        alpha_line=0.25 * alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=False,\n        total=True,\n        erange=erange,\n    )\n\n    band_down.plot_atom_spd(\n        ax=ax_band_down,\n        atom_spd_dict=atom_spd_dict,\n        scale_factor=scale_factor,\n        color_list=color_list,\n        legend=False,\n        linewidth=linewidth,\n        band_color=band_color,\n    )\n\n    band_up.plot_plain(\n        sp_scale_factor=0,\n        ax=ax_band_down,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n    )\n\n    dos_down.plot_atom_spd(\n        ax=ax_dos_down,\n        atom_spd_dict=atom_spd_dict,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=legend,\n        total=True,\n        erange=erange,\n    )\n\n    dos_up.plot_atom_spd(\n        ax=ax_dos_down,\n        atom_spd_dict=atom_spd_dict,\n        fill=fill,\n        alpha=0.25 * alpha,\n        alpha_line=0.25 * alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=False,\n        total=True,\n        erange=erange,\n    )\n\n    fig.canvas.draw()\n    nbins = len(ax_dos_down.get_xticklabels())\n    ax_dos_down.xaxis.set_major_locator(\n        MaxNLocator(nbins=nbins - 1, prune=\"lower\")\n    )\n\n    plt.tight_layout(pad=0.4)\n    plt.subplots_adjust(wspace=0, hspace=0.05)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax_band_up, ax_dos_up, ax_band_down, ax_dos_down\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_dos_atoms","title":"<code>band_dos_atoms(band_folder, dos_folder, atoms, output='band_dos_atoms.png', spin='up', scale_factor=5, color_list=None, legend=True, linewidth=0.75, band_color='black', figsize=(6, 3), width_ratios=[7, 3], erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, display_order=None, unfold=False, M=None, high_symm_points=None, fontsize=12, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None, fill=True, alpha=0.3, sigma=0.05)</code>","text":"<p>This function generates a projected band structure on specific atoms next to a projected density of states on the same atoms.</p> <p>Parameters:</p> Name Type Description Default <code>band_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the band structure</p> required <code>dos_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the density of states</p> required <code>atoms</code> <code>list</code> <p>List of atoms to project onto. The indices should be zero indexed (first atom is 0) and the atoms are in the same order as they are in the POSCAR</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_dos_atoms.png'</code> <code>spin</code> <code>str</code> <p>Choose which spin direction to parse. ('up' or 'down')</p> <code>'up'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(6, 3)</code> <code>width_ratios</code> <code>list / tuple</code> <p>Width ration of the band plot and dos plot.</p> <code>[7, 3]</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_dos_atoms(\n    band_folder,\n    dos_folder,\n    atoms,\n    output=\"band_dos_atoms.png\",\n    spin=\"up\",\n    scale_factor=5,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    figsize=(6, 3),\n    width_ratios=[7, 3],\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    display_order=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n    fill=True,\n    alpha=0.3,\n    sigma=0.05,\n):\n    \"\"\"\n    This function generates a projected band structure on specific atoms next to a\n    projected density of states on the same atoms.\n\n    Parameters:\n        band_folder (str): This is the folder that contains the VASP files for the band structure\n        dos_folder (str): This is the folder that contains the VASP files for the density of states\n        atoms (list): List of atoms to project onto. The indices should be zero indexed (first atom is 0)\n            and the atoms are in the same order as they are in the POSCAR\n        output (str): File name of the resulting plot.\n        spin (str): Choose which spin direction to parse. ('up' or 'down')\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background\n        band_color (string): Color of the plain band structure\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        width_ratios (list / tuple): Width ration of the band plot and dos plot.\n        erange (list / tuple): Range of energy to show in the plot [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        sigma (float): Standard deviation for gaussian filter\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    fig, ax = plt.subplots(\n        nrows=1,\n        ncols=2,\n        sharey=True,\n        figsize=figsize,\n        dpi=400,\n        gridspec_kw={\"width_ratios\": width_ratios},\n    )\n\n    ax1, ax2 = _figure_setup_band_dos(\n        ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]]\n    )\n\n    band = Band(\n        folder=band_folder,\n        spin=spin,\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    dos = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=spin)\n\n    band.plot_atoms(\n        ax=ax1,\n        atoms=atoms,\n        scale_factor=scale_factor,\n        color_list=color_list,\n        erange=erange,\n        display_order=display_order,\n        legend=False,\n        linewidth=linewidth,\n        band_color=band_color,\n    )\n\n    dos.plot_atoms(\n        ax=ax2,\n        atoms=atoms,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=legend,\n        total=True,\n        erange=erange,\n    )\n\n    fig.canvas.draw()\n    nbins = len(ax2.get_xticklabels())\n    ax2.xaxis.set_major_locator(MaxNLocator(nbins=nbins - 1, prune=\"lower\"))\n\n    plt.tight_layout(pad=0.4)\n    plt.subplots_adjust(wspace=0)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax1, ax2\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_dos_atoms_spin_polarized","title":"<code>band_dos_atoms_spin_polarized(band_folder, dos_folder, atoms, output='band_dos_atoms_sp.png', scale_factor=5, color_list=None, legend=True, linewidth=0.75, band_color='black', unprojected_band_color='gray', unprojected_linewidth=0.6, figsize=(8, 6), width_ratios=[7, 3], erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, fontsize=8, annotations=['$\\\\uparrow$ ', '$\\\\downarrow$ '], annotation_xy=(0.0125, 0.98), save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None, fill=True, alpha=0.3, sigma=0.05)</code>","text":"<p>This function plots a spin polarized bandstructure projected onto specified atoms in the POSCAR next to its corresponding density of states projected onto the same atoms. The top figure highlights the spin up bands and the bottom figure highlight the spin down bands.</p> <p>Parameters:</p> Name Type Description Default <code>band_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the band structure</p> required <code>dos_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the density of states</p> required <code>atoms</code> <code>list</code> <p>List of atoms to project onto. The indices should be zero indexed (first atom is 0) and the atoms are in the same order as they are in the POSCAR</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_dos_atoms_sp.png'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> required <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure</p> <code>'black'</code> <code>unprojected_band_color</code> <code>str</code> <p>Color of the unprojected band</p> <code>'gray'</code> <code>unprojected_linewidth</code> <code>float</code> <p>Line width of the unprojected bands</p> <code>0.6</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(8, 6)</code> <code>width_ratios</code> <code>list / tuple</code> <p>Width ration of the band plot and dos plot.</p> <code>[7, 3]</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> required <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> required <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> required <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>8</code> <code>annotations</code> <code>list</code> <p>Annotations to put on the top and bottom (left and right) figures. By default it will show the spin up and spin down arrows.</p> <code>['$\\\\uparrow$ ', '$\\\\downarrow$ ']</code> <code>annotation_xy</code> <code>list / tuple</code> <p>Fractional (x, y) coordinated of the annotation location</p> <code>(0.0125, 0.98)</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_dos_atoms_spin_polarized(\n    band_folder,\n    dos_folder,\n    atoms,\n    output=\"band_dos_atoms_sp.png\",\n    scale_factor=5,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    unprojected_band_color=\"gray\",\n    unprojected_linewidth=0.6,\n    figsize=(8, 6),\n    width_ratios=[7, 3],\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    fontsize=8,\n    annotations=[\"$\\\\uparrow$ \", \"$\\\\downarrow$ \"],\n    annotation_xy=(0.0125, 0.98),\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n    fill=True,\n    alpha=0.3,\n    sigma=0.05,\n):\n    \"\"\"\n    This function plots a spin polarized bandstructure projected onto specified atoms in the POSCAR next\n    to its corresponding density of states projected onto the same atoms. The top figure highlights the\n    spin up bands and the bottom figure highlight the spin down bands.\n\n    Parameters:\n        band_folder (str): This is the folder that contains the VASP files for the band structure\n        dos_folder (str): This is the folder that contains the VASP files for the density of states\n        atoms (list): List of atoms to project onto. The indices should be zero indexed (first atom is 0)\n            and the atoms are in the same order as they are in the POSCAR\n        output (str): File name of the resulting plot.\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background\n        band_color (string): Color of the plain band structure\n        unprojected_band_color (str): Color of the unprojected band\n        unprojected_linewidth (float): Line width of the unprojected bands\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        width_ratios (list / tuple): Width ration of the band plot and dos plot.\n        erange (list / tuple): Range of energy to show in the plot [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        annotations (list): Annotations to put on the top and bottom (left and right) figures.\n            By default it will show the spin up and spin down arrows.\n        annotation_xy (list / tuple): Fractional (x, y) coordinated of the annotation location\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        sigma (float): Standard deviation for gaussian filter\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    fig, ax = plt.subplots(\n        nrows=2,\n        ncols=2,\n        sharey=True,\n        figsize=figsize,\n        dpi=400,\n        gridspec_kw={\"width_ratios\": width_ratios},\n    )\n\n    (\n        ax_band_up,\n        ax_dos_up,\n        ax_band_down,\n        ax_dos_down,\n    ) = _figure_setup_band_dos_spin_polarized(\n        ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]]\n    )\n\n    band_up = Band(\n        folder=band_folder,\n        spin=\"up\",\n        projected=True,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n    )\n\n    band_down = Band(\n        folder=band_folder,\n        spin=\"down\",\n        projected=True,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n    )\n\n    dos_up = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=\"up\")\n    dos_down = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=\"down\")\n\n    bbox = dict(\n        boxstyle=\"round\", fc=\"white\", edgecolor=\"gray\", alpha=0.95, pad=0.3\n    )\n\n    ax_band_up.annotate(\n        annotations[0],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize + 1,\n    )\n    ax_band_down.annotate(\n        annotations[1],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize + 1,\n    )\n\n    band_up.plot_atoms(\n        ax=ax_band_up,\n        scale_factor=scale_factor,\n        atoms=atoms,\n        color_list=color_list,\n        legend=False,\n        linewidth=linewidth,\n        band_color=band_color,\n    )\n\n    band_down.plot_plain(\n        sp_scale_factor=0,\n        ax=ax_band_up,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n    )\n\n    dos_up.plot_atoms(\n        ax=ax_dos_up,\n        atoms=atoms,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=legend,\n        total=True,\n        erange=erange,\n    )\n\n    dos_down.plot_atoms(\n        ax=ax_dos_up,\n        atoms=atoms,\n        fill=fill,\n        alpha=0.25 * alpha,\n        alpha_line=0.25 * alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=False,\n        total=True,\n        erange=erange,\n    )\n\n    band_down.plot_atoms(\n        ax=ax_band_down,\n        scale_factor=scale_factor,\n        atoms=atoms,\n        color_list=color_list,\n        legend=False,\n        linewidth=linewidth,\n        band_color=band_color,\n    )\n\n    band_up.plot_plain(\n        sp_scale_factor=0,\n        ax=ax_band_down,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n    )\n\n    dos_down.plot_atoms(\n        ax=ax_dos_down,\n        atoms=atoms,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=legend,\n        total=True,\n        erange=erange,\n    )\n\n    dos_up.plot_atoms(\n        ax=ax_dos_down,\n        atoms=atoms,\n        fill=fill,\n        alpha=0.25 * alpha,\n        alpha_line=0.25 * alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=False,\n        total=True,\n        erange=erange,\n    )\n\n    fig.canvas.draw()\n    nbins = len(ax_dos_down.get_xticklabels())\n    ax_dos_down.xaxis.set_major_locator(\n        MaxNLocator(nbins=nbins - 1, prune=\"lower\")\n    )\n\n    plt.tight_layout(pad=0.4)\n    plt.subplots_adjust(wspace=0, hspace=0.05)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax_band_up, ax_dos_up, ax_band_down, ax_dos_down\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_dos_element_orbitals","title":"<code>band_dos_element_orbitals(band_folder, dos_folder, element_orbital_dict, output='band_dos_element_orbitals.png', spin='up', scale_factor=5, color_list=None, legend=True, linewidth=0.75, band_color='black', figsize=(6, 3), width_ratios=[7, 3], erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, display_order=None, unfold=False, M=None, high_symm_points=None, fontsize=12, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None, fill=True, alpha=0.3, sigma=0.05)</code>","text":"<p>This function generates a projected band structure on orbitals of specific elements next to a projected density of states on the same orbitals for the same elements.</p> <p>Parameters:</p> Name Type Description Default <code>band_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the band structure</p> required <code>dos_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the density of states</p> required <code>element_orbital_dict</code> <code>dict[str</code> <p>list]): A dictionary that contains the individual elements and the corresponding orbitals to project onto. For example, if the user wants to project onto the s, py, pz, and px orbitals of In and the s orbital of As for and InAs structure then the dictionary would be {'In':[0,1,2,3], 'As':[0]}</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_dos_element_orbitals.png'</code> <code>spin</code> <code>str</code> <p>Choose which spin direction to parse. ('up' or 'down')</p> <code>'up'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(6, 3)</code> <code>width_ratios</code> <code>list / tuple</code> <p>Width ration of the band plot and dos plot.</p> <code>[7, 3]</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_dos_element_orbitals(\n    band_folder,\n    dos_folder,\n    element_orbital_dict,\n    output=\"band_dos_element_orbitals.png\",\n    spin=\"up\",\n    scale_factor=5,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    figsize=(6, 3),\n    width_ratios=[7, 3],\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    display_order=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n    fill=True,\n    alpha=0.3,\n    sigma=0.05,\n):\n    \"\"\"\n    This function generates a projected band structure on orbitals of specific elements next to a\n    projected density of states on the same orbitals for the same elements.\n\n    Parameters:\n        band_folder (str): This is the folder that contains the VASP files for the band structure\n        dos_folder (str): This is the folder that contains the VASP files for the density of states\n        element_orbital_dict (dict[str:list]): A dictionary that contains the individual elements and the corresponding\n            orbitals to project onto. For example, if the user wants to project onto the s, py, pz, and px orbitals\n            of In and the s orbital of As for and InAs structure then the dictionary would be {'In':[0,1,2,3], 'As':[0]}\n        output (str): File name of the resulting plot.\n        spin (str): Choose which spin direction to parse. ('up' or 'down')\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background\n        band_color (string): Color of the plain band structure\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        width_ratios (list / tuple): Width ration of the band plot and dos plot.\n        erange (list / tuple): Range of energy to show in the plot [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        sigma (float): Standard deviation for gaussian filter\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    fig, ax = plt.subplots(\n        nrows=1,\n        ncols=2,\n        sharey=True,\n        figsize=figsize,\n        dpi=400,\n        gridspec_kw={\"width_ratios\": width_ratios},\n    )\n\n    ax1, ax2 = _figure_setup_band_dos(\n        ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]]\n    )\n\n    band = Band(\n        folder=band_folder,\n        spin=spin,\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    dos = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=spin)\n\n    band.plot_element_orbitals(\n        ax=ax1,\n        scale_factor=scale_factor,\n        element_orbital_dict=element_orbital_dict,\n        display_order=display_order,\n        erange=erange,\n        color_list=color_list,\n        legend=False,\n        linewidth=linewidth,\n        band_color=band_color,\n    )\n\n    dos.plot_element_orbitals(\n        ax=ax2,\n        element_orbital_dict=element_orbital_dict,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=legend,\n        total=True,\n        erange=erange,\n    )\n\n    fig.canvas.draw()\n    nbins = len(ax2.get_xticklabels())\n    ax2.xaxis.set_major_locator(MaxNLocator(nbins=nbins - 1, prune=\"lower\"))\n\n    plt.tight_layout(pad=0.4)\n    plt.subplots_adjust(wspace=0)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax1, ax2\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_dos_element_orbitals_spin_polarized","title":"<code>band_dos_element_orbitals_spin_polarized(band_folder, dos_folder, element_orbital_dict, output='band_dos_element_orbitals_sp.png', scale_factor=5, color_list=None, legend=True, linewidth=0.75, band_color='black', unprojected_band_color='gray', unprojected_linewidth=0.6, figsize=(8, 6), width_ratios=[7, 3], erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, fontsize=8, annotations=['$\\\\uparrow$ ', '$\\\\downarrow$ '], annotation_xy=(0.0125, 0.98), save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None, fill=True, alpha=0.3, sigma=0.05)</code>","text":"<p>This function plots a spin polarized band structure projected onto specified [element, orbital] dict next to a spin polarized density of states projected onto the same [element, orbital] dict. The top figure highlights the spin up bands and the bottom figure highlights the spin down bands.</p> <p>Parameters:</p> Name Type Description Default <code>band_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the band structure</p> required <code>dos_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the density of states</p> required <code>element_orbital_dict</code> <code>dict[str</code> <p>list]): A dictionary that contains the individual elements and the corresponding orbitals to project onto. For example, if the user wants to project onto the s, py, pz, and px orbitals of In and the s orbital of As for and InAs structure then the dictionary would be {'In':[0,1,2,3], 'As':[0]}</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_dos_element_orbitals_sp.png'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> required <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure</p> <code>'black'</code> <code>unprojected_band_color</code> <code>str</code> <p>Color of the unprojected band</p> <code>'gray'</code> <code>unprojected_linewidth</code> <code>float</code> <p>Line width of the unprojected bands</p> <code>0.6</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(8, 6)</code> <code>width_ratios</code> <code>list / tuple</code> <p>Width ration of the band plot and dos plot.</p> <code>[7, 3]</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> required <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> required <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> required <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>8</code> <code>annotations</code> <code>list</code> <p>Annotations to put on the top and bottom (left and right) figures. By default it will show the spin up and spin down arrows.</p> <code>['$\\\\uparrow$ ', '$\\\\downarrow$ ']</code> <code>annotation_xy</code> <code>list / tuple</code> <p>Fractional (x, y) coordinated of the annotation location</p> <code>(0.0125, 0.98)</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_dos_element_orbitals_spin_polarized(\n    band_folder,\n    dos_folder,\n    element_orbital_dict,\n    output=\"band_dos_element_orbitals_sp.png\",\n    scale_factor=5,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    unprojected_band_color=\"gray\",\n    unprojected_linewidth=0.6,\n    figsize=(8, 6),\n    width_ratios=[7, 3],\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    fontsize=8,\n    annotations=[\"$\\\\uparrow$ \", \"$\\\\downarrow$ \"],\n    annotation_xy=(0.0125, 0.98),\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n    fill=True,\n    alpha=0.3,\n    sigma=0.05,\n):\n    \"\"\"\n    This function plots a spin polarized band structure projected onto specified [element, orbital] dict next to a spin\n    polarized density of states projected onto the same [element, orbital] dict. The top figure highlights the spin up\n    bands and the bottom figure highlights the spin down bands.\n\n    Parameters:\n        band_folder (str): This is the folder that contains the VASP files for the band structure\n        dos_folder (str): This is the folder that contains the VASP files for the density of states\n        element_orbital_dict (dict[str:list]): A dictionary that contains the individual elements and the corresponding\n            orbitals to project onto. For example, if the user wants to project onto the s, py, pz, and px orbitals\n            of In and the s orbital of As for and InAs structure then the dictionary would be {'In':[0,1,2,3], 'As':[0]}\n        output (str): File name of the resulting plot.\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background\n        band_color (string): Color of the plain band structure\n        unprojected_band_color (str): Color of the unprojected band\n        unprojected_linewidth (float): Line width of the unprojected bands\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        width_ratios (list / tuple): Width ration of the band plot and dos plot.\n        erange (list / tuple): Range of energy to show in the plot [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        annotations (list): Annotations to put on the top and bottom (left and right) figures.\n            By default it will show the spin up and spin down arrows.\n        annotation_xy (list / tuple): Fractional (x, y) coordinated of the annotation location\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        sigma (float): Standard deviation for gaussian filter\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    fig, ax = plt.subplots(\n        nrows=2,\n        ncols=2,\n        sharey=True,\n        figsize=figsize,\n        dpi=400,\n        gridspec_kw={\"width_ratios\": width_ratios},\n    )\n\n    (\n        ax_band_up,\n        ax_dos_up,\n        ax_band_down,\n        ax_dos_down,\n    ) = _figure_setup_band_dos_spin_polarized(\n        ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]]\n    )\n\n    band_up = Band(\n        folder=band_folder,\n        spin=\"up\",\n        projected=True,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n    )\n\n    band_down = Band(\n        folder=band_folder,\n        spin=\"down\",\n        projected=True,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n    )\n\n    dos_up = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=\"up\")\n    dos_down = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=\"down\")\n\n    bbox = dict(\n        boxstyle=\"round\", fc=\"white\", edgecolor=\"gray\", alpha=0.95, pad=0.3\n    )\n\n    ax_band_up.annotate(\n        annotations[0],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize + 1,\n    )\n    ax_band_down.annotate(\n        annotations[1],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize + 1,\n    )\n\n    band_up.plot_element_orbitals(\n        ax=ax_band_up,\n        scale_factor=scale_factor,\n        element_orbital_dict=element_orbital_dict,\n        color_list=color_list,\n        legend=False,\n        linewidth=linewidth,\n        band_color=band_color,\n    )\n\n    band_down.plot_plain(\n        sp_scale_factor=0,\n        ax=ax_band_up,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n    )\n\n    dos_up.plot_element_orbitals(\n        ax=ax_dos_up,\n        element_orbital_dict=element_orbital_dict,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=legend,\n        total=True,\n        erange=erange,\n    )\n\n    dos_down.plot_element_orbitals(\n        ax=ax_dos_up,\n        element_orbital_dict=element_orbital_dict,\n        fill=fill,\n        alpha=0.25 * alpha,\n        alpha_line=0.25 * alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=False,\n        total=True,\n        erange=erange,\n    )\n\n    band_down.plot_element_orbitals(\n        ax=ax_band_down,\n        scale_factor=scale_factor,\n        element_orbital_dict=element_orbital_dict,\n        color_list=color_list,\n        legend=False,\n        linewidth=linewidth,\n        band_color=band_color,\n    )\n\n    band_up.plot_plain(\n        sp_scale_factor=0,\n        ax=ax_band_down,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n    )\n\n    dos_down.plot_element_orbitals(\n        ax=ax_dos_down,\n        element_orbital_dict=element_orbital_dict,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=legend,\n        total=True,\n        erange=erange,\n    )\n\n    dos_up.plot_element_orbitals(\n        ax=ax_dos_down,\n        element_orbital_dict=element_orbital_dict,\n        fill=fill,\n        alpha=0.25 * alpha,\n        alpha_line=0.25 * alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=False,\n        total=True,\n        erange=erange,\n    )\n\n    fig.canvas.draw()\n    nbins = len(ax_dos_down.get_xticklabels())\n    ax_dos_down.xaxis.set_major_locator(\n        MaxNLocator(nbins=nbins - 1, prune=\"lower\")\n    )\n\n    plt.tight_layout(pad=0.4)\n    plt.subplots_adjust(wspace=0, hspace=0.05)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax_band_up, ax_dos_up, ax_band_down, ax_dos_down\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_dos_element_spd","title":"<code>band_dos_element_spd(band_folder, dos_folder, element_spd_dict, output='band_dos_element_spd.png', spin='up', scale_factor=5, color_list=None, legend=True, linewidth=0.75, band_color='black', figsize=(6, 3), width_ratios=[7, 3], erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, display_order=None, unfold=False, M=None, high_symm_points=None, fontsize=12, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None, fill=True, alpha=0.3, sigma=0.05)</code>","text":"<p>This function generates a s, p, d projected band structure on specific elements next to a projected density of states on the s, p, d orbitals for the same elements.</p> <p>Parameters:</p> Name Type Description Default <code>band_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the band structure</p> required <code>dos_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the density of states</p> required <code>element_spd_dict</code> <code>dict[str</code> <p>str]): A dictionary that contains the individual atoms and the corresponding orbitals to project onto. For example, if the user wants to project onto the s, p, d orbitals of In and the p orbitals of As for an InAs structure then the dictionary would be {'In':'spd', 'As':'p'}</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_dos_element_spd.png'</code> <code>spin</code> <code>str</code> <p>Choose which spin direction to parse. ('up' or 'down')</p> <code>'up'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(6, 3)</code> <code>width_ratios</code> <code>list / tuple</code> <p>Width ration of the band plot and dos plot.</p> <code>[7, 3]</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_dos_element_spd(\n    band_folder,\n    dos_folder,\n    element_spd_dict,\n    output=\"band_dos_element_spd.png\",\n    spin=\"up\",\n    scale_factor=5,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    figsize=(6, 3),\n    width_ratios=[7, 3],\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    display_order=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n    fill=True,\n    alpha=0.3,\n    sigma=0.05,\n):\n    \"\"\"\n    This function generates a s, p, d projected band structure on specific elements next to a\n    projected density of states on the s, p, d orbitals for the same elements.\n\n    Parameters:\n        band_folder (str): This is the folder that contains the VASP files for the band structure\n        dos_folder (str): This is the folder that contains the VASP files for the density of states\n        element_spd_dict (dict[str:str]): A dictionary that contains the individual atoms and the corresponding\n            orbitals to project onto. For example, if the user wants to project onto the s, p, d orbitals\n            of In and the p orbitals of As for an InAs structure then the dictionary would be {'In':'spd', 'As':'p'}\n        output (str): File name of the resulting plot.\n        spin (str): Choose which spin direction to parse. ('up' or 'down')\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background\n        band_color (string): Color of the plain band structure\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        width_ratios (list / tuple): Width ration of the band plot and dos plot.\n        erange (list / tuple): Range of energy to show in the plot [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        sigma (float): Standard deviation for gaussian filter\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    fig, ax = plt.subplots(\n        nrows=1,\n        ncols=2,\n        sharey=True,\n        figsize=figsize,\n        dpi=400,\n        gridspec_kw={\"width_ratios\": width_ratios},\n    )\n\n    ax1, ax2 = _figure_setup_band_dos(\n        ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]]\n    )\n\n    band = Band(\n        folder=band_folder,\n        spin=spin,\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    dos = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=spin)\n\n    band.plot_element_spd(\n        ax=ax1,\n        element_spd_dict=element_spd_dict,\n        display_order=display_order,\n        scale_factor=scale_factor,\n        color_list=color_list,\n        legend=False,\n        linewidth=linewidth,\n        band_color=band_color,\n        erange=erange,\n    )\n\n    dos.plot_element_spd(\n        ax=ax2,\n        element_spd_dict=element_spd_dict,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=legend,\n        total=True,\n        erange=erange,\n    )\n\n    fig.canvas.draw()\n    nbins = len(ax2.get_xticklabels())\n    ax2.xaxis.set_major_locator(MaxNLocator(nbins=nbins - 1, prune=\"lower\"))\n\n    plt.tight_layout(pad=0.4)\n    plt.subplots_adjust(wspace=0)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax1, ax2\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_dos_element_spd_spin_polarized","title":"<code>band_dos_element_spd_spin_polarized(band_folder, dos_folder, element_spd_dict, output='band_dos_element_spd_sp.png', scale_factor=5, color_list=None, legend=True, linewidth=0.75, band_color='black', unprojected_band_color='gray', unprojected_linewidth=0.6, figsize=(8, 6), width_ratios=[7, 3], erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, fontsize=8, annotations=['$\\\\uparrow$ ', '$\\\\downarrow$ '], annotation_xy=(0.0125, 0.98), save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None, fill=True, alpha=0.3, sigma=0.05)</code>","text":"<p>This function plots a spin polarized s, p, d projected band structure on a given element next to a spin polarized s, p, d projected density of states on the same element. The top figure highlights the spin up bands and the bottom figure highlights the spin down bands.</p> <p>Parameters:</p> Name Type Description Default <code>band_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the band structure</p> required <code>dos_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the density of states</p> required <code>element_spd_dict</code> <code>dict[str</code> <p>str]): A dictionary that contains the individual atoms and the corresponding orbitals to project onto. For example, if the user wants to project onto the s, p, d orbitals of In and the p orbitals of As for an InAs structure then the dictionary would be {'In':'spd', 'As':'p'}</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_dos_element_spd_sp.png'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> required <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure</p> <code>'black'</code> <code>unprojected_band_color</code> <code>str</code> <p>Color of the unprojected band</p> <code>'gray'</code> <code>unprojected_linewidth</code> <code>float</code> <p>Line width of the unprojected bands</p> <code>0.6</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(8, 6)</code> <code>width_ratios</code> <code>list / tuple</code> <p>Width ration of the band plot and dos plot.</p> <code>[7, 3]</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> required <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> required <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> required <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>8</code> <code>annotations</code> <code>list</code> <p>Annotations to put on the top and bottom (left and right) figures. By default it will show the spin up and spin down arrows.</p> <code>['$\\\\uparrow$ ', '$\\\\downarrow$ ']</code> <code>annotation_xy</code> <code>list / tuple</code> <p>Fractional (x, y) coordinated of the annotation location</p> <code>(0.0125, 0.98)</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_dos_element_spd_spin_polarized(\n    band_folder,\n    dos_folder,\n    element_spd_dict,\n    output=\"band_dos_element_spd_sp.png\",\n    scale_factor=5,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    unprojected_band_color=\"gray\",\n    unprojected_linewidth=0.6,\n    figsize=(8, 6),\n    width_ratios=[7, 3],\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    fontsize=8,\n    annotations=[\"$\\\\uparrow$ \", \"$\\\\downarrow$ \"],\n    annotation_xy=(0.0125, 0.98),\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n    fill=True,\n    alpha=0.3,\n    sigma=0.05,\n):\n    \"\"\"\n    This function plots a spin polarized s, p, d projected band structure on a given element next to a spin polarized\n    s, p, d projected density of states on the same element. The top figure highlights the spin up bands and the bottom\n    figure highlights the spin down bands.\n\n    Parameters:\n        band_folder (str): This is the folder that contains the VASP files for the band structure\n        dos_folder (str): This is the folder that contains the VASP files for the density of states\n        element_spd_dict (dict[str:str]): A dictionary that contains the individual atoms and the corresponding\n            orbitals to project onto. For example, if the user wants to project onto the s, p, d orbitals\n            of In and the p orbitals of As for an InAs structure then the dictionary would be {'In':'spd', 'As':'p'}\n        output (str): File name of the resulting plot.\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background\n        band_color (string): Color of the plain band structure\n        unprojected_band_color (str): Color of the unprojected band\n        unprojected_linewidth (float): Line width of the unprojected bands\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        width_ratios (list / tuple): Width ration of the band plot and dos plot.\n        erange (list / tuple): Range of energy to show in the plot [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        annotations (list): Annotations to put on the top and bottom (left and right) figures.\n            By default it will show the spin up and spin down arrows.\n        annotation_xy (list / tuple): Fractional (x, y) coordinated of the annotation location\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        sigma (float): Standard deviation for gaussian filter\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    fig, ax = plt.subplots(\n        nrows=2,\n        ncols=2,\n        sharey=True,\n        figsize=figsize,\n        dpi=400,\n        gridspec_kw={\"width_ratios\": width_ratios},\n    )\n\n    (\n        ax_band_up,\n        ax_dos_up,\n        ax_band_down,\n        ax_dos_down,\n    ) = _figure_setup_band_dos_spin_polarized(\n        ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]]\n    )\n\n    band_up = Band(\n        folder=band_folder,\n        spin=\"up\",\n        projected=True,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n    )\n\n    band_down = Band(\n        folder=band_folder,\n        spin=\"down\",\n        projected=True,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n    )\n\n    dos_up = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=\"up\")\n    dos_down = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=\"down\")\n\n    bbox = dict(\n        boxstyle=\"round\", fc=\"white\", edgecolor=\"gray\", alpha=0.95, pad=0.3\n    )\n\n    ax_band_up.annotate(\n        annotations[0],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize + 1,\n    )\n    ax_band_down.annotate(\n        annotations[1],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize + 1,\n    )\n\n    band_up.plot_element_spd(\n        ax=ax_band_up,\n        element_spd_dict=element_spd_dict,\n        scale_factor=scale_factor,\n        color_list=color_list,\n        legend=False,\n        linewidth=linewidth,\n        band_color=band_color,\n    )\n\n    band_down.plot_plain(\n        sp_scale_factor=0,\n        ax=ax_band_up,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n    )\n\n    dos_up.plot_element_spd(\n        ax=ax_dos_up,\n        element_spd_dict=element_spd_dict,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=legend,\n        total=True,\n        erange=erange,\n    )\n\n    dos_down.plot_element_spd(\n        ax=ax_dos_up,\n        element_spd_dict=element_spd_dict,\n        fill=fill,\n        alpha=0.25 * alpha,\n        alpha_line=0.25 * alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=False,\n        total=True,\n        erange=erange,\n    )\n\n    band_down.plot_element_spd(\n        ax=ax_band_down,\n        element_spd_dict=element_spd_dict,\n        scale_factor=scale_factor,\n        color_list=color_list,\n        legend=False,\n        linewidth=linewidth,\n        band_color=band_color,\n    )\n\n    band_up.plot_plain(\n        sp_scale_factor=0,\n        ax=ax_band_down,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n    )\n\n    dos_down.plot_element_spd(\n        ax=ax_dos_down,\n        element_spd_dict=element_spd_dict,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=legend,\n        total=True,\n        erange=erange,\n    )\n\n    dos_up.plot_element_spd(\n        ax=ax_dos_down,\n        element_spd_dict=element_spd_dict,\n        fill=fill,\n        alpha=0.25 * alpha,\n        alpha_line=0.25 * alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=False,\n        total=True,\n        erange=erange,\n    )\n\n    fig.canvas.draw()\n    nbins = len(ax_dos_down.get_xticklabels())\n    ax_dos_down.xaxis.set_major_locator(\n        MaxNLocator(nbins=nbins - 1, prune=\"lower\")\n    )\n\n    plt.tight_layout(pad=0.4)\n    plt.subplots_adjust(wspace=0, hspace=0.05)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax_band_up, ax_dos_up, ax_band_down, ax_dos_down\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_dos_elements","title":"<code>band_dos_elements(band_folder, dos_folder, elements, output='band_dos_elements.png', spin='up', scale_factor=5, color_list=None, legend=True, linewidth=0.75, band_color='black', figsize=(6, 3), width_ratios=[7, 3], erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, display_order=None, unfold=False, M=None, high_symm_points=None, fontsize=12, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None, fill=True, alpha=0.3, sigma=0.05)</code>","text":"<p>This function generates a projected band structure on specific elements next to a projected density of states on the same elements.</p> <p>Parameters:</p> Name Type Description Default <code>band_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the band structure</p> required <code>dos_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the density of states</p> required <code>elements</code> <code>list</code> <p>List of elements to project onto. The list should countain the corresponding element symbols</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_dos_elements.png'</code> <code>spin</code> <code>str</code> <p>Choose which spin direction to parse. ('up' or 'down')</p> <code>'up'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(6, 3)</code> <code>width_ratios</code> <code>list / tuple</code> <p>Width ration of the band plot and dos plot.</p> <code>[7, 3]</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_dos_elements(\n    band_folder,\n    dos_folder,\n    elements,\n    output=\"band_dos_elements.png\",\n    spin=\"up\",\n    scale_factor=5,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    figsize=(6, 3),\n    width_ratios=[7, 3],\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    display_order=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n    fill=True,\n    alpha=0.3,\n    sigma=0.05,\n):\n    \"\"\"\n    This function generates a projected band structure on specific elements next to a projected\n    density of states on the same elements.\n\n    Parameters:\n        band_folder (str): This is the folder that contains the VASP files for the band structure\n        dos_folder (str): This is the folder that contains the VASP files for the density of states\n        elements (list): List of elements to project onto. The list should countain the corresponding element symbols\n        output (str): File name of the resulting plot.\n        spin (str): Choose which spin direction to parse. ('up' or 'down')\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background\n        band_color (string): Color of the plain band structure\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        width_ratios (list / tuple): Width ration of the band plot and dos plot.\n        erange (list / tuple): Range of energy to show in the plot [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        sigma (float): Standard deviation for gaussian filter\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    fig, ax = plt.subplots(\n        nrows=1,\n        ncols=2,\n        sharey=True,\n        figsize=figsize,\n        dpi=400,\n        gridspec_kw={\"width_ratios\": width_ratios},\n    )\n\n    ax1, ax2 = _figure_setup_band_dos(\n        ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]]\n    )\n\n    band = Band(\n        folder=band_folder,\n        spin=spin,\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    dos = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=spin)\n\n    band.plot_elements(\n        ax=ax1,\n        elements=elements,\n        scale_factor=scale_factor,\n        color_list=color_list,\n        erange=erange,\n        display_order=display_order,\n        legend=False,\n        linewidth=linewidth,\n        band_color=band_color,\n    )\n\n    dos.plot_elements(\n        ax=ax2,\n        elements=elements,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=legend,\n        total=True,\n        erange=erange,\n    )\n\n    fig.canvas.draw()\n    nbins = len(ax2.get_xticklabels())\n    ax2.xaxis.set_major_locator(MaxNLocator(nbins=nbins - 1, prune=\"lower\"))\n\n    plt.tight_layout(pad=0.4)\n    plt.subplots_adjust(wspace=0)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax1, ax2\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_dos_elements_spin_polarized","title":"<code>band_dos_elements_spin_polarized(band_folder, dos_folder, elements, output='band_dos_elements_sp.png', scale_factor=5, color_list=None, legend=True, linewidth=0.75, band_color='black', unprojected_band_color='gray', unprojected_linewidth=0.6, figsize=(8, 6), width_ratios=[7, 3], erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, fontsize=8, annotations=['$\\\\uparrow$ ', '$\\\\downarrow$ '], annotation_xy=(0.0125, 0.98), save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None, fill=True, alpha=0.3, sigma=0.05)</code>","text":"<p>This function plots a spin polarized bandstructure projected onto specified elements in the structure next to its corresponding density of states projected onto the same elements. The top figure highlights the spin up bands and the bottom figure highlight the spin down bands.</p> <p>Parameters:</p> Name Type Description Default <code>band_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the band structure</p> required <code>dos_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the density of states</p> required <code>elements</code> <code>list</code> <p>List of elements to project onto. The list should countain the corresponding element symbols</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_dos_elements_sp.png'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> required <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure</p> <code>'black'</code> <code>unprojected_band_color</code> <code>str</code> <p>Color of the unprojected band</p> <code>'gray'</code> <code>unprojected_linewidth</code> <code>float</code> <p>Line width of the unprojected bands</p> <code>0.6</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(8, 6)</code> <code>width_ratios</code> <code>list / tuple</code> <p>Width ration of the band plot and dos plot.</p> <code>[7, 3]</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> required <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> required <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> required <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>8</code> <code>annotations</code> <code>list</code> <p>Annotations to put on the top and bottom (left and right) figures. By default it will show the spin up and spin down arrows.</p> <code>['$\\\\uparrow$ ', '$\\\\downarrow$ ']</code> <code>annotation_xy</code> <code>list / tuple</code> <p>Fractional (x, y) coordinated of the annotation location</p> <code>(0.0125, 0.98)</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_dos_elements_spin_polarized(\n    band_folder,\n    dos_folder,\n    elements,\n    output=\"band_dos_elements_sp.png\",\n    scale_factor=5,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    unprojected_band_color=\"gray\",\n    unprojected_linewidth=0.6,\n    figsize=(8, 6),\n    width_ratios=[7, 3],\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    fontsize=8,\n    annotations=[\"$\\\\uparrow$ \", \"$\\\\downarrow$ \"],\n    annotation_xy=(0.0125, 0.98),\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n    fill=True,\n    alpha=0.3,\n    sigma=0.05,\n):\n    \"\"\"\n    This function plots a spin polarized bandstructure projected onto specified elements in the structure next\n    to its corresponding density of states projected onto the same elements. The top figure highlights the\n    spin up bands and the bottom figure highlight the spin down bands.\n\n    Parameters:\n        band_folder (str): This is the folder that contains the VASP files for the band structure\n        dos_folder (str): This is the folder that contains the VASP files for the density of states\n        elements (list): List of elements to project onto. The list should countain the corresponding element symbols\n        output (str): File name of the resulting plot.\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background\n        band_color (string): Color of the plain band structure\n        unprojected_band_color (str): Color of the unprojected band\n        unprojected_linewidth (float): Line width of the unprojected bands\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        width_ratios (list / tuple): Width ration of the band plot and dos plot.\n        erange (list / tuple): Range of energy to show in the plot [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        annotations (list): Annotations to put on the top and bottom (left and right) figures.\n            By default it will show the spin up and spin down arrows.\n        annotation_xy (list / tuple): Fractional (x, y) coordinated of the annotation location\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        sigma (float): Standard deviation for gaussian filter\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    fig, ax = plt.subplots(\n        nrows=2,\n        ncols=2,\n        sharey=True,\n        figsize=figsize,\n        dpi=400,\n        gridspec_kw={\"width_ratios\": width_ratios},\n    )\n\n    (\n        ax_band_up,\n        ax_dos_up,\n        ax_band_down,\n        ax_dos_down,\n    ) = _figure_setup_band_dos_spin_polarized(\n        ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]]\n    )\n\n    band_up = Band(\n        folder=band_folder,\n        spin=\"up\",\n        projected=True,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n    )\n\n    band_down = Band(\n        folder=band_folder,\n        spin=\"down\",\n        projected=True,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n    )\n\n    dos_up = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=\"up\")\n    dos_down = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=\"down\")\n\n    bbox = dict(\n        boxstyle=\"round\", fc=\"white\", edgecolor=\"gray\", alpha=0.95, pad=0.3\n    )\n\n    ax_band_up.annotate(\n        annotations[0],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize + 1,\n    )\n    ax_band_down.annotate(\n        annotations[1],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize + 1,\n    )\n\n    band_up.plot_elements(\n        ax=ax_band_up,\n        scale_factor=scale_factor,\n        elements=elements,\n        color_list=color_list,\n        legend=False,\n        linewidth=linewidth,\n        band_color=band_color,\n    )\n\n    band_down.plot_plain(\n        sp_scale_factor=0,\n        ax=ax_band_up,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n    )\n\n    dos_up.plot_elements(\n        ax=ax_dos_up,\n        elements=elements,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=legend,\n        total=True,\n        erange=erange,\n    )\n\n    dos_down.plot_elements(\n        ax=ax_dos_up,\n        elements=elements,\n        fill=fill,\n        alpha=0.25 * alpha,\n        alpha_line=0.25 * alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=False,\n        total=True,\n        erange=erange,\n    )\n\n    band_down.plot_elements(\n        ax=ax_band_down,\n        scale_factor=scale_factor,\n        elements=elements,\n        color_list=color_list,\n        legend=False,\n        linewidth=linewidth,\n        band_color=band_color,\n    )\n\n    band_up.plot_plain(\n        sp_scale_factor=0,\n        ax=ax_band_down,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n    )\n\n    dos_down.plot_elements(\n        ax=ax_dos_down,\n        elements=elements,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=legend,\n        total=True,\n        erange=erange,\n    )\n\n    dos_up.plot_elements(\n        ax=ax_dos_down,\n        elements=elements,\n        fill=fill,\n        alpha=0.25 * alpha,\n        alpha_line=0.25 * alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=False,\n        total=True,\n        erange=erange,\n    )\n\n    fig.canvas.draw()\n    nbins = len(ax_dos_down.get_xticklabels())\n    ax_dos_down.xaxis.set_major_locator(\n        MaxNLocator(nbins=nbins - 1, prune=\"lower\")\n    )\n\n    plt.tight_layout(pad=0.4)\n    plt.subplots_adjust(wspace=0, hspace=0.05)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax_band_up, ax_dos_up, ax_band_down, ax_dos_down\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_dos_orbitals","title":"<code>band_dos_orbitals(band_folder, dos_folder, orbitals, output='band_dos_orbitals.png', spin='up', scale_factor=5, color_list=None, legend=True, linewidth=0.75, band_color='black', figsize=(6, 3), width_ratios=[7, 3], erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, display_order=None, unfold=False, M=None, high_symm_points=None, fontsize=12, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None, fill=True, alpha=0.3, sigma=0.05)</code>","text":"<p>This function generates a band structure projected on specific orbitals next to a projected density of states on the same orbitals.</p> <p>Parameters:</p> Name Type Description Default <code>band_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the band structure</p> required <code>dos_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the density of states</p> required <code>orbitals</code> <code>list</code> <p>List of orbitals to compare</p> <p>| 0 = s | 1 = py | 2 = pz | 3 = px | 4 = dxy | 5 = dyz | 6 = dz2 | 7 = dxz | 8 = dx2-y2 | 9 = fy3x2 | 10 = fxyz | 11 = fyz2 | 12 = fz3 | 13 = fxz2 | 14 = fzx3 | 15 = fx3</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_dos_orbitals.png'</code> <code>spin</code> <code>str</code> <p>Choose which spin direction to parse. ('up' or 'down')</p> <code>'up'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(6, 3)</code> <code>width_ratios</code> <code>list / tuple</code> <p>Width ration of the band plot and dos plot.</p> <code>[7, 3]</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_dos_orbitals(\n    band_folder,\n    dos_folder,\n    orbitals,\n    output=\"band_dos_orbitals.png\",\n    spin=\"up\",\n    scale_factor=5,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    figsize=(6, 3),\n    width_ratios=[7, 3],\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    display_order=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n    fill=True,\n    alpha=0.3,\n    sigma=0.05,\n):\n    \"\"\"\n    This function generates a band structure projected on specific orbitals next to a\n    projected density of states on the same orbitals.\n\n    Parameters:\n        band_folder (str): This is the folder that contains the VASP files for the band structure\n        dos_folder (str): This is the folder that contains the VASP files for the density of states\n        orbitals (list): List of orbitals to compare\n\n            | 0 = s\n            | 1 = py\n            | 2 = pz\n            | 3 = px\n            | 4 = dxy\n            | 5 = dyz\n            | 6 = dz2\n            | 7 = dxz\n            | 8 = dx2-y2\n            | 9 = fy3x2\n            | 10 = fxyz\n            | 11 = fyz2\n            | 12 = fz3\n            | 13 = fxz2\n            | 14 = fzx3\n            | 15 = fx3\n\n        output (str): File name of the resulting plot.\n        spin (str): Choose which spin direction to parse. ('up' or 'down')\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background\n        band_color (string): Color of the plain band structure\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        width_ratios (list / tuple): Width ration of the band plot and dos plot.\n        erange (list / tuple): Range of energy to show in the plot [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        sigma (float): Standard deviation for gaussian filter\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    fig, ax = plt.subplots(\n        nrows=1,\n        ncols=2,\n        sharey=True,\n        figsize=figsize,\n        dpi=400,\n        gridspec_kw={\"width_ratios\": width_ratios},\n    )\n\n    ax1, ax2 = _figure_setup_band_dos(\n        ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]]\n    )\n\n    band = Band(\n        folder=band_folder,\n        spin=spin,\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    dos = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=spin)\n\n    band.plot_orbitals(\n        ax=ax1,\n        orbitals=orbitals,\n        scale_factor=scale_factor,\n        color_list=color_list,\n        erange=erange,\n        display_order=display_order,\n        legend=False,\n        linewidth=linewidth,\n        band_color=band_color,\n    )\n\n    dos.plot_orbitals(\n        ax=ax2,\n        orbitals=orbitals,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=legend,\n        total=True,\n        erange=erange,\n    )\n\n    fig.canvas.draw()\n    nbins = len(ax2.get_xticklabels())\n    ax2.xaxis.set_major_locator(MaxNLocator(nbins=nbins - 1, prune=\"lower\"))\n\n    plt.tight_layout(pad=0.4)\n    plt.subplots_adjust(wspace=0)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax1, ax2\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_dos_orbitals_spin_polarized","title":"<code>band_dos_orbitals_spin_polarized(band_folder, dos_folder, orbitals, output='band_dos_orbitals_sp.png', scale_factor=5, color_list=None, legend=True, linewidth=0.75, band_color='black', unprojected_band_color='gray', unprojected_linewidth=0.6, figsize=(8, 6), width_ratios=[7, 3], erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, fontsize=8, annotations=['$\\\\uparrow$ ', '$\\\\downarrow$ '], annotation_xy=(0.0125, 0.98), save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None, fill=True, alpha=0.3, sigma=0.05)</code>","text":"<p>This function plots a spin polarized bandstructure projected onto specified orbitals next to its corresponding density of states projected onto the same orbitals. The top figure highlights the spin up bands and the bottom figure highlight the spin down bands.</p> <p>Parameters:</p> Name Type Description Default <code>band_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the band structure</p> required <code>dos_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the density of states</p> required <code>orbitals</code> <code>list</code> <p>List of orbitals to compare</p> <p>| 0 = s | 1 = py | 2 = pz | 3 = px | 4 = dxy | 5 = dyz | 6 = dz2 | 7 = dxz | 8 = dx2-y2 | 9 = fy3x2 | 10 = fxyz | 11 = fyz2 | 12 = fz3 | 13 = fxz2 | 14 = fzx3 | 15 = fx3</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_dos_orbitals_sp.png'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> required <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure</p> <code>'black'</code> <code>unprojected_band_color</code> <code>str</code> <p>Color of the unprojected band</p> <code>'gray'</code> <code>unprojected_linewidth</code> <code>float</code> <p>Line width of the unprojected bands</p> <code>0.6</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(8, 6)</code> <code>width_ratios</code> <code>list / tuple</code> <p>Width ration of the band plot and dos plot.</p> <code>[7, 3]</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> required <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> required <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> required <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>8</code> <code>annotations</code> <code>list</code> <p>Annotations to put on the top and bottom (left and right) figures. By default it will show the spin up and spin down arrows.</p> <code>['$\\\\uparrow$ ', '$\\\\downarrow$ ']</code> <code>annotation_xy</code> <code>list / tuple</code> <p>Fractional (x, y) coordinated of the annotation location</p> <code>(0.0125, 0.98)</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_dos_orbitals_spin_polarized(\n    band_folder,\n    dos_folder,\n    orbitals,\n    output=\"band_dos_orbitals_sp.png\",\n    scale_factor=5,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    unprojected_band_color=\"gray\",\n    unprojected_linewidth=0.6,\n    figsize=(8, 6),\n    width_ratios=[7, 3],\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    fontsize=8,\n    annotations=[\"$\\\\uparrow$ \", \"$\\\\downarrow$ \"],\n    annotation_xy=(0.0125, 0.98),\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n    fill=True,\n    alpha=0.3,\n    sigma=0.05,\n):\n    \"\"\"\n    This function plots a spin polarized bandstructure projected onto specified orbitals next to its\n    corresponding density of states projected onto the same orbitals. The top figure highlights the\n    spin up bands and the bottom figure highlight the spin down bands.\n\n    Parameters:\n        band_folder (str): This is the folder that contains the VASP files for the band structure\n        dos_folder (str): This is the folder that contains the VASP files for the density of states\n        orbitals (list): List of orbitals to compare\n\n            | 0 = s\n            | 1 = py\n            | 2 = pz\n            | 3 = px\n            | 4 = dxy\n            | 5 = dyz\n            | 6 = dz2\n            | 7 = dxz\n            | 8 = dx2-y2\n            | 9 = fy3x2\n            | 10 = fxyz\n            | 11 = fyz2\n            | 12 = fz3\n            | 13 = fxz2\n            | 14 = fzx3\n            | 15 = fx3\n\n        output (str): File name of the resulting plot.\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background\n        band_color (string): Color of the plain band structure\n        unprojected_band_color (str): Color of the unprojected band\n        unprojected_linewidth (float): Line width of the unprojected bands\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        width_ratios (list / tuple): Width ration of the band plot and dos plot.\n        erange (list / tuple): Range of energy to show in the plot [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        annotations (list): Annotations to put on the top and bottom (left and right) figures.\n            By default it will show the spin up and spin down arrows.\n        annotation_xy (list / tuple): Fractional (x, y) coordinated of the annotation location\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        sigma (float): Standard deviation for gaussian filter\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    fig, ax = plt.subplots(\n        nrows=2,\n        ncols=2,\n        sharey=True,\n        figsize=figsize,\n        dpi=400,\n        gridspec_kw={\"width_ratios\": width_ratios},\n    )\n\n    (\n        ax_band_up,\n        ax_dos_up,\n        ax_band_down,\n        ax_dos_down,\n    ) = _figure_setup_band_dos_spin_polarized(\n        ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]]\n    )\n\n    band_up = Band(\n        folder=band_folder,\n        spin=\"up\",\n        projected=True,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n    )\n\n    band_down = Band(\n        folder=band_folder,\n        spin=\"down\",\n        projected=True,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n    )\n\n    dos_up = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=\"up\")\n    dos_down = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=\"down\")\n\n    bbox = dict(\n        boxstyle=\"round\", fc=\"white\", edgecolor=\"gray\", alpha=0.95, pad=0.3\n    )\n\n    ax_band_up.annotate(\n        annotations[0],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize + 1,\n    )\n    ax_band_down.annotate(\n        annotations[1],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize + 1,\n    )\n\n    band_up.plot_orbitals(\n        ax=ax_band_up,\n        scale_factor=scale_factor,\n        orbitals=orbitals,\n        color_list=color_list,\n        legend=False,\n        linewidth=linewidth,\n        band_color=band_color,\n    )\n\n    band_down.plot_plain(\n        sp_scale_factor=0,\n        ax=ax_band_up,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n    )\n\n    dos_up.plot_orbitals(\n        ax=ax_dos_up,\n        orbitals=orbitals,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=legend,\n        total=True,\n        erange=erange,\n    )\n\n    dos_down.plot_orbitals(\n        ax=ax_dos_up,\n        orbitals=orbitals,\n        fill=fill,\n        alpha=0.25 * alpha,\n        alpha_line=0.25 * alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=False,\n        total=True,\n        erange=erange,\n    )\n\n    band_down.plot_orbitals(\n        ax=ax_band_down,\n        scale_factor=scale_factor,\n        orbitals=orbitals,\n        color_list=color_list,\n        legend=False,\n        linewidth=linewidth,\n        band_color=band_color,\n    )\n\n    band_up.plot_plain(\n        sp_scale_factor=0,\n        ax=ax_band_down,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n    )\n\n    dos_down.plot_orbitals(\n        ax=ax_dos_down,\n        orbitals=orbitals,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=legend,\n        total=True,\n        erange=erange,\n    )\n\n    dos_up.plot_orbitals(\n        ax=ax_dos_down,\n        orbitals=orbitals,\n        fill=fill,\n        alpha=0.25 * alpha,\n        alpha_line=0.25 * alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=False,\n        total=True,\n        erange=erange,\n    )\n\n    fig.canvas.draw()\n    nbins = len(ax_dos_down.get_xticklabels())\n    ax_dos_down.xaxis.set_major_locator(\n        MaxNLocator(nbins=nbins - 1, prune=\"lower\")\n    )\n\n    plt.tight_layout(pad=0.4)\n    plt.subplots_adjust(wspace=0, hspace=0.05)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax_band_up, ax_dos_up, ax_band_down, ax_dos_down\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_dos_plain","title":"<code>band_dos_plain(band_folder, dos_folder, output='band_dos_plain.png', spin='up', color='black', linewidth=1.25, linestyle='-', figsize=(6, 3), width_ratios=[7, 3], erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, unfold=False, M=None, high_symm_points=None, fontsize=12, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None, fill=True, alpha=0.3, sigma=0.05)</code>","text":"<p>This function plots a plain band structure and density of states next to eachother.</p> <p>Parameters:</p> Name Type Description Default <code>band_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the band structure calculation</p> required <code>dos_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the density of states calculation</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_dos_plain.png'</code> <code>spin</code> <code>str</code> <p>Choose which spin direction to parse. ('up' or 'down')</p> <code>'up'</code> <code>color</code> <code>str</code> <p>Color of the band structure lines</p> <code>'black'</code> <code>linewidth</code> <code>float</code> <p>Line width of the band structure lines</p> <code>1.25</code> <code>linestyle</code> <code>str</code> <p>Line style of the bands</p> <code>'-'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(6, 3)</code> <code>width_ratios</code> <code>list / tuple</code> <p>Width ration of the band plot and dos plot.</p> <code>[7, 3]</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_dos_plain(\n    band_folder,\n    dos_folder,\n    output=\"band_dos_plain.png\",\n    spin=\"up\",\n    color=\"black\",\n    linewidth=1.25,\n    linestyle=\"-\",\n    figsize=(6, 3),\n    width_ratios=[7, 3],\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n    fill=True,\n    alpha=0.3,\n    sigma=0.05,\n):\n    \"\"\"\n    This function plots a plain band structure and density of states next to eachother.\n\n    Parameters:\n        band_folder (str): This is the folder that contains the VASP files for the band structure calculation\n        dos_folder (str): This is the folder that contains the VASP files for the density of states calculation\n        output (str): File name of the resulting plot.\n        spin (str): Choose which spin direction to parse. ('up' or 'down')\n        color (str): Color of the band structure lines\n        linewidth (float): Line width of the band structure lines\n        linestyle (str): Line style of the bands\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        width_ratios (list / tuple): Width ration of the band plot and dos plot.\n        erange (list / tuple): Range of energy to show in the plot [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        sigma (float): Standard deviation for gaussian filter\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n    fig, ax = plt.subplots(\n        nrows=1,\n        ncols=2,\n        sharey=True,\n        figsize=figsize,\n        dpi=400,\n        gridspec_kw={\"width_ratios\": width_ratios},\n    )\n\n    ax1, ax2 = _figure_setup_band_dos(\n        ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]]\n    )\n\n    band = Band(\n        folder=band_folder,\n        spin=spin,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    dos = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=spin)\n\n    band.plot_plain(\n        ax=ax1,\n        color=color,\n        linewidth=linewidth,\n        linestyle=linestyle,\n    )\n\n    dos.plot_plain(\n        ax=ax2,\n        linewidth=linewidth,\n        fill=fill,\n        alpha=alpha,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color=color,\n        erange=erange,\n    )\n\n    fig.canvas.draw()\n    labels = ax2.get_xticklabels()\n    labels[0] = \"\"\n    ax2.set_xticklabels(labels)\n\n    plt.tight_layout(pad=0.4)\n    plt.subplots_adjust(wspace=0)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax1, ax2\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_dos_plain_spin_polarized","title":"<code>band_dos_plain_spin_polarized(band_folder, dos_folder, output='band_dos_plain_sp.png', up_color='black', down_color='red', linewidth=1.25, up_linestyle='-', down_linestyle=':', figsize=(6, 3), width_ratios=[7, 3], erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, unfold=False, M=None, high_symm_points=None, fontsize=12, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None, fill=True, alpha=0.3, sigma=0.05)</code>","text":"<p>This function plots a plain spin polarized band structure and density of states next to eachother.</p> <p>Parameters:</p> Name Type Description Default <code>band_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the band structure calculation</p> required <code>dos_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the density of states calculation</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_dos_plain_sp.png'</code> <code>up_color</code> <code>str</code> <p>Color of the spin up band structure lines</p> <code>'black'</code> <code>down_color</code> <code>str</code> <p>Color of the spin down band structure lines</p> <code>'red'</code> <code>linewidth</code> <code>float</code> <p>Line width of the band structure lines</p> <code>1.25</code> <code>up_linestyle</code> <code>str</code> <p>Line style of the spin up bands</p> <code>'-'</code> <code>down_linestyle</code> <code>str</code> <p>Line style of the spin down bands</p> <code>':'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(6, 3)</code> <code>width_ratios</code> <code>list / tuple</code> <p>Width ration of the band plot and dos plot.</p> <code>[7, 3]</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_dos_plain_spin_polarized(\n    band_folder,\n    dos_folder,\n    output=\"band_dos_plain_sp.png\",\n    up_color=\"black\",\n    down_color=\"red\",\n    linewidth=1.25,\n    up_linestyle=\"-\",\n    down_linestyle=\":\",\n    figsize=(6, 3),\n    width_ratios=[7, 3],\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n    fill=True,\n    alpha=0.3,\n    sigma=0.05,\n):\n    \"\"\"\n    This function plots a plain spin polarized band structure and density of states next to eachother.\n\n    Parameters:\n        band_folder (str): This is the folder that contains the VASP files for the band structure calculation\n        dos_folder (str): This is the folder that contains the VASP files for the density of states calculation\n        output (str): File name of the resulting plot.\n        up_color (str): Color of the spin up band structure lines\n        down_color (str): Color of the spin down band structure lines\n        linewidth (float): Line width of the band structure lines\n        up_linestyle (str): Line style of the spin up bands\n        down_linestyle (str): Line style of the spin down bands\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        width_ratios (list / tuple): Width ration of the band plot and dos plot.\n        erange (list / tuple): Range of energy to show in the plot [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        sigma (float): Standard deviation for gaussian filter\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n    fig, ax = plt.subplots(\n        nrows=1,\n        ncols=2,\n        sharey=True,\n        figsize=figsize,\n        dpi=400,\n        gridspec_kw={\"width_ratios\": width_ratios},\n    )\n\n    ax1, ax2 = _figure_setup_band_dos(\n        ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]]\n    )\n\n    band_up = Band(\n        folder=band_folder,\n        spin=\"up\",\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    band_down = Band(\n        folder=band_folder,\n        spin=\"down\",\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    dos_up = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=\"up\")\n    dos_down = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=\"down\")\n\n    band_up.plot_plain(\n        sp_scale_factor=0,\n        ax=ax1,\n        color=up_color,\n        linewidth=linewidth,\n        linestyle=up_linestyle,\n        erange=erange,\n    )\n\n    band_down.plot_plain(\n        sp_scale_factor=0,\n        ax=ax1,\n        color=down_color,\n        linewidth=linewidth,\n        linestyle=down_linestyle,\n        erange=erange,\n    )\n\n    dos_up.plot_plain(\n        ax=ax2,\n        linewidth=linewidth,\n        fill=fill,\n        alpha=alpha,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color=up_color,\n        erange=erange,\n    )\n\n    dos_down.plot_plain(\n        ax=ax2,\n        linewidth=linewidth,\n        fill=fill,\n        alpha=alpha,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color=down_color,\n        erange=erange,\n    )\n\n    fig.canvas.draw()\n    nbins = len(ax2.get_xticklabels())\n    ax2.xaxis.set_major_locator(MaxNLocator(nbins=nbins - 1, prune=\"lower\"))\n\n    plt.tight_layout(pad=0.4)\n    plt.subplots_adjust(wspace=0)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax1, ax2\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_dos_spd","title":"<code>band_dos_spd(band_folder, dos_folder, output='band_dos_spd.png', spin='up', scale_factor=5, orbitals='spd', color_list=None, legend=True, linewidth=0.75, band_color='black', figsize=(6, 3), width_ratios=[7, 3], erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, display_order=None, unfold=False, M=None, high_symm_points=None, fontsize=12, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None, fill=True, alpha=0.3, sigma=0.05)</code>","text":"<p>This function plots a s, p, d projected band structure next to and s, p, d projected density of states.</p> <p>Parameters:</p> Name Type Description Default <code>band_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the band structure</p> required <code>dos_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the density of states</p> required <code>orbitals</code> <code>str</code> <p>String that contains the s, p, or d orbitals that to project onto. The default is 'spd', if the user only wanted to project onto the p, and d orbitals than 'pd' should be passed in</p> <code>'spd'</code> <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_dos_spd.png'</code> <code>spin</code> <code>str</code> <p>Choose which spin direction to parse. ('up' or 'down')</p> <code>'up'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(6, 3)</code> <code>width_ratios</code> <code>list / tuple</code> <p>Width ration of the band plot and dos plot.</p> <code>[7, 3]</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_dos_spd(\n    band_folder,\n    dos_folder,\n    output=\"band_dos_spd.png\",\n    spin=\"up\",\n    scale_factor=5,\n    orbitals=\"spd\",\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    figsize=(6, 3),\n    width_ratios=[7, 3],\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    display_order=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n    fill=True,\n    alpha=0.3,\n    sigma=0.05,\n):\n    \"\"\"\n    This function plots a s, p, d projected band structure next to and s, p, d projected\n    density of states.\n\n    Parameters:\n        band_folder (str): This is the folder that contains the VASP files for the band structure\n        dos_folder (str): This is the folder that contains the VASP files for the density of states\n        orbitals (str): String that contains the s, p, or d orbitals that to project onto.\n            The default is 'spd', if the user only wanted to project onto the p, and d orbitals\n            than 'pd' should be passed in\n        output (str): File name of the resulting plot.\n        spin (str): Choose which spin direction to parse. ('up' or 'down')\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background\n        band_color (string): Color of the plain band structure\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        width_ratios (list / tuple): Width ration of the band plot and dos plot.\n        erange (list / tuple): Range of energy to show in the plot [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        sigma (float): Standard deviation for gaussian filter\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    fig, ax = plt.subplots(\n        nrows=1,\n        ncols=2,\n        sharey=True,\n        figsize=figsize,\n        dpi=400,\n        gridspec_kw={\"width_ratios\": width_ratios},\n    )\n\n    ax1, ax2 = _figure_setup_band_dos(\n        ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]]\n    )\n\n    band = Band(\n        folder=band_folder,\n        spin=spin,\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    dos = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=spin)\n\n    band.plot_spd(\n        ax=ax1,\n        scale_factor=scale_factor,\n        orbitals=orbitals,\n        erange=erange,\n        display_order=display_order,\n        color_list=color_list,\n        legend=False,\n        linewidth=linewidth,\n        band_color=band_color,\n    )\n\n    dos.plot_spd(\n        ax=ax2,\n        orbitals=orbitals,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=legend,\n        total=True,\n        erange=erange,\n    )\n\n    fig.canvas.draw()\n    nbins = len(ax2.get_xticklabels())\n    ax2.xaxis.set_major_locator(MaxNLocator(nbins=nbins - 1, prune=\"lower\"))\n\n    plt.tight_layout(pad=0.4)\n    plt.subplots_adjust(wspace=0)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax1, ax2\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_dos_spd_spin_polarized","title":"<code>band_dos_spd_spin_polarized(band_folder, dos_folder, output='band_dos_spd_sp.png', scale_factor=5, orbitals='spd', color_list=None, legend=True, linewidth=0.75, band_color='black', unprojected_band_color='gray', unprojected_linewidth=0.6, figsize=(8, 6), width_ratios=[7, 3], erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, display_order=None, unfold=False, M=None, high_symm_points=None, fontsize=8, annotations=['$\\\\uparrow$ ', '$\\\\downarrow$ '], annotation_xy=(0.0125, 0.98), save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None, fill=True, alpha=0.3, sigma=0.05)</code>","text":"<p>This function plots a spin polarized s, p, d projected band structure next to a spin polarized s, p, d projected density of states. The top figure highlights the spin up bands and the bottom figure highlights the spin down bands.</p> <p>Parameters:</p> Name Type Description Default <code>band_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the band structure</p> required <code>dos_folder</code> <code>str</code> <p>This is the folder that contains the VASP files for the density of states</p> required <code>orbitals</code> <code>str</code> <p>String that contains the s, p, or d orbitals that to project onto. The default is 'spd', if the user only wanted to project onto the p, and d orbitals than 'pd' should be passed in</p> <code>'spd'</code> <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_dos_spd_sp.png'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure</p> <code>'black'</code> <code>unprojected_band_color</code> <code>str</code> <p>Color of the unprojected band</p> <code>'gray'</code> <code>unprojected_linewidth</code> <code>float</code> <p>Line width of the unprojected bands</p> <code>0.6</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(8, 6)</code> <code>width_ratios</code> <code>list / tuple</code> <p>Width ration of the band plot and dos plot.</p> <code>[7, 3]</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>8</code> <code>annotations</code> <code>list</code> <p>Annotations to put on the top and bottom (left and right) figures. By default it will show the spin up and spin down arrows.</p> <code>['$\\\\uparrow$ ', '$\\\\downarrow$ ']</code> <code>annotation_xy</code> <code>list / tuple</code> <p>Fractional (x, y) coordinated of the annotation location</p> <code>(0.0125, 0.98)</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_dos_spd_spin_polarized(\n    band_folder,\n    dos_folder,\n    output=\"band_dos_spd_sp.png\",\n    scale_factor=5,\n    orbitals=\"spd\",\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    unprojected_band_color=\"gray\",\n    unprojected_linewidth=0.6,\n    figsize=(8, 6),\n    width_ratios=[7, 3],\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    display_order=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=8,\n    annotations=[\"$\\\\uparrow$ \", \"$\\\\downarrow$ \"],\n    annotation_xy=(0.0125, 0.98),\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n    fill=True,\n    alpha=0.3,\n    sigma=0.05,\n):\n    \"\"\"\n    This function plots a spin polarized s, p, d projected band structure next to a spin polarized s, p, d projected\n    density of states. The top figure highlights the spin up bands and the bottom figure highlights the spin down bands.\n\n    Parameters:\n        band_folder (str): This is the folder that contains the VASP files for the band structure\n        dos_folder (str): This is the folder that contains the VASP files for the density of states\n        orbitals (str): String that contains the s, p, or d orbitals that to project onto.\n            The default is 'spd', if the user only wanted to project onto the p, and d orbitals\n            than 'pd' should be passed in\n        output (str): File name of the resulting plot.\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background\n        band_color (string): Color of the plain band structure\n        unprojected_band_color (str): Color of the unprojected band\n        unprojected_linewidth (float): Line width of the unprojected bands\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        width_ratios (list / tuple): Width ration of the band plot and dos plot.\n        erange (list / tuple): Range of energy to show in the plot [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        annotations (list): Annotations to put on the top and bottom (left and right) figures.\n            By default it will show the spin up and spin down arrows.\n        annotation_xy (list / tuple): Fractional (x, y) coordinated of the annotation location\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        sigma (float): Standard deviation for gaussian filter\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    fig, ax = plt.subplots(\n        nrows=2,\n        ncols=2,\n        sharey=True,\n        figsize=figsize,\n        dpi=400,\n        gridspec_kw={\"width_ratios\": width_ratios},\n    )\n\n    (\n        ax_band_up,\n        ax_dos_up,\n        ax_band_down,\n        ax_dos_down,\n    ) = _figure_setup_band_dos_spin_polarized(\n        ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]]\n    )\n\n    band_up = Band(\n        folder=band_folder,\n        spin=\"up\",\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    band_down = Band(\n        folder=band_folder,\n        spin=\"down\",\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    dos_up = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=\"up\")\n    dos_down = Dos(shift_efermi=shift_efermi, folder=dos_folder, spin=\"down\")\n\n    bbox = dict(\n        boxstyle=\"round\", fc=\"white\", edgecolor=\"gray\", alpha=0.95, pad=0.3\n    )\n\n    ax_band_up.annotate(\n        annotations[0],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize + 1,\n    )\n    ax_band_down.annotate(\n        annotations[1],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize + 1,\n    )\n\n    band_up.plot_spd(\n        ax=ax_band_up,\n        scale_factor=scale_factor,\n        orbitals=orbitals,\n        color_list=color_list,\n        legend=False,\n        linewidth=linewidth,\n        band_color=band_color,\n        display_order=display_order,\n        erange=erange,\n    )\n\n    band_down.plot_plain(\n        sp_scale_factor=0,\n        ax=ax_band_up,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n        erange=erange,\n    )\n\n    dos_up.plot_spd(\n        ax=ax_dos_up,\n        orbitals=orbitals,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=legend,\n        total=True,\n        erange=erange,\n    )\n\n    dos_down.plot_spd(\n        ax=ax_dos_up,\n        orbitals=orbitals,\n        fill=fill,\n        alpha=0.25 * alpha,\n        alpha_line=0.25 * alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=False,\n        total=True,\n        erange=erange,\n    )\n\n    band_down.plot_spd(\n        ax=ax_band_down,\n        scale_factor=scale_factor,\n        orbitals=orbitals,\n        color_list=color_list,\n        legend=False,\n        linewidth=linewidth,\n        band_color=band_color,\n        display_order=display_order,\n        erange=erange,\n    )\n\n    band_up.plot_plain(\n        sp_scale_factor=0,\n        ax=ax_band_down,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n        erange=erange,\n    )\n\n    dos_down.plot_spd(\n        ax=ax_dos_down,\n        orbitals=orbitals,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=legend,\n        total=True,\n        erange=erange,\n    )\n\n    dos_up.plot_spd(\n        ax=ax_dos_down,\n        orbitals=orbitals,\n        fill=fill,\n        alpha=0.25 * alpha,\n        alpha_line=0.25 * alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=\"y\",\n        color_list=color_list,\n        legend=False,\n        total=True,\n        erange=erange,\n    )\n\n    fig.canvas.draw()\n    nbins = len(ax_dos_down.get_xticklabels())\n    ax_dos_down.xaxis.set_major_locator(\n        MaxNLocator(nbins=nbins - 1, prune=\"lower\")\n    )\n\n    plt.tight_layout(pad=0.4)\n    plt.subplots_adjust(wspace=0, hspace=0.05)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax_band_up, ax_dos_up, ax_band_down, ax_dos_down\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_element_orbital_spin_polarized","title":"<code>band_element_orbital_spin_polarized(folder, element_orbital_dict, output='band_element_orbital_sp.png', display_order=None, scale_factor=5, color_list=None, legend=True, linewidth=0.75, band_color='black', unprojected_band_color='gray', unprojected_linewidth=0.6, fontsize=12, annotations=['$\\\\uparrow$ ', '$\\\\downarrow$ '], annotation_xy=(0.02, 0.98), figsize=(4, 3), erange=[-6, 6], stack='vertical', kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, unfold=False, M=None, high_symm_points=None, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None)</code>","text":"<p>This function generates an element orbital spin polarized band structure. This will plot two plots stacked on top or eachother or next to eachother. The top or left plot will project on the spin up bands and the bottom or right plot will project onto the spin down bands.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>element_orbital_dict</code> <code>dict[str</code> <p>list]): A dictionary that contains the individual elements and the corresponding orbitals to project onto. For example, if the user wants to project onto the s, py, pz, and px orbitals of In and the s orbital of As for and InAs structure then the dictionary would be {'In':[0,1,2,3], 'As':[0]}</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_element_orbital_sp.png'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot.</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>unprojected_band_color</code> <code>str</code> <p>Color of the unprojected band</p> <code>'gray'</code> <code>unprojected_linewidth</code> <code>float</code> <p>Line width of the unprojected bands</p> <code>0.6</code> <code>annotations</code> <code>list</code> <p>Annotations to put on the top and bottom (left and right) figures. By default it will show the spin up and spin down arrows.</p> <code>['$\\\\uparrow$ ', '$\\\\downarrow$ ']</code> <code>annotation_xy</code> <code>list / tuple</code> <p>Fractional (x, y) coordinated of the annotation location</p> <code>(0.02, 0.98)</code> <code>stack</code> <code>str</code> <p>Determines how the plots are stacked (vertical or horizontal)</p> <code>'vertical'</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background.</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure.</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches. (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot. [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing. (fig, ax1, ax2)</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_element_orbital_spin_polarized(\n    folder,\n    element_orbital_dict,\n    output=\"band_element_orbital_sp.png\",\n    display_order=None,\n    scale_factor=5,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    unprojected_band_color=\"gray\",\n    unprojected_linewidth=0.6,\n    fontsize=12,\n    annotations=[\"$\\\\uparrow$ \", \"$\\\\downarrow$ \"],\n    annotation_xy=(0.02, 0.98),\n    figsize=(4, 3),\n    erange=[-6, 6],\n    stack=\"vertical\",\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n):\n    \"\"\"\n    This function generates an element orbital spin polarized band structure. This will plot two plots\n    stacked on top or eachother or next to eachother. The top or left plot will project on the\n    spin up bands and the bottom or right plot will project onto the spin down bands.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        element_orbital_dict (dict[str:list]): A dictionary that contains the individual elements and the corresponding\n            orbitals to project onto. For example, if the user wants to project onto the s, py, pz, and px orbitals\n            of In and the s orbital of As for and InAs structure then the dictionary would be {'In':[0,1,2,3], 'As':[0]}\n        output (str): File name of the resulting plot.\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot.\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        unprojected_band_color (str): Color of the unprojected band\n        unprojected_linewidth (float): Line width of the unprojected bands\n        annotations (list): Annotations to put on the top and bottom (left and right) figures.\n            By default it will show the spin up and spin down arrows.\n        annotation_xy (list / tuple): Fractional (x, y) coordinated of the annotation location\n        stack (str): Determines how the plots are stacked (vertical or horizontal)\n        linewidth (float): Line width of the plain band structure plotted in the background.\n        band_color (string): Color of the plain band structure.\n        figsize (list / tuple): Desired size of the image in inches. (width, height)\n        erange (list / tuple): Range of energy to show in the plot. [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing. (fig, ax1, ax2)\n    \"\"\"\n\n    band_up = Band(\n        folder=folder,\n        spin=\"up\",\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    band_down = Band(\n        folder=folder,\n        spin=\"down\",\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    if stack == \"vertical\":\n        fig = plt.figure(figsize=(figsize[0], 2 * figsize[1]), dpi=400)\n        ax1 = fig.add_subplot(211)\n        ax2 = fig.add_subplot(212)\n        _figure_setup(ax=ax1, fontsize=fontsize, ylim=[erange[0], erange[1]])\n        _figure_setup(ax=ax2, fontsize=fontsize, ylim=[erange[0], erange[1]])\n    elif stack == \"horizontal\":\n        fig = plt.figure(figsize=(2 * figsize[0], figsize[1]), dpi=400)\n        ax1 = fig.add_subplot(121)\n        ax2 = fig.add_subplot(122)\n        _figure_setup(ax=ax1, fontsize=fontsize, ylim=[erange[0], erange[1]])\n        _figure_setup(ax=ax2, fontsize=fontsize, ylim=[erange[0], erange[1]])\n\n    bbox = dict(\n        boxstyle=\"round\", fc=\"white\", edgecolor=\"gray\", alpha=0.95, pad=0.3\n    )\n    ax1.annotate(\n        annotations[0],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize,\n    )\n    ax2.annotate(\n        annotations[1],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize,\n    )\n\n    band_up.plot_element_orbitals(\n        ax=ax1,\n        element_orbital_dict=element_orbital_dict,\n        scale_factor=scale_factor,\n        display_order=display_order,\n        color_list=color_list,\n        legend=legend,\n        linewidth=linewidth,\n        band_color=band_color,\n        erange=erange,\n    )\n    band_down.plot_plain(\n        sp_scale_factor=0,\n        ax=ax1,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n        erange=erange,\n    )\n\n    band_down.plot_element_orbitals(\n        ax=ax2,\n        element_orbital_dict=element_orbital_dict,\n        scale_factor=scale_factor,\n        display_order=display_order,\n        color_list=color_list,\n        legend=legend,\n        linewidth=linewidth,\n        band_color=band_color,\n        erange=erange,\n    )\n    band_up.plot_plain(\n        sp_scale_factor=0,\n        ax=ax2,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax1, ax2\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_element_orbitals","title":"<code>band_element_orbitals(folder, element_orbital_dict, output='band_element_orbital.png', spin='up', display_order=None, scale_factor=5, color_list=None, legend=True, linewidth=0.75, band_color='black', figsize=(4, 3), erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, unfold=False, M=None, high_symm_points=None, fontsize=12, heatmap=False, bins=800, sigma=2, cmap='hot', vlinecolor='black', cbar=True, cbar_orientation='horizontal', powernorm=True, gamma=0.5, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None)</code>","text":"<p>This function generates a projected band structure on orbitals of specific elements.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>element_orbital_dict</code> <code>dict[str</code> <p>list]): A dictionary that contains the individual elements and the corresponding orbitals to project onto. For example, if the user wants to project onto the s, py, pz, and px orbitals of In and the s orbital of As for and InAs structure then the dictionary would be {'In':[0,1,2,3], 'As':[0]}</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_element_orbital.png'</code> <code>spin</code> <code>str</code> <p>Choose which spin direction to parse. ('up' or 'down')</p> <code>'up'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot.</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background.</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure.</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches. (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot. [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_element_orbitals(\n    folder,\n    element_orbital_dict,\n    output=\"band_element_orbital.png\",\n    spin=\"up\",\n    display_order=None,\n    scale_factor=5,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    figsize=(4, 3),\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=12,\n    heatmap=False,\n    bins=800,\n    sigma=2,\n    cmap=\"hot\",\n    vlinecolor=\"black\",\n    cbar=True,\n    cbar_orientation=\"horizontal\",\n    powernorm=True,\n    gamma=0.5,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n):\n    \"\"\"\n    This function generates a projected band structure on orbitals of specific elements.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        element_orbital_dict (dict[str:list]): A dictionary that contains the individual elements and the corresponding\n            orbitals to project onto. For example, if the user wants to project onto the s, py, pz, and px orbitals\n            of In and the s orbital of As for and InAs structure then the dictionary would be {'In':[0,1,2,3], 'As':[0]}\n        output (str): File name of the resulting plot.\n        spin (str): Choose which spin direction to parse. ('up' or 'down')\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot.\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background.\n        band_color (string): Color of the plain band structure.\n        figsize (list / tuple): Desired size of the image in inches. (width, height)\n        erange (list / tuple): Range of energy to show in the plot. [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    band = Band(\n        folder=folder,\n        spin=spin,\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    if heatmap:\n        legend = False\n        if cbar:\n            if cbar_orientation == \"horizontal\":\n                fig, (ax, cax) = plt.subplots(\n                    nrows=2,\n                    figsize=figsize,\n                    gridspec_kw={\"height_ratios\": [1, 0.05]},\n                    dpi=400,\n                    constrained_layout=True,\n                )\n            elif cbar_orientation == \"vertical\":\n                fig, (ax, cax) = plt.subplots(\n                    ncols=2,\n                    figsize=figsize,\n                    gridspec_kw={\"width_ratios\": [1, 0.05]},\n                    dpi=400,\n                    constrained_layout=True,\n                )\n            else:\n                raise (\n                    \"This is not a valid orientation please choose either horizontal or vertical\"\n                )\n        else:\n            fig = plt.figure(figsize=(figsize), dpi=400)\n            ax = fig.add_subplot(111)\n    else:\n        fig = plt.figure(figsize=(figsize), dpi=400)\n        ax = fig.add_subplot(111)\n\n    _figure_setup(ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]])\n    band.plot_element_orbitals(\n        ax=ax,\n        element_orbital_dict=element_orbital_dict,\n        scale_factor=scale_factor,\n        display_order=display_order,\n        color_list=color_list,\n        legend=legend,\n        linewidth=linewidth,\n        band_color=band_color,\n        erange=erange,\n        heatmap=heatmap,\n        bins=bins,\n        sigma=sigma,\n        cmap=cmap,\n        vlinecolor=vlinecolor,\n        powernorm=powernorm,\n        gamma=gamma,\n    )\n\n    if heatmap:\n        if cbar:\n            im = ax.collections[0]\n            min_val = im.norm.vmin\n            max_val = im.norm.vmax\n            cbar = fig.colorbar(im, cax=cax, orientation=cbar_orientation)\n            cbar.set_ticks([min_val, max_val])\n            cbar.set_ticklabels([\"min\", \"max\"])\n\n    if heatmap:\n        if not cbar:\n            fig.tight_layout(pad=0.4)\n    else:\n        fig.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_element_spd","title":"<code>band_element_spd(folder, element_spd_dict, output='band_element_spd.png', spin='up', display_order=None, scale_factor=5, color_list=None, legend=True, linewidth=0.75, band_color='black', figsize=(4, 3), erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, unfold=False, M=None, high_symm_points=None, fontsize=12, heatmap=False, bins=800, sigma=2, cmap='hot', vlinecolor='black', cbar=True, cbar_orientation='horizontal', powernorm=True, gamma=0.5, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None)</code>","text":"<p>This function generates a s, p, d projected band structure on specific elements.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>element_spd_dict</code> <code>dict[str</code> <p>str]): A dictionary that contains the individual atoms and the corresponding orbitals to project onto. For example, if the user wants to project onto the s, p, d orbitals of In and the p orbitals of As for an InAs structure then the dictionary would be {'In':'spd', 'As':'p'}</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_element_spd.png'</code> <code>spin</code> <code>str</code> <p>Choose which spin direction to parse. ('up' or 'down')</p> <code>'up'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot.</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background.</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure.</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches. (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot. [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_element_spd(\n    folder,\n    element_spd_dict,\n    output=\"band_element_spd.png\",\n    spin=\"up\",\n    display_order=None,\n    scale_factor=5,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    figsize=(4, 3),\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=12,\n    heatmap=False,\n    bins=800,\n    sigma=2,\n    cmap=\"hot\",\n    vlinecolor=\"black\",\n    cbar=True,\n    cbar_orientation=\"horizontal\",\n    powernorm=True,\n    gamma=0.5,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n):\n    \"\"\"\n    This function generates a s, p, d projected band structure on specific elements.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        element_spd_dict (dict[str:str]): A dictionary that contains the individual atoms and the corresponding\n            orbitals to project onto. For example, if the user wants to project onto the s, p, d orbitals\n            of In and the p orbitals of As for an InAs structure then the dictionary would be {'In':'spd', 'As':'p'}\n        output (str): File name of the resulting plot.\n        spin (str): Choose which spin direction to parse. ('up' or 'down')\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot.\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background.\n        band_color (string): Color of the plain band structure.\n        figsize (list / tuple): Desired size of the image in inches. (width, height)\n        erange (list / tuple): Range of energy to show in the plot. [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    band = Band(\n        folder=folder,\n        spin=spin,\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    if heatmap:\n        legend = False\n        if cbar:\n            if cbar_orientation == \"horizontal\":\n                fig, (ax, cax) = plt.subplots(\n                    nrows=2,\n                    figsize=figsize,\n                    gridspec_kw={\"height_ratios\": [1, 0.05]},\n                    dpi=400,\n                    constrained_layout=True,\n                )\n            elif cbar_orientation == \"vertical\":\n                fig, (ax, cax) = plt.subplots(\n                    ncols=2,\n                    figsize=figsize,\n                    gridspec_kw={\"width_ratios\": [1, 0.05]},\n                    dpi=400,\n                    constrained_layout=True,\n                )\n            else:\n                raise (\n                    \"This is not a valid orientation please choose either horizontal or vertical\"\n                )\n        else:\n            fig = plt.figure(figsize=(figsize), dpi=400)\n            ax = fig.add_subplot(111)\n    else:\n        fig = plt.figure(figsize=(figsize), dpi=400)\n        ax = fig.add_subplot(111)\n\n    _figure_setup(ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]])\n    band.plot_element_spd(\n        ax=ax,\n        element_spd_dict=element_spd_dict,\n        display_order=display_order,\n        scale_factor=scale_factor,\n        color_list=color_list,\n        legend=legend,\n        linewidth=linewidth,\n        band_color=band_color,\n        erange=erange,\n        heatmap=heatmap,\n        bins=bins,\n        sigma=sigma,\n        cmap=cmap,\n        vlinecolor=vlinecolor,\n        powernorm=powernorm,\n        gamma=gamma,\n    )\n\n    if heatmap:\n        if cbar:\n            im = ax.collections[0]\n            min_val = im.norm.vmin\n            max_val = im.norm.vmax\n            cbar = fig.colorbar(im, cax=cax, orientation=cbar_orientation)\n            cbar.set_ticks([min_val, max_val])\n            cbar.set_ticklabels([\"min\", \"max\"])\n\n    if heatmap:\n        if not cbar:\n            fig.tight_layout(pad=0.4)\n    else:\n        fig.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_element_spd_spin_polarized","title":"<code>band_element_spd_spin_polarized(folder, element_spd_dict, output='band_elements_spd_sp.png', display_order=None, scale_factor=5, color_list=None, legend=True, linewidth=0.75, band_color='black', unprojected_band_color='gray', unprojected_linewidth=0.6, fontsize=12, annotations=['$\\\\uparrow$ ', '$\\\\downarrow$ '], annotation_xy=(0.02, 0.98), figsize=(4, 3), erange=[-6, 6], stack='vertical', kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, unfold=False, M=None, high_symm_points=None, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None)</code>","text":"<p>This function generates a s, p, d spin polarized band structure on specific elements. This will plot two plots stacked on top or eachother or next to eachother. The top or left plot will project on the spin up bands and the bottom or right plot will project onto the spin down bands.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>element_spd_dict</code> <code>dict[str</code> <p>str]): A dictionary that contains the individual atoms and the corresponding orbitals to project onto. For example, if the user wants to project onto the s, p, d orbitals of In and the p orbitals of As for an InAs structure then the dictionary would be {'In':'spd', 'As':'p'}</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_elements_spd_sp.png'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot.</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>unprojected_band_color</code> <code>str</code> <p>Color of the unprojected band</p> <code>'gray'</code> <code>unprojected_linewidth</code> <code>float</code> <p>Line width of the unprojected bands</p> <code>0.6</code> <code>annotations</code> <code>list</code> <p>Annotations to put on the top and bottom (left and right) figures. By default it will show the spin up and spin down arrows.</p> <code>['$\\\\uparrow$ ', '$\\\\downarrow$ ']</code> <code>annotation_xy</code> <code>list / tuple</code> <p>Fractional (x, y) coordinated of the annotation location</p> <code>(0.02, 0.98)</code> <code>stack</code> <code>str</code> <p>Determines how the plots are stacked (vertical or horizontal)</p> <code>'vertical'</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background.</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure.</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches. (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot. [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing. (fig, ax1, ax2)</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_element_spd_spin_polarized(\n    folder,\n    element_spd_dict,\n    output=\"band_elements_spd_sp.png\",\n    display_order=None,\n    scale_factor=5,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    unprojected_band_color=\"gray\",\n    unprojected_linewidth=0.6,\n    fontsize=12,\n    annotations=[\"$\\\\uparrow$ \", \"$\\\\downarrow$ \"],\n    annotation_xy=(0.02, 0.98),\n    figsize=(4, 3),\n    erange=[-6, 6],\n    stack=\"vertical\",\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n):\n    \"\"\"\n    This function generates a s, p, d spin polarized band structure on specific elements. This will plot two plots\n    stacked on top or eachother or next to eachother. The top or left plot will project on the\n    spin up bands and the bottom or right plot will project onto the spin down bands.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        element_spd_dict (dict[str:str]): A dictionary that contains the individual atoms and the corresponding\n            orbitals to project onto. For example, if the user wants to project onto the s, p, d orbitals\n            of In and the p orbitals of As for an InAs structure then the dictionary would be {'In':'spd', 'As':'p'}\n        output (str): File name of the resulting plot.\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot.\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        unprojected_band_color (str): Color of the unprojected band\n        unprojected_linewidth (float): Line width of the unprojected bands\n        annotations (list): Annotations to put on the top and bottom (left and right) figures.\n            By default it will show the spin up and spin down arrows.\n        annotation_xy (list / tuple): Fractional (x, y) coordinated of the annotation location\n        stack (str): Determines how the plots are stacked (vertical or horizontal)\n        linewidth (float): Line width of the plain band structure plotted in the background.\n        band_color (string): Color of the plain band structure.\n        figsize (list / tuple): Desired size of the image in inches. (width, height)\n        erange (list / tuple): Range of energy to show in the plot. [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing. (fig, ax1, ax2)\n    \"\"\"\n\n    band_up = Band(\n        folder=folder,\n        spin=\"up\",\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    band_down = Band(\n        folder=folder,\n        spin=\"down\",\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    if stack == \"vertical\":\n        fig = plt.figure(figsize=(figsize[0], 2 * figsize[1]), dpi=400)\n        ax1 = fig.add_subplot(211)\n        ax2 = fig.add_subplot(212)\n        _figure_setup(ax=ax1, fontsize=fontsize, ylim=[erange[0], erange[1]])\n        _figure_setup(ax=ax2, fontsize=fontsize, ylim=[erange[0], erange[1]])\n    elif stack == \"horizontal\":\n        fig = plt.figure(figsize=(2 * figsize[0], figsize[1]), dpi=400)\n        ax1 = fig.add_subplot(121)\n        ax2 = fig.add_subplot(122)\n        _figure_setup(ax=ax1, fontsize=fontsize, ylim=[erange[0], erange[1]])\n        _figure_setup(ax=ax2, fontsize=fontsize, ylim=[erange[0], erange[1]])\n\n    bbox = dict(\n        boxstyle=\"round\", fc=\"white\", edgecolor=\"gray\", alpha=0.95, pad=0.3\n    )\n    ax1.annotate(\n        annotations[0],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize,\n    )\n    ax2.annotate(\n        annotations[1],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize,\n    )\n\n    band_up.plot_element_spd(\n        ax=ax1,\n        element_spd_dict=element_spd_dict,\n        display_order=display_order,\n        scale_factor=scale_factor,\n        color_list=color_list,\n        legend=legend,\n        linewidth=linewidth,\n        band_color=band_color,\n        erange=erange,\n    )\n    band_down.plot_plain(\n        sp_scale_factor=0,\n        ax=ax1,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n        erange=erange,\n    )\n\n    band_down.plot_element_spd(\n        ax=ax2,\n        element_spd_dict=element_spd_dict,\n        display_order=display_order,\n        scale_factor=scale_factor,\n        color_list=color_list,\n        legend=legend,\n        linewidth=linewidth,\n        band_color=band_color,\n        erange=erange,\n    )\n    band_up.plot_plain(\n        sp_scale_factor=0,\n        ax=ax2,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax1, ax2\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_elements","title":"<code>band_elements(folder, elements, output='band_elements.png', spin='up', scale_factor=5, display_order=None, color_list=None, legend=True, linewidth=0.75, band_color='black', figsize=(4, 3), erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, unfold=False, M=None, high_symm_points=None, fontsize=12, heatmap=False, bins=800, sigma=2, cmap='hot', vlinecolor='black', cbar=True, cbar_orientation='horizontal', powernorm=True, gamma=0.5, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None)</code>","text":"<p>This function generates a projected band structure on specific elements.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>elements</code> <code>list</code> <p>List of elements to project onto. The list should countain the corresponding element symbols</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_elements.png'</code> <code>spin</code> <code>str</code> <p>Choose which spin direction to parse. ('up' or 'down')</p> <code>'up'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot.</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background.</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure.</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches. (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot. [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_elements(\n    folder,\n    elements,\n    output=\"band_elements.png\",\n    spin=\"up\",\n    scale_factor=5,\n    display_order=None,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    figsize=(4, 3),\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=12,\n    heatmap=False,\n    bins=800,\n    sigma=2,\n    cmap=\"hot\",\n    vlinecolor=\"black\",\n    cbar=True,\n    cbar_orientation=\"horizontal\",\n    powernorm=True,\n    gamma=0.5,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n):\n    \"\"\"\n    This function generates a projected band structure on specific elements.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        elements (list): List of elements to project onto. The list should countain the corresponding element symbols\n        output (str): File name of the resulting plot.\n        spin (str): Choose which spin direction to parse. ('up' or 'down')\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot.\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background.\n        band_color (string): Color of the plain band structure.\n        figsize (list / tuple): Desired size of the image in inches. (width, height)\n        erange (list / tuple): Range of energy to show in the plot. [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    band = Band(\n        folder=folder,\n        spin=spin,\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    if heatmap:\n        legend = False\n        if cbar:\n            if cbar_orientation == \"horizontal\":\n                fig, (ax, cax) = plt.subplots(\n                    nrows=2,\n                    figsize=figsize,\n                    gridspec_kw={\"height_ratios\": [1, 0.05]},\n                    dpi=400,\n                    constrained_layout=True,\n                )\n            elif cbar_orientation == \"vertical\":\n                fig, (ax, cax) = plt.subplots(\n                    ncols=2,\n                    figsize=figsize,\n                    gridspec_kw={\"width_ratios\": [1, 0.05]},\n                    dpi=400,\n                    constrained_layout=True,\n                )\n            else:\n                raise (\n                    \"This is not a valid orientation please choose either horizontal or vertical\"\n                )\n        else:\n            fig = plt.figure(figsize=(figsize), dpi=400)\n            ax = fig.add_subplot(111)\n    else:\n        fig = plt.figure(figsize=(figsize), dpi=400)\n        ax = fig.add_subplot(111)\n\n    _figure_setup(ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]])\n    band.plot_elements(\n        ax=ax,\n        elements=elements,\n        scale_factor=scale_factor,\n        display_order=display_order,\n        color_list=color_list,\n        legend=legend,\n        linewidth=linewidth,\n        band_color=band_color,\n        erange=erange,\n        heatmap=heatmap,\n        bins=bins,\n        sigma=sigma,\n        cmap=cmap,\n        vlinecolor=vlinecolor,\n        powernorm=powernorm,\n        gamma=gamma,\n    )\n\n    if heatmap:\n        if cbar:\n            im = ax.collections[0]\n            min_val = im.norm.vmin\n            max_val = im.norm.vmax\n            cbar = fig.colorbar(im, cax=cax, orientation=cbar_orientation)\n            cbar.set_ticks([min_val, max_val])\n            cbar.set_ticklabels([\"min\", \"max\"])\n\n    if heatmap:\n        if not cbar:\n            fig.tight_layout(pad=0.4)\n    else:\n        fig.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_elements_spin_polarized","title":"<code>band_elements_spin_polarized(folder, elements, output='band_elements_sp.png', scale_factor=5, display_order=None, color_list=None, legend=True, linewidth=0.75, band_color='black', unprojected_band_color='gray', figsize=(4, 3), erange=[-6, 6], stack='vertical', kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, unfold=False, M=None, high_symm_points=None, fontsize=12, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None)</code>","text":"<p>This function generates an element spin polarized band structure. This will plot two plots stacked on top or eachother or next to eachother. The top or left plot will project on the spin up bands and the bottom or right plot will project onto the spin down bands.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>elements</code> <code>list</code> <p>List of elements to project onto. The list should countain the corresponding element symbols</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_elements_sp.png'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot.</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>unprojected_band_color</code> <code>str</code> <p>Color of the unprojected band</p> <code>'gray'</code> <code>unprojected_linewidth</code> <code>float</code> <p>Line width of the unprojected bands</p> required <code>annotations</code> <code>list</code> <p>Annotations to put on the top and bottom (left and right) figures. By default it will show the spin up and spin down arrows.</p> required <code>annotation_xy</code> <code>list / tuple</code> <p>Fractional (x, y) coordinated of the annotation location</p> required <code>stack</code> <code>str</code> <p>Determines how the plots are stacked (vertical or horizontal)</p> <code>'vertical'</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background.</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure.</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches. (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot. [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing. (fig, ax1, ax2)</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_elements_spin_polarized(\n    folder,\n    elements,\n    output=\"band_elements_sp.png\",\n    scale_factor=5,\n    display_order=None,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    unprojected_band_color=\"gray\",\n    figsize=(4, 3),\n    erange=[-6, 6],\n    stack=\"vertical\",\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n):\n    \"\"\"\n    This function generates an element spin polarized band structure. This will plot two plots\n    stacked on top or eachother or next to eachother. The top or left plot will project on the\n    spin up bands and the bottom or right plot will project onto the spin down bands.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        elements (list): List of elements to project onto. The list should countain the corresponding element symbols\n        output (str): File name of the resulting plot.\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot.\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        unprojected_band_color (str): Color of the unprojected band\n        unprojected_linewidth (float): Line width of the unprojected bands\n        annotations (list): Annotations to put on the top and bottom (left and right) figures.\n            By default it will show the spin up and spin down arrows.\n        annotation_xy (list / tuple): Fractional (x, y) coordinated of the annotation location\n        stack (str): Determines how the plots are stacked (vertical or horizontal)\n        linewidth (float): Line width of the plain band structure plotted in the background.\n        band_color (string): Color of the plain band structure.\n        figsize (list / tuple): Desired size of the image in inches. (width, height)\n        erange (list / tuple): Range of energy to show in the plot. [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing. (fig, ax1, ax2)\n    \"\"\"\n\n    band_up = Band(\n        folder=folder,\n        spin=\"up\",\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    band_down = Band(\n        folder=folder,\n        spin=\"down\",\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    if stack == \"vertical\":\n        fig = plt.figure(figsize=(figsize[0], 2 * figsize[1]), dpi=400)\n        ax1 = fig.add_subplot(211)\n        ax2 = fig.add_subplot(212)\n        _figure_setup(ax=ax1, fontsize=fontsize, ylim=[erange[0], erange[1]])\n        _figure_setup(ax=ax2, fontsize=fontsize, ylim=[erange[0], erange[1]])\n    elif stack == \"horizontal\":\n        fig = plt.figure(figsize=(2 * figsize[0], figsize[1]), dpi=400)\n        ax1 = fig.add_subplot(121)\n        ax2 = fig.add_subplot(122)\n        _figure_setup(ax=ax1, fontsize=fontsize, ylim=[erange[0], erange[1]])\n        _figure_setup(ax=ax2, fontsize=fontsize, ylim=[erange[0], erange[1]])\n\n    bbox = dict(boxstyle=\"round\", fc=\"white\")\n    ax1.annotate(\n        \"$\\\\uparrow$ \",\n        xy=(0.02, 0.98),\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n    )\n    ax2.annotate(\n        \"$\\\\downarrow$ \",\n        xy=(0.02, 0.98),\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n    )\n\n    band_up.plot_elements(\n        ax=ax1,\n        elements=elements,\n        scale_factor=scale_factor,\n        display_order=display_order,\n        color_list=color_list,\n        legend=legend,\n        linewidth=linewidth,\n        band_color=band_color,\n        erange=erange,\n    )\n    band_up.plot_plain(\n        sp_scale_factor=0,\n        ax=ax1,\n        color=unprojected_band_color,\n        linewidth=0.5,\n        erange=erange,\n    )\n\n    band_down.plot_elements(\n        ax=ax2,\n        elements=elements,\n        scale_factor=scale_factor,\n        display_order=display_order,\n        color_list=color_list,\n        legend=legend,\n        linewidth=linewidth,\n        band_color=band_color,\n        erange=erange,\n    )\n    band_down.plot_plain(\n        sp_scale_factor=0,\n        ax=ax2,\n        color=unprojected_band_color,\n        linewidth=0.5,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax1, ax2\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_orbitals","title":"<code>band_orbitals(folder, orbitals, output='band_orbital.png', spin='up', scale_factor=5, display_order=None, color_list=None, legend=True, linewidth=0.75, band_color='black', figsize=(4, 3), erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, unfold=False, M=None, high_symm_points=None, fontsize=12, heatmap=False, bins=800, sigma=2, cmap='hot', vlinecolor='black', cbar=True, cbar_orientation='horizontal', powernorm=True, gamma=0.5, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None)</code>","text":"<p>This function generates a projected band structure on specific orbitals.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>orbitals</code> <code>list</code> <p>List of orbitals to compare</p> <p>| 0 = s | 1 = py | 2 = pz | 3 = px | 4 = dxy | 5 = dyz | 6 = dz2 | 7 = dxz | 8 = dx2-y2 | 9 = fy3x2 | 10 = fxyz | 11 = fyz2 | 12 = fz3 | 13 = fxz2 | 14 = fzx3 | 15 = fx3</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_orbital.png'</code> <code>spin</code> <code>str</code> <p>Choose which spin direction to parse. ('up' or 'down')</p> <code>'up'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot.</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background.</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure.</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches. (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot. [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_orbitals(\n    folder,\n    orbitals,\n    output=\"band_orbital.png\",\n    spin=\"up\",\n    scale_factor=5,\n    display_order=None,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    figsize=(4, 3),\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=12,\n    heatmap=False,\n    bins=800,\n    sigma=2,\n    cmap=\"hot\",\n    vlinecolor=\"black\",\n    cbar=True,\n    cbar_orientation=\"horizontal\",\n    powernorm=True,\n    gamma=0.5,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n):\n    \"\"\"\n    This function generates a projected band structure on specific orbitals.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        orbitals (list): List of orbitals to compare\n\n            | 0 = s\n            | 1 = py\n            | 2 = pz\n            | 3 = px\n            | 4 = dxy\n            | 5 = dyz\n            | 6 = dz2\n            | 7 = dxz\n            | 8 = dx2-y2\n            | 9 = fy3x2\n            | 10 = fxyz\n            | 11 = fyz2\n            | 12 = fz3\n            | 13 = fxz2\n            | 14 = fzx3\n            | 15 = fx3\n\n        output (str): File name of the resulting plot.\n        spin (str): Choose which spin direction to parse. ('up' or 'down')\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot.\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background.\n        band_color (string): Color of the plain band structure.\n        figsize (list / tuple): Desired size of the image in inches. (width, height)\n        erange (list / tuple): Range of energy to show in the plot. [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    band = Band(\n        folder=folder,\n        spin=spin,\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    if heatmap:\n        legend = False\n        if cbar:\n            if cbar_orientation == \"horizontal\":\n                fig, (ax, cax) = plt.subplots(\n                    nrows=2,\n                    figsize=figsize,\n                    gridspec_kw={\"height_ratios\": [1, 0.05]},\n                    dpi=400,\n                    constrained_layout=True,\n                )\n            elif cbar_orientation == \"vertical\":\n                fig, (ax, cax) = plt.subplots(\n                    ncols=2,\n                    figsize=figsize,\n                    gridspec_kw={\"width_ratios\": [1, 0.05]},\n                    dpi=400,\n                    constrained_layout=True,\n                )\n            else:\n                raise (\n                    \"This is not a valid orientation please choose either horizontal or vertical\"\n                )\n        else:\n            fig = plt.figure(figsize=(figsize), dpi=400)\n            ax = fig.add_subplot(111)\n    else:\n        fig = plt.figure(figsize=(figsize), dpi=400)\n        ax = fig.add_subplot(111)\n\n    _figure_setup(ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]])\n    band.plot_orbitals(\n        ax=ax,\n        orbitals=orbitals,\n        scale_factor=scale_factor,\n        erange=erange,\n        display_order=display_order,\n        color_list=color_list,\n        legend=legend,\n        linewidth=linewidth,\n        band_color=band_color,\n        heatmap=heatmap,\n        bins=bins,\n        sigma=sigma,\n        cmap=cmap,\n        vlinecolor=vlinecolor,\n        powernorm=powernorm,\n        gamma=gamma,\n    )\n\n    if heatmap:\n        if cbar:\n            im = ax.collections[0]\n            min_val = im.norm.vmin\n            max_val = im.norm.vmax\n            cbar = fig.colorbar(im, cax=cax, orientation=cbar_orientation)\n            cbar.set_ticks([min_val, max_val])\n            cbar.set_ticklabels([\"min\", \"max\"])\n\n    if heatmap:\n        if not cbar:\n            fig.tight_layout(pad=0.4)\n    else:\n        fig.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_orbitals_spin_polarized","title":"<code>band_orbitals_spin_polarized(folder, orbitals, output='band_orbitals_sp.png', scale_factor=5, display_order=None, color_list=None, legend=True, linewidth=0.75, band_color='black', unprojected_band_color='gray', figsize=(4, 3), erange=[-6, 6], stack='vertical', kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, unfold=False, M=None, high_symm_points=None, fontsize=12, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None)</code>","text":"<p>This function generates an orbital spin polarized band structure. This will plot two plots stacked on top or eachother or next to eachother. The top or left plot will project on the spin up bands and the bottom or right plot will project onto the spin down bands.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>orbitals</code> <code>list</code> <p>List of orbitals to compare</p> <p>| 0 = s | 1 = py | 2 = pz | 3 = px | 4 = dxy | 5 = dyz | 6 = dz2 | 7 = dxz | 8 = dx2-y2 | 9 = fy3x2 | 10 = fxyz | 11 = fyz2 | 12 = fz3 | 13 = fxz2 | 14 = fzx3 | 15 = fx3</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_orbitals_sp.png'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot.</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>unprojected_band_color</code> <code>str</code> <p>Color of the unprojected band</p> <code>'gray'</code> <code>unprojected_linewidth</code> <code>float</code> <p>Line width of the unprojected bands</p> required <code>annotations</code> <code>list</code> <p>Annotations to put on the top and bottom (left and right) figures. By default it will show the spin up and spin down arrows.</p> required <code>annotation_xy</code> <code>list / tuple</code> <p>Fractional (x, y) coordinated of the annotation location</p> required <code>stack</code> <code>str</code> <p>Determines how the plots are stacked (vertical or horizontal)</p> <code>'vertical'</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background.</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure.</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches. (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot. [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing. (fig, ax1, ax2)</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_orbitals_spin_polarized(\n    folder,\n    orbitals,\n    output=\"band_orbitals_sp.png\",\n    scale_factor=5,\n    display_order=None,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    unprojected_band_color=\"gray\",\n    figsize=(4, 3),\n    erange=[-6, 6],\n    stack=\"vertical\",\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n):\n    \"\"\"\n    This function generates an orbital spin polarized band structure. This will plot two plots\n    stacked on top or eachother or next to eachother. The top or left plot will project on the\n    spin up bands and the bottom or right plot will project onto the spin down bands.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        orbitals (list): List of orbitals to compare\n\n            | 0 = s\n            | 1 = py\n            | 2 = pz\n            | 3 = px\n            | 4 = dxy\n            | 5 = dyz\n            | 6 = dz2\n            | 7 = dxz\n            | 8 = dx2-y2\n            | 9 = fy3x2\n            | 10 = fxyz\n            | 11 = fyz2\n            | 12 = fz3\n            | 13 = fxz2\n            | 14 = fzx3\n            | 15 = fx3\n\n        output (str): File name of the resulting plot.\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot.\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        unprojected_band_color (str): Color of the unprojected band\n        unprojected_linewidth (float): Line width of the unprojected bands\n        annotations (list): Annotations to put on the top and bottom (left and right) figures.\n            By default it will show the spin up and spin down arrows.\n        annotation_xy (list / tuple): Fractional (x, y) coordinated of the annotation location\n        stack (str): Determines how the plots are stacked (vertical or horizontal)\n        linewidth (float): Line width of the plain band structure plotted in the background.\n        band_color (string): Color of the plain band structure.\n        figsize (list / tuple): Desired size of the image in inches. (width, height)\n        erange (list / tuple): Range of energy to show in the plot. [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing. (fig, ax1, ax2)\n    \"\"\"\n\n    band_up = Band(\n        folder=folder,\n        spin=\"up\",\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    band_down = Band(\n        folder=folder,\n        spin=\"down\",\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    if stack == \"vertical\":\n        fig = plt.figure(figsize=(figsize[0], 2 * figsize[1]), dpi=400)\n        ax1 = fig.add_subplot(211)\n        ax2 = fig.add_subplot(212)\n        _figure_setup(ax=ax1, fontsize=fontsize, ylim=[erange[0], erange[1]])\n        _figure_setup(ax=ax2, fontsize=fontsize, ylim=[erange[0], erange[1]])\n    elif stack == \"horizontal\":\n        fig = plt.figure(figsize=(2 * figsize[0], figsize[1]), dpi=400)\n        ax1 = fig.add_subplot(121)\n        ax2 = fig.add_subplot(122)\n        _figure_setup(ax=ax1, fontsize=fontsize, ylim=[erange[0], erange[1]])\n        _figure_setup(ax=ax2, fontsize=fontsize, ylim=[erange[0], erange[1]])\n\n    bbox = dict(boxstyle=\"round\", fc=\"white\")\n    ax1.annotate(\n        \"$\\\\uparrow$ \",\n        xy=(0.02, 0.98),\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n    )\n    ax2.annotate(\n        \"$\\\\downarrow$ \",\n        xy=(0.02, 0.98),\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n    )\n\n    band_up.plot_orbitals(\n        ax=ax1,\n        orbitals=orbitals,\n        scale_factor=scale_factor,\n        erange=erange,\n        display_order=display_order,\n        color_list=color_list,\n        legend=legend,\n        linewidth=linewidth,\n        band_color=band_color,\n    )\n    band_up.plot_plain(\n        sp_scale_factor=0,\n        ax=ax1,\n        color=unprojected_band_color,\n        linewidth=0.5,\n        erange=erange,\n    )\n\n    band_down.plot_orbitals(\n        ax=ax2,\n        orbitals=orbitals,\n        scale_factor=scale_factor,\n        erange=erange,\n        display_order=display_order,\n        color_list=color_list,\n        legend=legend,\n        linewidth=linewidth,\n        band_color=band_color,\n    )\n    band_down.plot_plain(\n        sp_scale_factor=0,\n        ax=ax2,\n        color=unprojected_band_color,\n        linewidth=0.5,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax1, ax2\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_plain","title":"<code>band_plain(folder, output='band_plain.png', spin='up', color='black', linewidth=1.25, linestyle='-', figsize=(4, 3), erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, unfold=False, M=None, high_symm_points=None, fontsize=12, scale_factor=5, heatmap=False, bins=1000, sigma=2, cmap='hot', vlinecolor='black', cbar=True, cbar_orientation='horizontal', powernorm=True, gamma=0.7, save=True, shift_efermi=0, interpolate=False, new_n=200, highlight_band=False, highlight_band_color='red', band_index=None, soc_axis=None, sp_scale_factor=5, sp_color='red')</code>","text":"<p>This function generates a plain band structure</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_plain.png'</code> <code>spin</code> <code>str</code> <p>Choose which spin direction to parse. ('up' or 'down')</p> <code>'up'</code> <code>color</code> <code>str</code> <p>Color of the band structure lines</p> <code>'black'</code> <code>linewidth</code> <code>float</code> <p>Line width of the band structure lines</p> <code>1.25</code> <code>linestyle</code> <code>str</code> <p>Line style of the bands</p> <code>'-'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale scatter points in unfolded plots.</p> <code>5</code> <code>heatmap</code> <code>bool</code> <p>Determines if an unfolded plot is plotted as a heat map. Only valid from unfolded plots.</p> <code>False</code> <code>bins</code> <code>int</code> <p>number of bins included in the histogram. More bin will result in higher resolution.</p> <code>1000</code> <code>sigma</code> <code>float</code> <p>Value used to smooth the heatmap.</p> <code>2</code> <code>cmap</code> <code>str</code> <p>Matplotlib colormap for the unfolded heatmap.</p> <code>'hot'</code> <code>vlinecolor</code> <code>str</code> <p>Color of the vertical lines in the band structure useful for heatmaps when there is a dark background color.</p> <code>'black'</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_plain(\n    folder,\n    output=\"band_plain.png\",\n    spin=\"up\",\n    color=\"black\",\n    linewidth=1.25,\n    linestyle=\"-\",\n    figsize=(4, 3),\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=12,\n    scale_factor=5,\n    heatmap=False,\n    bins=1000,\n    sigma=2,\n    cmap=\"hot\",\n    vlinecolor=\"black\",\n    cbar=True,\n    cbar_orientation=\"horizontal\",\n    powernorm=True,\n    gamma=0.7,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    highlight_band=False,\n    highlight_band_color=\"red\",\n    band_index=None,\n    soc_axis=None,\n    sp_scale_factor=5,\n    sp_color=\"red\",\n):\n    \"\"\"\n    This function generates a plain band structure\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        output (str): File name of the resulting plot.\n        spin (str): Choose which spin direction to parse. ('up' or 'down')\n        color (str): Color of the band structure lines\n        linewidth (float): Line width of the band structure lines\n        linestyle (str): Line style of the bands\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        erange (list / tuple): Range of energy to show in the plot [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        scale_factor (float): Factor to scale scatter points in unfolded plots.\n        heatmap (bool): Determines if an unfolded plot is plotted as a heat map. Only valid from unfolded plots.\n        bins (int): number of bins included in the histogram. More bin will result in higher resolution.\n        sigma (float): Value used to smooth the heatmap.\n        cmap (str): Matplotlib colormap for the unfolded heatmap.\n        vlinecolor (str): Color of the vertical lines in the band structure\n            useful for heatmaps when there is a dark background color.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    band = Band(\n        folder=folder,\n        spin=spin,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n        soc_axis=soc_axis,\n    )\n\n    if heatmap:\n        if cbar:\n            if cbar_orientation == \"horizontal\":\n                fig, (ax, cax) = plt.subplots(\n                    nrows=2,\n                    figsize=figsize,\n                    gridspec_kw={\"height_ratios\": [1, 0.05]},\n                    dpi=400,\n                    constrained_layout=True,\n                )\n            elif cbar_orientation == \"vertical\":\n                fig, (ax, cax) = plt.subplots(\n                    ncols=2,\n                    figsize=figsize,\n                    gridspec_kw={\"width_ratios\": [1, 0.05]},\n                    dpi=400,\n                    constrained_layout=True,\n                )\n            else:\n                raise (\n                    \"This is not a valid orientation please choose either horizontal or vertical\"\n                )\n        else:\n            fig = plt.figure(figsize=(figsize), dpi=400)\n            ax = fig.add_subplot(111)\n    else:\n        fig = plt.figure(figsize=(figsize), dpi=400)\n        ax = fig.add_subplot(111)\n\n    _figure_setup(ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]])\n\n    band.plot_plain(\n        ax=ax,\n        color=color,\n        linewidth=linewidth,\n        linestyle=linestyle,\n        erange=erange,\n        scale_factor=scale_factor,\n        heatmap=heatmap,\n        bins=bins,\n        sigma=sigma,\n        cmap=cmap,\n        vlinecolor=vlinecolor,\n        powernorm=powernorm,\n        gamma=gamma,\n        highlight_band=highlight_band,\n        highlight_band_color=highlight_band_color,\n        band_index=band_index,\n        sp_color=sp_color,\n        sp_scale_factor=sp_scale_factor,\n    )\n\n    if heatmap:\n        if cbar:\n            im = ax.collections[0]\n            min_val = im.norm.vmin\n            max_val = im.norm.vmax\n            cbar = fig.colorbar(im, cax=cax, orientation=cbar_orientation)\n            cbar.set_ticks([min_val, max_val])\n            cbar.set_ticklabels([\"min\", \"max\"])\n\n    if heatmap:\n        if not cbar:\n            fig.tight_layout(pad=0.4)\n    else:\n        fig.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_plain_spin_polarized","title":"<code>band_plain_spin_polarized(folder, output='band_plain_sp.png', up_color='red', down_color='blue', background_color='black', linewidth=1.25, up_linestyle='-', down_linestyle=':', figsize=(4, 3), erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, unfold=False, M=None, high_symm_points=None, fontsize=12, save=True, scale_factor=5, shift_efermi=0, interpolate=False, new_n=200, heatmap=False, bins=1000, sigma=2, vlinecolor='black', cbar=True, cbar_orientation='horizontal', powernorm=True, gamma=0.7, soc_axis=None, sp_scale_factor=5)</code>","text":"<p>This function generates a plain spin polarized band structure.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_plain_sp.png'</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> required <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> required <code>unprojected_band_color</code> <code>str</code> <p>Color of the unprojected band</p> required <code>unprojected_linewidth</code> <code>float</code> <p>Line width of the unprojected bands</p> required <code>annotations</code> <code>list</code> <p>Annotations to put on the top and bottom (left and right) figures. By default it will show the spin up and spin down arrows.</p> required <code>annotation_xy</code> <code>list / tuple</code> <p>Fractional (x, y) coordinated of the annotation location</p> required <code>stack</code> <code>str</code> <p>Determines how the plots are stacked (vertical or horizontal)</p> required <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background.</p> <code>1.25</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure.</p> required <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches. (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot. [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing. (fig, ax1, ax2)</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_plain_spin_polarized(\n    folder,\n    output=\"band_plain_sp.png\",\n    up_color=\"red\",\n    down_color=\"blue\",\n    background_color=\"black\",\n    linewidth=1.25,\n    up_linestyle=\"-\",\n    down_linestyle=\":\",\n    figsize=(4, 3),\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=12,\n    save=True,\n    scale_factor=5,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    heatmap=False,\n    bins=1000,\n    sigma=2,\n    vlinecolor=\"black\",\n    cbar=True,\n    cbar_orientation=\"horizontal\",\n    powernorm=True,\n    gamma=0.7,\n    soc_axis=None,\n    sp_scale_factor=5,\n):\n    \"\"\"\n    This function generates a plain spin polarized band structure.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        output (str): File name of the resulting plot.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        unprojected_band_color (str): Color of the unprojected band\n        unprojected_linewidth (float): Line width of the unprojected bands\n        annotations (list): Annotations to put on the top and bottom (left and right) figures.\n            By default it will show the spin up and spin down arrows.\n        annotation_xy (list / tuple): Fractional (x, y) coordinated of the annotation location\n        stack (str): Determines how the plots are stacked (vertical or horizontal)\n        linewidth (float): Line width of the plain band structure plotted in the background.\n        band_color (string): Color of the plain band structure.\n        figsize (list / tuple): Desired size of the image in inches. (width, height)\n        erange (list / tuple): Range of energy to show in the plot. [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing. (fig, ax1, ax2)\n    \"\"\"\n\n    band_up = Band(\n        folder=folder,\n        spin=\"up\",\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n    band_down = Band(\n        folder=folder,\n        spin=\"down\",\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n        soc_axis=soc_axis,\n    )\n\n    if heatmap:\n        if cbar:\n            if cbar_orientation == \"horizontal\":\n                fig, (ax, cax) = plt.subplots(\n                    nrows=2,\n                    figsize=figsize,\n                    gridspec_kw={\"height_ratios\": [1, 0.05]},\n                    dpi=400,\n                    constrained_layout=True,\n                )\n            elif cbar_orientation == \"vertical\":\n                fig, (ax, cax) = plt.subplots(\n                    ncols=2,\n                    figsize=figsize,\n                    gridspec_kw={\"width_ratios\": [1, 0.05]},\n                    dpi=400,\n                    constrained_layout=True,\n                )\n            else:\n                raise (\n                    \"This is not a valid orientation please choose either horizontal or vertical\"\n                )\n        else:\n            fig = plt.figure(figsize=(figsize), dpi=400)\n            ax = fig.add_subplot(111)\n    else:\n        fig = plt.figure(figsize=(figsize), dpi=400)\n        ax = fig.add_subplot(111)\n\n    _figure_setup(ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]])\n\n    if heatmap:\n        _, axd = plt.subplots()\n        spin_cmap = LinearSegmentedColormap.from_list(\n            \"spin\",\n            [\n                to_rgba(down_color),\n                to_rgba(down_color),\n                to_rgba(down_color),\n                (1, 1, 1, 0),\n                to_rgba(up_color),\n                to_rgba(up_color),\n                to_rgba(up_color),\n            ],\n            N=10000,\n        )\n\n        bot_cmap = LinearSegmentedColormap.from_list(\n            \"background\",\n            [\n                (1, 1, 1, 0),\n                to_rgba(background_color),\n            ],\n            N=10000,\n        )\n        band_up.plot_plain(\n            ax=ax,\n            erange=erange,\n            heatmap=heatmap,\n            bins=bins,\n            sigma=sigma,\n            vlinecolor=vlinecolor,\n            powernorm=False,\n            cmap=bot_cmap,\n            gamma=gamma,\n        )\n\n        band_down.plot_plain(\n            ax=axd,\n            erange=erange,\n            heatmap=heatmap,\n            bins=bins,\n            sigma=sigma,\n            vlinecolor=vlinecolor,\n            powernorm=False,\n            cmap=bot_cmap,\n            gamma=gamma,\n        )\n\n        band_up.plot_plain(\n            ax=ax,\n            erange=erange,\n            heatmap=heatmap,\n            bins=bins,\n            sigma=sigma,\n            vlinecolor=vlinecolor,\n            powernorm=False,\n            cmap=spin_cmap,\n            gamma=gamma,\n        )\n\n        band_down.plot_plain(\n            ax=axd,\n            erange=erange,\n            heatmap=heatmap,\n            bins=bins,\n            sigma=sigma,\n            vlinecolor=vlinecolor,\n            cmap=spin_cmap,\n            powernorm=False,\n            gamma=gamma,\n        )\n\n        ax.collections[1].set_array(\n            ax.collections[1].get_array() - axd.collections[1].get_array()\n        )\n        ax.collections[0].set_array(\n            ax.collections[0].get_array() + axd.collections[0].get_array()\n        )\n        im = ax.collections[1]\n        sym_val = np.max(\n            np.abs([np.min(im.get_array()), np.max(im.get_array())])\n        )\n        norm = Normalize(\n            vmin=-sym_val,\n            vmax=sym_val,\n        )\n        ax.collections[1].set_norm(norm)\n    else:\n        band_up.plot_plain(\n            ax=ax,\n            color=up_color,\n            linewidth=linewidth,\n            linestyle=up_linestyle,\n            erange=erange,\n            scale_factor=scale_factor,\n            heatmap=heatmap,\n            bins=bins,\n            sigma=sigma,\n            vlinecolor=vlinecolor,\n            powernorm=powernorm,\n            gamma=gamma,\n            sp_color=up_color,\n            sp_scale_factor=sp_scale_factor,\n        )\n\n        band_down.plot_plain(\n            ax=ax,\n            color=down_color,\n            linewidth=linewidth,\n            linestyle=down_linestyle,\n            erange=erange,\n            scale_factor=scale_factor,\n            heatmap=heatmap,\n            bins=bins,\n            sigma=sigma,\n            vlinecolor=vlinecolor,\n            powernorm=powernorm,\n            gamma=gamma,\n            sp_color=down_color,\n            sp_scale_factor=sp_scale_factor,\n        )\n\n        if unfold:\n            legend_lines = [\n                plt.Line2D(\n                    [0],\n                    [0],\n                    color=up_color,\n                    linestyle=\"\",\n                    marker=\"o\",\n                    markersize=3,\n                ),\n                plt.Line2D(\n                    [0],\n                    [0],\n                    color=down_color,\n                    linestyle=\"\",\n                    marker=\"o\",\n                    markersize=3,\n                ),\n            ]\n        elif soc_axis is not None and band_up.lsorbit:\n            legend_lines = [\n                plt.Line2D(\n                    [0],\n                    [0],\n                    color=up_color,\n                    linestyle=\"\",\n                    marker=\"o\",\n                    markersize=3,\n                ),\n                plt.Line2D(\n                    [0],\n                    [0],\n                    color=down_color,\n                    linestyle=\"\",\n                    marker=\"o\",\n                    markersize=3,\n                ),\n            ]\n        else:\n            legend_lines = [\n                plt.Line2D([0], [0], color=up_color, linestyle=up_linestyle),\n                plt.Line2D(\n                    [0], [0], color=down_color, linestyle=down_linestyle\n                ),\n            ]\n\n        legend_labels = [\"$\\\\uparrow$\", \"$\\\\downarrow$\"]\n\n        ax.legend(\n            legend_lines,\n            legend_labels,\n            ncol=1,\n            loc=\"upper left\",\n            fontsize=fontsize,\n            bbox_to_anchor=(1, 1),\n            borderaxespad=0,\n            frameon=False,\n            handletextpad=0.1,\n        )\n\n    if heatmap:\n        if cbar:\n            im = ax.collections[1]\n            min_val = im.norm.vmin\n            max_val = im.norm.vmax\n            cbar = fig.colorbar(im, cax=cax, orientation=cbar_orientation)\n            cbar.set_ticks([min_val, max_val])\n            cbar.set_ticklabels([\"down\", \"up\"])\n\n    if heatmap:\n        if not cbar:\n            fig.tight_layout(pad=0.4)\n    else:\n        fig.tight_layout(pad=0.4)\n\n    if save:\n        fig.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_spd","title":"<code>band_spd(folder, output='band_spd.png', spin='up', scale_factor=5, orbitals='spd', display_order=None, color_list=None, legend=True, linewidth=0.75, band_color='black', figsize=(4, 3), erange=[-6, 6], kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, unfold=False, M=None, high_symm_points=None, fontsize=12, heatmap=False, bins=800, sigma=2, cmap='hot', vlinecolor='black', cbar=True, cbar_orientation='horizontal', powernorm=True, gamma=0.5, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None)</code>","text":"<p>This function generates a s, p, d projected band structure.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>orbitals</code> <code>str</code> <p>String that contains the s, p, or d orbitals that to project onto. The default is 'spd', if the user only wanted to project onto the p, and d orbitals than 'pd' should be passed in</p> <code>'spd'</code> <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_spd.png'</code> <code>spin</code> <code>str</code> <p>Choose which spin direction to parse. ('up' or 'down')</p> <code>'up'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot.</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background.</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure.</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches. (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot. [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_spd(\n    folder,\n    output=\"band_spd.png\",\n    spin=\"up\",\n    scale_factor=5,\n    orbitals=\"spd\",\n    display_order=None,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    figsize=(4, 3),\n    erange=[-6, 6],\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    fontsize=12,\n    heatmap=False,\n    bins=800,\n    sigma=2,\n    cmap=\"hot\",\n    vlinecolor=\"black\",\n    cbar=True,\n    cbar_orientation=\"horizontal\",\n    powernorm=True,\n    gamma=0.5,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n):\n    \"\"\"\n    This function generates a s, p, d projected band structure.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        orbitals (str): String that contains the s, p, or d orbitals that to project onto.\n            The default is 'spd', if the user only wanted to project onto the p, and d orbitals\n            than 'pd' should be passed in\n        output (str): File name of the resulting plot.\n        spin (str): Choose which spin direction to parse. ('up' or 'down')\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot.\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        linewidth (float): Line width of the plain band structure plotted in the background.\n        band_color (string): Color of the plain band structure.\n        figsize (list / tuple): Desired size of the image in inches. (width, height)\n        erange (list / tuple): Range of energy to show in the plot. [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    band = Band(\n        folder=folder,\n        spin=spin,\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    if heatmap:\n        legend = False\n        if cbar:\n            if cbar_orientation == \"horizontal\":\n                fig, (ax, cax) = plt.subplots(\n                    nrows=2,\n                    figsize=figsize,\n                    gridspec_kw={\"height_ratios\": [1, 0.05]},\n                    dpi=400,\n                    constrained_layout=True,\n                )\n            elif cbar_orientation == \"vertical\":\n                fig, (ax, cax) = plt.subplots(\n                    ncols=2,\n                    figsize=figsize,\n                    gridspec_kw={\"width_ratios\": [1, 0.05]},\n                    dpi=400,\n                    constrained_layout=True,\n                )\n            else:\n                raise (\n                    \"This is not a valid orientation please choose either horizontal or vertical\"\n                )\n        else:\n            fig = plt.figure(figsize=(figsize), dpi=400)\n            ax = fig.add_subplot(111)\n    else:\n        fig = plt.figure(figsize=(figsize), dpi=400)\n        ax = fig.add_subplot(111)\n\n    _figure_setup(ax=ax, fontsize=fontsize, ylim=[erange[0], erange[1]])\n    band.plot_spd(\n        ax=ax,\n        scale_factor=scale_factor,\n        orbitals=orbitals,\n        erange=erange,\n        display_order=display_order,\n        color_list=color_list,\n        legend=legend,\n        linewidth=linewidth,\n        band_color=band_color,\n        heatmap=heatmap,\n        bins=bins,\n        sigma=sigma,\n        cmap=cmap,\n        vlinecolor=vlinecolor,\n        powernorm=powernorm,\n        gamma=gamma,\n    )\n\n    if heatmap:\n        if cbar:\n            im = ax.collections[0]\n            min_val = im.norm.vmin\n            max_val = im.norm.vmax\n            cbar = fig.colorbar(im, cax=cax, orientation=cbar_orientation)\n            cbar.set_ticks([min_val, max_val])\n            cbar.set_ticklabels([\"min\", \"max\"])\n\n    if heatmap:\n        if not cbar:\n            fig.tight_layout(pad=0.4)\n    else:\n        fig.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.band_spd_spin_polarized","title":"<code>band_spd_spin_polarized(folder, output='band_spd_sp.png', scale_factor=5, orbitals='spd', display_order=None, color_list=None, legend=True, linewidth=0.75, band_color='black', unprojected_band_color='gray', unprojected_linewidth=0.6, fontsize=12, annotations=['$\\\\uparrow$ ', '$\\\\downarrow$ '], annotation_xy=(0.02, 0.98), figsize=(4, 3), erange=[-6, 6], stack='vertical', kpath=None, custom_kpath=None, stretch_factor=1.0, n=None, unfold=False, M=None, high_symm_points=None, save=True, shift_efermi=0, interpolate=False, new_n=200, soc_axis=None)</code>","text":"<p>This function generates a spin polarized s, p, d projected band structure. This will plot two plots stacked on top or eachother or next to eachother. The top or left plot will project on the spin up bands and the bottom or right plot will project onto the spin down bands.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>orbitals</code> <code>str</code> <p>String that contains the s, p, or d orbitals that to project onto. The default is 'spd', if the user only wanted to project onto the p, and d orbitals than 'pd' should be passed in</p> <code>'spd'</code> <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'band_spd_sp.png'</code> <code>scale_factor</code> <code>float</code> <p>Factor to scale weights. This changes the size of the points in the scatter plot.</p> <code>5</code> <code>display_order</code> <code>str / None</code> <p>If None, the projections will be displayed in the same order the user inputs them. If 'all' the projections will be plotted from largest to smallest so every point is visable. If 'dominant' the projections will be plotted from smallest to largest so only the dominant projection is shown.</p> <code>None</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines if the legend should be included or not.</p> <code>True</code> <code>unprojected_band_color</code> <code>str</code> <p>Color of the unprojected band</p> <code>'gray'</code> <code>unprojected_linewidth</code> <code>float</code> <p>Line width of the unprojected bands</p> <code>0.6</code> <code>annotations</code> <code>list</code> <p>Annotations to put on the top and bottom (left and right) figures. By default it will show the spin up and spin down arrows.</p> <code>['$\\\\uparrow$ ', '$\\\\downarrow$ ']</code> <code>annotation_xy</code> <code>list / tuple</code> <p>Fractional (x, y) coordinated of the annotation location</p> <code>(0.02, 0.98)</code> <code>stack</code> <code>str</code> <p>Determines how the plots are stacked (vertical or horizontal)</p> <code>'vertical'</code> <code>linewidth</code> <code>float</code> <p>Line width of the plain band structure plotted in the background.</p> <code>0.75</code> <code>band_color</code> <code>string</code> <p>Color of the plain band structure.</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches. (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list / tuple</code> <p>Range of energy to show in the plot. [low, high]</p> <code>[-6, 6]</code> <code>kpath</code> <code>list[list]</code> <p>High symmetry k-point path of band structure calculation Due to the nature of the KPOINTS file for unfolded calculations this information is a required input for proper labeling of the figure for unfolded calculations. This information is extracted from the KPOINTS files for non-unfolded calculations. (G is automatically converted to \\Gamma) (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])</p> <code>None</code> <code>custom_kpath</code> <code>list</code> <p>This gives the option to only plot specific segments of a given band structure calculation. For example if the kpath was G-X-W-L then there are three segements to choose from: G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3], where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2]. If one of the segements should be flipped it can be done by making its value negative (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of points between each high symmetry points. This is also only required for unfolded calculations and band unfolding. This number should be known by the user, as it was used to generate the KPOINTS file.</p> <code>None</code> <code>unfold</code> <code>bool</code> <p>Determines if the plotted band structure is from a band unfolding calculation.</p> <code>False</code> <code>M</code> <code>list[list]</code> <p>Transformation matrix from the primitive bulk structure to the slab structure. Only required for a band unfolding calculation.</p> <code>None</code> <code>high_symm_points</code> <code>list[list]</code> <p>List of fractional coordinated for each high symmetry point in the band structure path. Only required for a band unfolding calculation.</p> <code>None</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing. (fig, ax1, ax2)</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def band_spd_spin_polarized(\n    folder,\n    output=\"band_spd_sp.png\",\n    scale_factor=5,\n    orbitals=\"spd\",\n    display_order=None,\n    color_list=None,\n    legend=True,\n    linewidth=0.75,\n    band_color=\"black\",\n    unprojected_band_color=\"gray\",\n    unprojected_linewidth=0.6,\n    fontsize=12,\n    annotations=[\"$\\\\uparrow$ \", \"$\\\\downarrow$ \"],\n    annotation_xy=(0.02, 0.98),\n    figsize=(4, 3),\n    erange=[-6, 6],\n    stack=\"vertical\",\n    kpath=None,\n    custom_kpath=None,\n    stretch_factor=1.0,\n    n=None,\n    unfold=False,\n    M=None,\n    high_symm_points=None,\n    save=True,\n    shift_efermi=0,\n    interpolate=False,\n    new_n=200,\n    soc_axis=None,\n):\n    \"\"\"\n    This function generates a spin polarized s, p, d projected band structure. This will plot two plots\n    stacked on top or eachother or next to eachother. The top or left plot will project on the\n    spin up bands and the bottom or right plot will project onto the spin down bands.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        orbitals (str): String that contains the s, p, or d orbitals that to project onto.\n            The default is 'spd', if the user only wanted to project onto the p, and d orbitals\n            than 'pd' should be passed in\n        output (str): File name of the resulting plot.\n        scale_factor (float): Factor to scale weights. This changes the size of the\n            points in the scatter plot.\n        display_order (str / None): If None, the projections will be displayed in the same order\n            the user inputs them. If 'all' the projections will be plotted from largest to smallest\n            so every point is visable. If 'dominant' the projections will be plotted from smallest\n            to largest so only the dominant projection is shown.\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines if the legend should be included or not.\n        unprojected_band_color (str): Color of the unprojected band\n        unprojected_linewidth (float): Line width of the unprojected bands\n        annotations (list): Annotations to put on the top and bottom (left and right) figures.\n            By default it will show the spin up and spin down arrows.\n        annotation_xy (list / tuple): Fractional (x, y) coordinated of the annotation location\n        stack (str): Determines how the plots are stacked (vertical or horizontal)\n        linewidth (float): Line width of the plain band structure plotted in the background.\n        band_color (string): Color of the plain band structure.\n        figsize (list / tuple): Desired size of the image in inches. (width, height)\n        erange (list / tuple): Range of energy to show in the plot. [low, high]\n        kpath (list[list]): High symmetry k-point path of band structure calculation\n            Due to the nature of the KPOINTS file for unfolded calculations this\n            information is a required input for proper labeling of the figure\n            for unfolded calculations. This information is extracted from the KPOINTS\n            files for non-unfolded calculations. (G is automatically converted to \\\\Gamma)\n            (e.g. For the path X-G-X, kpath=[['X', 'G'], ['G', 'X']])\n        custom_kpath (list): This gives the option to only plot specific segments of a given band structure\n            calculation. For example if the kpath was G-X-W-L then there are three segements to choose from:\n            G-X, X-W, and W-L. In this case the default kpath could be plotted by defining custom_kpath=[1,2,3],\n            where 1 -&gt; G-X, 2 -&gt; X-W, and 3 -&gt; W-L. If only G-X and X-W were desired then custom_kpath=[1,2].\n            If one of the segements should be flipped it can be done by making its value negative\n            (e.g. -1 -&gt; X-G, -2 -&gt; W-X, -3 -&gt; L-W)\n        n (int): Number of points between each high symmetry points.\n            This is also only required for unfolded calculations and band unfolding. This number should be\n            known by the user, as it was used to generate the KPOINTS file.\n        unfold (bool): Determines if the plotted band structure is from a band unfolding calculation.\n        M (list[list]): Transformation matrix from the primitive bulk structure to the slab structure.\n            Only required for a band unfolding calculation.\n        high_symm_points (list[list]): List of fractional coordinated for each high symmetry point in\n            the band structure path. Only required for a band unfolding calculation.\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing. (fig, ax1, ax2)\n    \"\"\"\n\n    band_up = Band(\n        folder=folder,\n        spin=\"up\",\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    band_down = Band(\n        folder=folder,\n        spin=\"down\",\n        projected=True,\n        unfold=unfold,\n        high_symm_points=high_symm_points,\n        interpolate=interpolate,\n        new_n=new_n,\n        soc_axis=soc_axis,\n        kpath=kpath,\n        custom_kpath=custom_kpath,\n        stretch_factor=stretch_factor,\n        n=n,\n        M=M,\n        shift_efermi=shift_efermi,\n    )\n\n    if stack == \"vertical\":\n        fig = plt.figure(figsize=(figsize[0], 2 * figsize[1]), dpi=400)\n        ax1 = fig.add_subplot(211)\n        ax2 = fig.add_subplot(212)\n        _figure_setup(ax=ax1, fontsize=fontsize, ylim=[erange[0], erange[1]])\n        _figure_setup(ax=ax2, fontsize=fontsize, ylim=[erange[0], erange[1]])\n    elif stack == \"horizontal\":\n        fig = plt.figure(figsize=(2 * figsize[0], figsize[1]), dpi=400)\n        ax1 = fig.add_subplot(121)\n        ax2 = fig.add_subplot(122)\n        _figure_setup(ax=ax1, fontsize=fontsize, ylim=[erange[0], erange[1]])\n        _figure_setup(ax=ax2, fontsize=fontsize, ylim=[erange[0], erange[1]])\n\n    bbox = dict(\n        boxstyle=\"round\", fc=\"white\", edgecolor=\"gray\", alpha=0.95, pad=0.3\n    )\n    ax1.annotate(\n        annotations[0],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize,\n    )\n    ax2.annotate(\n        annotations[1],\n        xy=annotation_xy,\n        xycoords=\"axes fraction\",\n        zorder=200,\n        va=\"top\",\n        ha=\"left\",\n        bbox=bbox,\n        fontsize=fontsize,\n    )\n\n    band_up.plot_spd(\n        ax=ax1,\n        scale_factor=scale_factor,\n        orbitals=orbitals,\n        erange=erange,\n        display_order=display_order,\n        color_list=color_list,\n        legend=legend,\n        linewidth=linewidth,\n        band_color=band_color,\n    )\n    band_down.plot_plain(\n        sp_scale_factor=0,\n        ax=ax1,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n        erange=erange,\n    )\n\n    band_down.plot_spd(\n        ax=ax2,\n        scale_factor=scale_factor,\n        orbitals=orbitals,\n        erange=erange,\n        display_order=display_order,\n        color_list=color_list,\n        legend=legend,\n        linewidth=linewidth,\n        band_color=band_color,\n    )\n    band_up.plot_plain(\n        sp_scale_factor=0,\n        ax=ax2,\n        color=unprojected_band_color,\n        linewidth=unprojected_linewidth,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax1, ax2\n</code></pre>"},{"location":"standard/#vaspvis.standard.dos_atom_orbitals","title":"<code>dos_atom_orbitals(folder, atom_orbital_dict, output='dos_atom_orbitals.png', fill=True, alpha=0.3, linewidth=1.5, sigma=0.05, energyaxis='x', color_list=None, legend=True, total=True, figsize=(4, 3), erange=[-6, 6], spin='up', soc_axis=None, combination_method='add', fontsize=12, save=True, shift_efermi=0)</code>","text":"<p>This function plots the orbital projected density of states on specific atoms.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>atom_orbital_dict</code> <code>dict[int</code> <p>list]): A dictionary that contains the individual atoms and the corresponding orbitals to project onto. For example, if the user wants to project onto the s, py, pz, and px orbitals of the first atom and the s orbital of the second atom then the dictionary would be {0:[0,1,2,3], 1:[0]}</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'dos_atom_orbitals.png'</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'x'</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines whether to draw the legend or not</p> <code>True</code> <code>total</code> <code>bool</code> <p>Determines wheth to draw the total density of states or not</p> <code>True</code> <code>spin</code> <code>str</code> <p>Which spin direction to parse ('up' or 'down')</p> <code>'up'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> <code>combination_method</code> <code>str</code> <p>If spin == 'both', this determines if the spin up and spin down desnities are added or subtracted. ('add' or 'sub')</p> <code>'add'</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def dos_atom_orbitals(\n    folder,\n    atom_orbital_dict,\n    output=\"dos_atom_orbitals.png\",\n    fill=True,\n    alpha=0.3,\n    linewidth=1.5,\n    sigma=0.05,\n    energyaxis=\"x\",\n    color_list=None,\n    legend=True,\n    total=True,\n    figsize=(4, 3),\n    erange=[-6, 6],\n    spin=\"up\",\n    soc_axis=None,\n    combination_method=\"add\",\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n):\n    \"\"\"\n    This function plots the orbital projected density of states on specific atoms.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        atom_orbital_dict (dict[int:list]): A dictionary that contains the individual atoms and the corresponding\n            orbitals to project onto. For example, if the user wants to project onto the s, py, pz, and px orbitals\n            of the first atom and the s orbital of the second atom then the dictionary would be {0:[0,1,2,3], 1:[0]}\n        output (str): File name of the resulting plot.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines whether to draw the legend or not\n        total (bool): Determines wheth to draw the total density of states or not\n        spin (str): Which spin direction to parse ('up' or 'down')\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        combination_method (str): If spin == 'both', this determines if the spin up and spin down\n            desnities are added or subtracted. ('add' or 'sub')\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    dos = Dos(\n        shift_efermi=shift_efermi,\n        folder=folder,\n        spin=spin,\n        combination_method=combination_method,\n    )\n\n    fig = plt.figure(figsize=figsize, dpi=400)\n    ax = fig.add_subplot(111)\n    _figure_setup_dos(ax=ax, fontsize=fontsize, energyaxis=energyaxis)\n\n    dos.plot_atom_orbitals(\n        ax=ax,\n        atom_orbital_dict=atom_orbital_dict,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color_list=color_list,\n        legend=legend,\n        total=total,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.dos_atom_orbitals_spin_polarized","title":"<code>dos_atom_orbitals_spin_polarized(folder, atom_orbital_dict, output='dos_atom_orbitals_sp.png', fill=True, alpha=0.3, linewidth=1.5, sigma=0.05, energyaxis='y', soc_axis='z', color_list=None, legend=True, total=True, figsize=(4, 3), erange=[-6, 6], fontsize=12, save=True, shift_efermi=0)</code>","text":"<p>This function plots a spin polarized orbital projected density of states on specific atoms.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>atom_orbital_dict</code> <code>dict[int</code> <p>list]): A dictionary that contains the individual atoms and the corresponding orbitals to project onto. For example, if the user wants to project onto the s, py, pz, and px orbitals of the first atom and the s orbital of the second atom then the dictionary would be {0:[0,1,2,3], 1:[0]}</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'dos_atom_orbitals_sp.png'</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'y'</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines whether to draw the legend or not</p> <code>True</code> <code>total</code> <code>bool</code> <p>Determines wheth to draw the total density of states or not</p> <code>True</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def dos_atom_orbitals_spin_polarized(\n    folder,\n    atom_orbital_dict,\n    output=\"dos_atom_orbitals_sp.png\",\n    fill=True,\n    alpha=0.3,\n    linewidth=1.5,\n    sigma=0.05,\n    energyaxis=\"y\",\n    soc_axis=\"z\",\n    color_list=None,\n    legend=True,\n    total=True,\n    figsize=(4, 3),\n    erange=[-6, 6],\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n):\n    \"\"\"\n    This function plots a spin polarized orbital projected density of states on specific atoms.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        atom_orbital_dict (dict[int:list]): A dictionary that contains the individual atoms and the corresponding\n            orbitals to project onto. For example, if the user wants to project onto the s, py, pz, and px orbitals\n            of the first atom and the s orbital of the second atom then the dictionary would be {0:[0,1,2,3], 1:[0]}\n        output (str): File name of the resulting plot.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines whether to draw the legend or not\n        total (bool): Determines wheth to draw the total density of states or not\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    dos_up = Dos(\n        shift_efermi=shift_efermi, folder=folder, spin=\"up\", soc_axis=soc_axis\n    )\n    dos_down = Dos(\n        shift_efermi=shift_efermi,\n        folder=folder,\n        spin=\"down\",\n        soc_axis=soc_axis,\n    )\n\n    fig = plt.figure(figsize=figsize, dpi=400)\n    ax = fig.add_subplot(111)\n    _figure_setup_dos(ax=ax, fontsize=fontsize, energyaxis=energyaxis)\n\n    dos_up.plot_atom_orbitals(\n        ax=ax,\n        atom_orbital_dict=atom_orbital_dict,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color_list=color_list,\n        legend=legend,\n        total=total,\n        erange=erange,\n    )\n\n    dos_down.plot_atom_orbitals(\n        ax=ax,\n        atom_orbital_dict=atom_orbital_dict,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color_list=color_list,\n        legend=False,\n        total=total,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.dos_atom_spd","title":"<code>dos_atom_spd(folder, atom_spd_dict, output='dos_atom_spd.png', fill=True, alpha=0.3, linewidth=1.5, sigma=0.05, energyaxis='x', color_list=None, legend=True, total=True, figsize=(4, 3), erange=[-6, 6], spin='up', soc_axis=None, combination_method='add', fontsize=12, save=True, shift_efermi=0)</code>","text":"<p>This function plots the atom projected density of states of the s, p, and d orbitals.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>atom_spd_dict</code> <code>dict[int</code> <p>str]): A dictionary that contains the individual atoms and the corresponding orbitals to project onto. For example, if the user wants to project onto the s, p, d orbitals of the first atom and the p orbitals of the second atom then the dictionary would be {0:'spd', 1:'p'}</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'dos_atom_spd.png'</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'x'</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines whether to draw the legend or not</p> <code>True</code> <code>total</code> <code>bool</code> <p>Determines wheth to draw the total density of states or not</p> <code>True</code> <code>spin</code> <code>str</code> <p>Which spin direction to parse ('up' or 'down')</p> <code>'up'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> <code>combination_method</code> <code>str</code> <p>If spin == 'both', this determines if the spin up and spin down desnities are added or subtracted. ('add' or 'sub')</p> <code>'add'</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def dos_atom_spd(\n    folder,\n    atom_spd_dict,\n    output=\"dos_atom_spd.png\",\n    fill=True,\n    alpha=0.3,\n    linewidth=1.5,\n    sigma=0.05,\n    energyaxis=\"x\",\n    color_list=None,\n    legend=True,\n    total=True,\n    figsize=(4, 3),\n    erange=[-6, 6],\n    spin=\"up\",\n    soc_axis=None,\n    combination_method=\"add\",\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n):\n    \"\"\"\n    This function plots the atom projected density of states of the s, p, and d orbitals.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        atom_spd_dict (dict[int:str]): A dictionary that contains the individual atoms and the corresponding\n            orbitals to project onto. For example, if the user wants to project onto the s, p, d orbitals\n            of the first atom and the p orbitals of the second atom then the dictionary would be {0:'spd', 1:'p'}\n        output (str): File name of the resulting plot.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines whether to draw the legend or not\n        total (bool): Determines wheth to draw the total density of states or not\n        spin (str): Which spin direction to parse ('up' or 'down')\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        combination_method (str): If spin == 'both', this determines if the spin up and spin down\n            desnities are added or subtracted. ('add' or 'sub')\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    dos = Dos(\n        shift_efermi=shift_efermi,\n        folder=folder,\n        spin=spin,\n        combination_method=combination_method,\n    )\n\n    fig = plt.figure(figsize=figsize, dpi=400)\n    ax = fig.add_subplot(111)\n    _figure_setup_dos(ax=ax, fontsize=fontsize, energyaxis=energyaxis)\n\n    dos.plot_atom_spd(\n        ax=ax,\n        atom_spd_dict=atom_spd_dict,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color_list=color_list,\n        legend=legend,\n        total=total,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.dos_atom_spd_spin_polarized","title":"<code>dos_atom_spd_spin_polarized(folder, atom_spd_dict, output='dos_atom_spd_sp.png', fill=True, alpha=0.3, linewidth=1.5, sigma=0.05, energyaxis='x', soc_axis='z', color_list=None, legend=True, total=True, figsize=(4, 3), erange=[-6, 6], fontsize=12, save=True, shift_efermi=0)</code>","text":"<p>This function plots a spin polarized atom projected density of states of the s, p, and d orbitals.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>atom_spd_dict</code> <code>dict[int</code> <p>str]): A dictionary that contains the individual atoms and the corresponding orbitals to project onto. For example, if the user wants to project onto the s, p, d orbitals of the first atom and the p orbitals of the second atom then the dictionary would be {0:'spd', 1:'p'}</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'dos_atom_spd_sp.png'</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'x'</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines whether to draw the legend or not</p> <code>True</code> <code>total</code> <code>bool</code> <p>Determines wheth to draw the total density of states or not</p> <code>True</code> <code>spin</code> <code>str</code> <p>Which spin direction to parse ('up' or 'down')</p> required <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> <code>combination_method</code> <code>str</code> <p>If spin == 'both', this determines if the spin up and spin down desnities are added or subtracted. ('add' or 'sub')</p> required <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def dos_atom_spd_spin_polarized(\n    folder,\n    atom_spd_dict,\n    output=\"dos_atom_spd_sp.png\",\n    fill=True,\n    alpha=0.3,\n    linewidth=1.5,\n    sigma=0.05,\n    energyaxis=\"x\",\n    soc_axis=\"z\",\n    color_list=None,\n    legend=True,\n    total=True,\n    figsize=(4, 3),\n    erange=[-6, 6],\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n):\n    \"\"\"\n    This function plots a spin polarized atom projected density of states of the s, p, and d orbitals.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        atom_spd_dict (dict[int:str]): A dictionary that contains the individual atoms and the corresponding\n            orbitals to project onto. For example, if the user wants to project onto the s, p, d orbitals\n            of the first atom and the p orbitals of the second atom then the dictionary would be {0:'spd', 1:'p'}\n        output (str): File name of the resulting plot.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines whether to draw the legend or not\n        total (bool): Determines wheth to draw the total density of states or not\n        spin (str): Which spin direction to parse ('up' or 'down')\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        combination_method (str): If spin == 'both', this determines if the spin up and spin down\n            desnities are added or subtracted. ('add' or 'sub')\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    dos_up = Dos(\n        shift_efermi=shift_efermi, folder=folder, spin=\"up\", soc_axis=soc_axis\n    )\n    dos_down = Dos(\n        shift_efermi=shift_efermi,\n        folder=folder,\n        spin=\"down\",\n        soc_axis=soc_axis,\n    )\n\n    fig = plt.figure(figsize=figsize, dpi=400)\n    ax = fig.add_subplot(111)\n    _figure_setup_dos(ax=ax, fontsize=fontsize, energyaxis=energyaxis)\n\n    dos_up.plot_atom_spd(\n        ax=ax,\n        atom_spd_dict=atom_spd_dict,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color_list=color_list,\n        legend=legend,\n        total=total,\n        erange=erange,\n    )\n\n    dos_down.plot_atom_spd(\n        ax=ax,\n        atom_spd_dict=atom_spd_dict,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color_list=color_list,\n        legend=False,\n        total=total,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.dos_atoms","title":"<code>dos_atoms(folder, atoms, output='dos_atoms.png', fill=True, alpha=0.3, linewidth=1.5, sigma=0.05, energyaxis='x', color_list=None, legend=True, total=True, figsize=(4, 3), erange=[-6, 6], spin='up', soc_axis=None, combination_method='add', fontsize=12, save=True, shift_efermi=0)</code>","text":"<p>This function plots the atom projected density of states.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>atoms</code> <code>list</code> <p>List of atoms to project onto. The indices should be zero indexed (first atom is 0) and the atoms are in the same order as they are in the POSCAR</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'dos_atoms.png'</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'x'</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines whether to draw the legend or not</p> <code>True</code> <code>total</code> <code>bool</code> <p>Determines wheth to draw the total density of states or not</p> <code>True</code> <code>spin</code> <code>str</code> <p>Which spin direction to parse ('up' or 'down')</p> <code>'up'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> <code>combination_method</code> <code>str</code> <p>If spin == 'both', this determines if the spin up and spin down desnities are added or subtracted. ('add' or 'sub')</p> <code>'add'</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def dos_atoms(\n    folder,\n    atoms,\n    output=\"dos_atoms.png\",\n    fill=True,\n    alpha=0.3,\n    linewidth=1.5,\n    sigma=0.05,\n    energyaxis=\"x\",\n    color_list=None,\n    legend=True,\n    total=True,\n    figsize=(4, 3),\n    erange=[-6, 6],\n    spin=\"up\",\n    soc_axis=None,\n    combination_method=\"add\",\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n):\n    \"\"\"\n    This function plots the atom projected density of states.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        atoms (list): List of atoms to project onto. The indices should be zero indexed (first atom is 0)\n            and the atoms are in the same order as they are in the POSCAR\n        output (str): File name of the resulting plot.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines whether to draw the legend or not\n        total (bool): Determines wheth to draw the total density of states or not\n        spin (str): Which spin direction to parse ('up' or 'down')\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        combination_method (str): If spin == 'both', this determines if the spin up and spin down\n            desnities are added or subtracted. ('add' or 'sub')\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    dos = Dos(\n        shift_efermi=shift_efermi,\n        folder=folder,\n        spin=spin,\n        combination_method=combination_method,\n    )\n\n    fig = plt.figure(figsize=figsize, dpi=400)\n    ax = fig.add_subplot(111)\n    _figure_setup_dos(ax=ax, fontsize=fontsize, energyaxis=energyaxis)\n\n    dos.plot_atoms(\n        ax=ax,\n        atoms=atoms,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color_list=color_list,\n        legend=legend,\n        total=total,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.dos_atoms_spin_polarized","title":"<code>dos_atoms_spin_polarized(folder, atoms, output='dos_atoms_sp.png', fill=True, alpha=0.3, linewidth=1.5, sigma=0.05, energyaxis='y', soc_axis='z', color_list=None, legend=True, total=True, figsize=(4, 3), erange=[-6, 6], fontsize=12, save=True, shift_efermi=0)</code>","text":"<p>This function plots a spin polarized atom projected density of states.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>atoms</code> <code>list</code> <p>List of atoms to project onto. The indices should be zero indexed (first atom is 0) and the atoms are in the same order as they are in the POSCAR</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'dos_atoms_sp.png'</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'y'</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines whether to draw the legend or not</p> <code>True</code> <code>total</code> <code>bool</code> <p>Determines wheth to draw the total density of states or not</p> <code>True</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def dos_atoms_spin_polarized(\n    folder,\n    atoms,\n    output=\"dos_atoms_sp.png\",\n    fill=True,\n    alpha=0.3,\n    linewidth=1.5,\n    sigma=0.05,\n    energyaxis=\"y\",\n    soc_axis=\"z\",\n    color_list=None,\n    legend=True,\n    total=True,\n    figsize=(4, 3),\n    erange=[-6, 6],\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n):\n    \"\"\"\n    This function plots a spin polarized atom projected density of states.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        atoms (list): List of atoms to project onto. The indices should be zero indexed (first atom is 0)\n            and the atoms are in the same order as they are in the POSCAR\n        output (str): File name of the resulting plot.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines whether to draw the legend or not\n        total (bool): Determines wheth to draw the total density of states or not\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    dos_up = Dos(\n        shift_efermi=shift_efermi, folder=folder, spin=\"up\", soc_axis=soc_axis\n    )\n    dos_down = Dos(\n        shift_efermi=shift_efermi,\n        folder=folder,\n        spin=\"down\",\n        soc_axis=soc_axis,\n    )\n\n    fig = plt.figure(figsize=figsize, dpi=400)\n    ax = fig.add_subplot(111)\n    _figure_setup_dos(ax=ax, fontsize=fontsize, energyaxis=energyaxis)\n\n    dos_up.plot_atoms(\n        ax=ax,\n        atoms=atoms,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color_list=color_list,\n        legend=legend,\n        total=total,\n        erange=erange,\n    )\n\n    dos_down.plot_atoms(\n        ax=ax,\n        atoms=atoms,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color_list=color_list,\n        legend=False,\n        total=total,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.dos_element_orbitals","title":"<code>dos_element_orbitals(folder, element_orbital_dict, output='dos_element_orbitals.png', fill=True, alpha=0.3, linewidth=1.5, sigma=0.05, energyaxis='x', color_list=None, legend=True, total=True, figsize=(4, 3), erange=[-6, 6], spin='up', soc_axis=None, combination_method='add', fontsize=12, save=True, shift_efermi=0)</code>","text":"<p>This function plots the element projected density of states on specific orbitals.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>element_orbital_dict</code> <code>dict[str</code> <p>list]): A dictionary that contains the individual elements and the corresponding orbitals to project onto. For example, if the user wants to project onto the s, py, pz, and px orbitals of In and the s orbital of As for and InAs structure then the dictionary would be {'In':[0,1,2,3], 'As':[0]}</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'dos_element_orbitals.png'</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'x'</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines whether to draw the legend or not</p> <code>True</code> <code>total</code> <code>bool</code> <p>Determines wheth to draw the total density of states or not</p> <code>True</code> <code>spin</code> <code>str</code> <p>Which spin direction to parse ('up' or 'down')</p> <code>'up'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> <code>combination_method</code> <code>str</code> <p>If spin == 'both', this determines if the spin up and spin down desnities are added or subtracted. ('add' or 'sub')</p> <code>'add'</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def dos_element_orbitals(\n    folder,\n    element_orbital_dict,\n    output=\"dos_element_orbitals.png\",\n    fill=True,\n    alpha=0.3,\n    linewidth=1.5,\n    sigma=0.05,\n    energyaxis=\"x\",\n    color_list=None,\n    legend=True,\n    total=True,\n    figsize=(4, 3),\n    erange=[-6, 6],\n    spin=\"up\",\n    soc_axis=None,\n    combination_method=\"add\",\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n):\n    \"\"\"\n    This function plots the element projected density of states on specific orbitals.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        element_orbital_dict (dict[str:list]): A dictionary that contains the individual elements and the corresponding\n            orbitals to project onto. For example, if the user wants to project onto the s, py, pz, and px orbitals\n            of In and the s orbital of As for and InAs structure then the dictionary would be {'In':[0,1,2,3], 'As':[0]}\n        output (str): File name of the resulting plot.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines whether to draw the legend or not\n        total (bool): Determines wheth to draw the total density of states or not\n        spin (str): Which spin direction to parse ('up' or 'down')\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        combination_method (str): If spin == 'both', this determines if the spin up and spin down\n            desnities are added or subtracted. ('add' or 'sub')\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    dos = Dos(\n        shift_efermi=shift_efermi,\n        folder=folder,\n        spin=spin,\n        combination_method=combination_method,\n    )\n\n    fig = plt.figure(figsize=figsize, dpi=400)\n    ax = fig.add_subplot(111)\n    _figure_setup_dos(ax=ax, fontsize=fontsize, energyaxis=energyaxis)\n\n    dos.plot_element_orbitals(\n        ax=ax,\n        element_orbital_dict=element_orbital_dict,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color_list=color_list,\n        legend=legend,\n        total=total,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.dos_element_orbitals_spin_polarized","title":"<code>dos_element_orbitals_spin_polarized(folder, element_orbital_dict, output='dos_element_orbitals_sp.png', fill=True, alpha=0.3, linewidth=1.5, sigma=0.05, energyaxis='y', soc_axis='z', color_list=None, legend=True, total=True, figsize=(4, 3), erange=[-6, 6], fontsize=12, save=True, shift_efermi=0)</code>","text":"<p>This function plots a spin polarized element projected density of states on specific orbitals.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>element_orbital_dict</code> <code>dict[str</code> <p>list]): A dictionary that contains the individual elements and the corresponding orbitals to project onto. For example, if the user wants to project onto the s, py, pz, and px orbitals of In and the s orbital of As for and InAs structure then the dictionary would be {'In':[0,1,2,3], 'As':[0]}</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'dos_element_orbitals_sp.png'</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'y'</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines whether to draw the legend or not</p> <code>True</code> <code>total</code> <code>bool</code> <p>Determines wheth to draw the total density of states or not</p> <code>True</code> <code>spin</code> <code>str</code> <p>Which spin direction to parse ('up' or 'down')</p> required <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> <code>combination_method</code> <code>str</code> <p>If spin == 'both', this determines if the spin up and spin down desnities are added or subtracted. ('add' or 'sub')</p> required <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def dos_element_orbitals_spin_polarized(\n    folder,\n    element_orbital_dict,\n    output=\"dos_element_orbitals_sp.png\",\n    fill=True,\n    alpha=0.3,\n    linewidth=1.5,\n    sigma=0.05,\n    energyaxis=\"y\",\n    soc_axis=\"z\",\n    color_list=None,\n    legend=True,\n    total=True,\n    figsize=(4, 3),\n    erange=[-6, 6],\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n):\n    \"\"\"\n    This function plots a spin polarized element projected density of states on specific orbitals.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        element_orbital_dict (dict[str:list]): A dictionary that contains the individual elements and the corresponding\n            orbitals to project onto. For example, if the user wants to project onto the s, py, pz, and px orbitals\n            of In and the s orbital of As for and InAs structure then the dictionary would be {'In':[0,1,2,3], 'As':[0]}\n        output (str): File name of the resulting plot.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines whether to draw the legend or not\n        total (bool): Determines wheth to draw the total density of states or not\n        spin (str): Which spin direction to parse ('up' or 'down')\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        combination_method (str): If spin == 'both', this determines if the spin up and spin down\n            desnities are added or subtracted. ('add' or 'sub')\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    dos_up = Dos(\n        shift_efermi=shift_efermi, folder=folder, spin=\"up\", soc_axis=soc_axis\n    )\n    dos_down = Dos(\n        shift_efermi=shift_efermi,\n        folder=folder,\n        spin=\"down\",\n        soc_axis=soc_axis,\n    )\n\n    fig = plt.figure(figsize=figsize, dpi=400)\n    ax = fig.add_subplot(111)\n    _figure_setup_dos(ax=ax, fontsize=fontsize, energyaxis=energyaxis)\n\n    dos_up.plot_element_orbitals(\n        ax=ax,\n        element_orbital_dict=element_orbital_dict,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color_list=color_list,\n        legend=legend,\n        total=total,\n        erange=erange,\n    )\n\n    dos_down.plot_element_orbitals(\n        ax=ax,\n        element_orbital_dict=element_orbital_dict,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color_list=color_list,\n        legend=False,\n        total=total,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.dos_element_spd","title":"<code>dos_element_spd(folder, element_spd_dict, output='dos_element_spd.png', fill=True, alpha=0.3, linewidth=1.5, sigma=0.05, energyaxis='x', color_list=None, legend=True, total=True, figsize=(4, 3), erange=[-6, 6], spin='up', soc_axis=None, combination_method='add', fontsize=12, save=True, shift_efermi=0)</code>","text":"<p>This function plots the element projected density of states of the s, p, and d orbitals.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>element_spd_dict</code> <code>dict[str</code> <p>str]): A dictionary that contains the individual atoms and the corresponding orbitals to project onto. For example, if the user wants to project onto the s, p, d orbitals of In and the p orbitals of As for an InAs structure then the dictionary would be {'In':'spd', 'As':'p'}</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'dos_element_spd.png'</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'x'</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines whether to draw the legend or not</p> <code>True</code> <code>total</code> <code>bool</code> <p>Determines wheth to draw the total density of states or not</p> <code>True</code> <code>spin</code> <code>str</code> <p>Which spin direction to parse ('up' or 'down')</p> <code>'up'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> <code>combination_method</code> <code>str</code> <p>If spin == 'both', this determines if the spin up and spin down desnities are added or subtracted. ('add' or 'sub')</p> <code>'add'</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def dos_element_spd(\n    folder,\n    element_spd_dict,\n    output=\"dos_element_spd.png\",\n    fill=True,\n    alpha=0.3,\n    linewidth=1.5,\n    sigma=0.05,\n    energyaxis=\"x\",\n    color_list=None,\n    legend=True,\n    total=True,\n    figsize=(4, 3),\n    erange=[-6, 6],\n    spin=\"up\",\n    soc_axis=None,\n    combination_method=\"add\",\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n):\n    \"\"\"\n    This function plots the element projected density of states of the s, p, and d orbitals.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        element_spd_dict (dict[str:str]): A dictionary that contains the individual atoms and the corresponding\n            orbitals to project onto. For example, if the user wants to project onto the s, p, d orbitals\n            of In and the p orbitals of As for an InAs structure then the dictionary would be {'In':'spd', 'As':'p'}\n        output (str): File name of the resulting plot.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines whether to draw the legend or not\n        total (bool): Determines wheth to draw the total density of states or not\n        spin (str): Which spin direction to parse ('up' or 'down')\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        combination_method (str): If spin == 'both', this determines if the spin up and spin down\n            desnities are added or subtracted. ('add' or 'sub')\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    dos = Dos(\n        shift_efermi=shift_efermi,\n        folder=folder,\n        spin=spin,\n        combination_method=combination_method,\n    )\n\n    fig = plt.figure(figsize=figsize, dpi=400)\n    ax = fig.add_subplot(111)\n    _figure_setup_dos(ax=ax, fontsize=fontsize, energyaxis=energyaxis)\n\n    dos.plot_element_spd(\n        ax=ax,\n        element_spd_dict=element_spd_dict,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color_list=color_list,\n        legend=legend,\n        total=total,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.dos_element_spd_spin_polarized","title":"<code>dos_element_spd_spin_polarized(folder, element_spd_dict, output='dos_element_spd_sp.png', fill=True, alpha=0.3, linewidth=1.5, sigma=0.05, energyaxis='x', soc_axis='z', color_list=None, legend=True, total=True, figsize=(4, 3), erange=[-6, 6], fontsize=12, save=True, shift_efermi=0)</code>","text":"<p>This function plots a spin polarized element projected density of states of the s, p, and d orbitals.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>element_spd_dict</code> <code>dict[str</code> <p>str]): A dictionary that contains the individual atoms and the corresponding orbitals to project onto. For example, if the user wants to project onto the s, p, d orbitals of In and the p orbitals of As for an InAs structure then the dictionary would be {'In':'spd', 'As':'p'}</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'dos_element_spd_sp.png'</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'x'</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines whether to draw the legend or not</p> <code>True</code> <code>total</code> <code>bool</code> <p>Determines wheth to draw the total density of states or not</p> <code>True</code> <code>spin</code> <code>str</code> <p>Which spin direction to parse ('up' or 'down')</p> required <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> <code>combination_method</code> <code>str</code> <p>If spin == 'both', this determines if the spin up and spin down desnities are added or subtracted. ('add' or 'sub')</p> required <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def dos_element_spd_spin_polarized(\n    folder,\n    element_spd_dict,\n    output=\"dos_element_spd_sp.png\",\n    fill=True,\n    alpha=0.3,\n    linewidth=1.5,\n    sigma=0.05,\n    energyaxis=\"x\",\n    soc_axis=\"z\",\n    color_list=None,\n    legend=True,\n    total=True,\n    figsize=(4, 3),\n    erange=[-6, 6],\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n):\n    \"\"\"\n    This function plots a spin polarized element projected density of states of the s, p, and d orbitals.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        element_spd_dict (dict[str:str]): A dictionary that contains the individual atoms and the corresponding\n            orbitals to project onto. For example, if the user wants to project onto the s, p, d orbitals\n            of In and the p orbitals of As for an InAs structure then the dictionary would be {'In':'spd', 'As':'p'}\n        output (str): File name of the resulting plot.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines whether to draw the legend or not\n        total (bool): Determines wheth to draw the total density of states or not\n        spin (str): Which spin direction to parse ('up' or 'down')\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        combination_method (str): If spin == 'both', this determines if the spin up and spin down\n            desnities are added or subtracted. ('add' or 'sub')\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    dos_up = Dos(\n        shift_efermi=shift_efermi, folder=folder, spin=\"up\", soc_axis=soc_axis\n    )\n    dos_down = Dos(\n        shift_efermi=shift_efermi,\n        folder=folder,\n        spin=\"down\",\n        soc_axis=soc_axis,\n    )\n\n    fig = plt.figure(figsize=figsize, dpi=400)\n    ax = fig.add_subplot(111)\n    _figure_setup_dos(ax=ax, fontsize=fontsize, energyaxis=energyaxis)\n\n    dos_up.plot_element_spd(\n        ax=ax,\n        element_spd_dict=element_spd_dict,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color_list=color_list,\n        legend=legend,\n        total=total,\n        erange=erange,\n    )\n\n    dos_down.plot_element_spd(\n        ax=ax,\n        element_spd_dict=element_spd_dict,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color_list=color_list,\n        legend=False,\n        total=total,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.dos_elements","title":"<code>dos_elements(folder, elements, output='dos_elements.png', fill=True, alpha=0.3, linewidth=1.5, sigma=0.05, energyaxis='x', color_list=None, legend=True, total=True, figsize=(4, 3), erange=[-6, 6], spin='up', soc_axis=None, combination_method='add', fontsize=12, save=True, shift_efermi=0)</code>","text":"<p>This function plots the element projected density of states.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>elements</code> <code>list</code> <p>List of elements to project onto. The list should countain the corresponding element symbols</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'dos_elements.png'</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'x'</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines whether to draw the legend or not</p> <code>True</code> <code>total</code> <code>bool</code> <p>Determines wheth to draw the total density of states or not</p> <code>True</code> <code>spin</code> <code>str</code> <p>Which spin direction to parse ('up' or 'down')</p> <code>'up'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> <code>combination_method</code> <code>str</code> <p>If spin == 'both', this determines if the spin up and spin down desnities are added or subtracted. ('add' or 'sub')</p> <code>'add'</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def dos_elements(\n    folder,\n    elements,\n    output=\"dos_elements.png\",\n    fill=True,\n    alpha=0.3,\n    linewidth=1.5,\n    sigma=0.05,\n    energyaxis=\"x\",\n    color_list=None,\n    legend=True,\n    total=True,\n    figsize=(4, 3),\n    erange=[-6, 6],\n    spin=\"up\",\n    soc_axis=None,\n    combination_method=\"add\",\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n):\n    \"\"\"\n    This function plots the element projected density of states.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        elements (list): List of elements to project onto. The list should countain the corresponding element symbols\n        output (str): File name of the resulting plot.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines whether to draw the legend or not\n        total (bool): Determines wheth to draw the total density of states or not\n        spin (str): Which spin direction to parse ('up' or 'down')\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        combination_method (str): If spin == 'both', this determines if the spin up and spin down\n            desnities are added or subtracted. ('add' or 'sub')\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    dos = Dos(\n        shift_efermi=shift_efermi,\n        folder=folder,\n        spin=spin,\n        combination_method=combination_method,\n    )\n\n    fig = plt.figure(figsize=figsize, dpi=400)\n    ax = fig.add_subplot(111)\n    _figure_setup_dos(ax=ax, fontsize=fontsize, energyaxis=energyaxis)\n\n    dos.plot_elements(\n        ax=ax,\n        elements=elements,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color_list=color_list,\n        legend=legend,\n        total=total,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.dos_elements_spin_polarized","title":"<code>dos_elements_spin_polarized(folder, elements, output='dos_elements_sp.png', fill=True, alpha=0.3, linewidth=1.5, sigma=0.05, energyaxis='y', soc_axis='z', color_list=None, legend=True, total=True, figsize=(4, 3), erange=[-6, 6], fontsize=12, save=True, shift_efermi=0)</code>","text":"<p>This function plots a spin polarized element projected density of states.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>elements</code> <code>list</code> <p>List of elements to project onto. The list should countain the corresponding element symbols</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'dos_elements_sp.png'</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'y'</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines whether to draw the legend or not</p> <code>True</code> <code>total</code> <code>bool</code> <p>Determines wheth to draw the total density of states or not</p> <code>True</code> <code>spin</code> <code>str</code> <p>Which spin direction to parse ('up' or 'down')</p> required <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> <code>combination_method</code> <code>str</code> <p>If spin == 'both', this determines if the spin up and spin down desnities are added or subtracted. ('add' or 'sub')</p> required <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def dos_elements_spin_polarized(\n    folder,\n    elements,\n    output=\"dos_elements_sp.png\",\n    fill=True,\n    alpha=0.3,\n    linewidth=1.5,\n    sigma=0.05,\n    energyaxis=\"y\",\n    soc_axis=\"z\",\n    color_list=None,\n    legend=True,\n    total=True,\n    figsize=(4, 3),\n    erange=[-6, 6],\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n):\n    \"\"\"\n    This function plots a spin polarized element projected density of states.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        elements (list): List of elements to project onto. The list should countain the corresponding element symbols\n        output (str): File name of the resulting plot.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines whether to draw the legend or not\n        total (bool): Determines wheth to draw the total density of states or not\n        spin (str): Which spin direction to parse ('up' or 'down')\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        combination_method (str): If spin == 'both', this determines if the spin up and spin down\n            desnities are added or subtracted. ('add' or 'sub')\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    dos_up = Dos(\n        shift_efermi=shift_efermi, folder=folder, spin=\"up\", soc_axis=soc_axis\n    )\n    dos_down = Dos(\n        shift_efermi=shift_efermi,\n        folder=folder,\n        spin=\"down\",\n        soc_axis=soc_axis,\n    )\n\n    fig = plt.figure(figsize=figsize, dpi=400)\n    ax = fig.add_subplot(111)\n    _figure_setup_dos(ax=ax, fontsize=fontsize, energyaxis=energyaxis)\n\n    dos_up.plot_elements(\n        ax=ax,\n        elements=elements,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color_list=color_list,\n        legend=legend,\n        total=total,\n        erange=erange,\n    )\n\n    dos_down.plot_elements(\n        ax=ax,\n        elements=elements,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color_list=color_list,\n        legend=False,\n        total=total,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.dos_layers","title":"<code>dos_layers(folder, output='dos_layers.png', energyaxis='y', figsize=(5, 3), erange=[-3, 3], lrange=None, spin='up', soc_axis=None, combination_method='add', fontsize=12, save=True, shift_efermi=0, cmap='magma', sigma_energy=0.05, sigma_layers=0.75, antialiased=False, show_structure=False, interface_layer=None, show_interface_line=False, interface_line_color='white', interface_line_style='--', interface_line_width=2, log_scale=True, contour=False, levels=10, min_cutoff=1e-07, max_cutoff=None, atol=None, custom_layer_inds=None, custom_cbar_label=None, plot_vbm_cbm=False, vbm_color='white', cbm_color='white', vbm_linestyle=':', cbm_linestyle=':', cbar_orientation='vertical', show_bounds=False, set_bounds=None, sp_method='percentage')</code>","text":"<p>This function is used to plot a layer by layer density of states heat map for slab structures. It is useful for visualizing band alignment of interfaces.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'dos_layers.png'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(5, 3)</code> <code>spin</code> <code>str</code> <p>Which spin direction to parse ('up' or 'down')</p> <code>'up'</code> <code>combination_method</code> <code>str</code> <p>If spin == 'both', this determines if the spin up and spin down desnities are added or subtracted. ('add' or 'sub')</p> <code>'add'</code> <code>show_structure</code> <code>bool</code> <p>If true, a projected of the structure will be plotted next to the layer by later dos. This feature works best with large slab structures, and has not been fully tested.</p> <code>False</code> <code>cmap</code> <code>str</code> <p>Color map to use in the heat map</p> <code>'magma'</code> <code>sigma_energy</code> <code>float</code> <p>Variance for a gaussian blur with respect to the energy This will help smooth out spikey looking density of states</p> <code>0.05</code> <code>sigma_layers</code> <code>float</code> <p>Variance for a gaussian blur with respect to the layers This will help smooth out the the pixelation that can occur between the summed dos with respect to the layers.</p> <code>0.75</code> <code>energyaxis</code> <code>str</code> <p>Axis to plot the energy on. ('x' or 'y')</p> <code>'y'</code> <code>erange</code> <code>list</code> <p>Upper and lower energy bounds for the plot.</p> <code>[-3, 3]</code> <code>lrange</code> <code>list</code> <p>Upper and lower bounds of the layers included in the plot.</p> <code>None</code> <code>antialiased</code> <code>bool</code> <p>Determines if antialiasing is used or not.</p> <code>False</code> <code>fontsize</code> <code>float</code> <p>Fontsize of all the text in the group.</p> <code>12</code> <code>interface_layer</code> <code>float or None</code> <p>If a value is provided, then the axis labels will be shifted accordingly so that the defined interface layer is zero.</p> <code>None</code> <code>show_interface_line</code> <code>bool</code> <p>If True, then a line will be drawn on the plot to identify the interface layer defined by interface_layer.</p> <code>False</code> <code>interface_line_color</code> <code>str</code> <p>Color of the line drawn on the plot to mark the interface.</p> <code>'white'</code> <code>interface_line_width</code> <code>float</code> <p>Line with of the line marking the interface.</p> <code>2</code> <code>interface_line_style</code> <code>str</code> <p>Style of the line marking the interface.</p> <code>'--'</code> <code>log_scale</code> <code>bool</code> <p>Determines if the color map is applied in log scale of not. Recommended in order to accurately view the band gap and smaller features.</p> <code>True</code> <code>contour</code> <code>bool</code> <p>Determines if the color map is plotted as a contour plot instead of a heatmap.</p> <code>False</code> <code>levels</code> <code>int</code> <p>Number of levels used in the contour plot.</p> <code>10</code> <code>min_cutoff</code> <code>float</code> <p>Minimum dos value used to determine the cut off for the plot. This can be adjusted to better visualize the band gap of the material.</p> <code>1e-07</code> <code>max_cutoff</code> <code>float</code> <p>Maximum dos value used to determine the cut off for the plot. This can be adjusted to better visualize the band gap of the material.</p> <code>None</code> <code>atol</code> <code>float or None</code> <p>Tolarence used in the grouping of the layers. This value is automatically calculated if None and is usually on the order of 1e-3.</p> <code>None</code> <code>custom_layer_inds</code> <code>list or None</code> <p>If the structure being calculated has relaxed atomic positions, sometimes the layer grouping algorithm can behave non-idealy. If this is the case, the user can input a list of list that contain the atomic indices in each layers of the material.</p> <code>None</code> <code>custom_cbar_label</code> <code>str or None</code> <p>Custom label for the colorbar</p> <code>None</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <code>plot_vbm_cbm</code> <code>bool</code> <p>Determines if the valence band maximum and conduction band minimum are plotted on the graph.</p> <code>False</code> <code>vbm_color</code> <code>str</code> <p>Color of the vbm line.</p> <code>'white'</code> <code>cbm_color</code> <code>str</code> <p>Color of the cbm line.</p> <code>'white'</code> <code>vbm_linestyle</code> <code>str</code> <p>Linestyle of the vbm line.</p> <code>':'</code> <code>cbm_linestyle</code> <code>str</code> <p>Linestyle of the cbm line.</p> <code>':'</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def dos_layers(\n    folder,\n    output=\"dos_layers.png\",\n    energyaxis=\"y\",\n    figsize=(5, 3),\n    erange=[-3, 3],\n    lrange=None,\n    spin=\"up\",\n    soc_axis=None,\n    combination_method=\"add\",\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n    cmap=\"magma\",\n    sigma_energy=0.05,\n    sigma_layers=0.75,\n    antialiased=False,\n    show_structure=False,\n    interface_layer=None,\n    show_interface_line=False,\n    interface_line_color=\"white\",\n    interface_line_style=\"--\",\n    interface_line_width=2,\n    log_scale=True,\n    contour=False,\n    levels=10,\n    min_cutoff=1e-7,\n    max_cutoff=None,\n    atol=None,\n    custom_layer_inds=None,\n    custom_cbar_label=None,\n    plot_vbm_cbm=False,\n    vbm_color=\"white\",\n    cbm_color=\"white\",\n    vbm_linestyle=\":\",\n    cbm_linestyle=\":\",\n    cbar_orientation=\"vertical\",\n    show_bounds=False,\n    set_bounds=None,\n    sp_method=\"percentage\",\n):\n    \"\"\"\n    This function is used to plot a layer by layer density of states heat map for slab structures. It is useful for\n    visualizing band alignment of interfaces.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        output (str): File name of the resulting plot.\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        spin (str): Which spin direction to parse ('up' or 'down')\n        combination_method (str): If spin == 'both', this determines if the spin up and spin down\n            desnities are added or subtracted. ('add' or 'sub')\n        show_structure (bool): If true, a projected of the structure will be plotted next to the\n            layer by later dos. This feature works best with large slab structures, and has not\n            been fully tested.\n        cmap (str): Color map to use in the heat map\n        sigma_energy (float): Variance for a gaussian blur with respect to the energy\n            This will help smooth out spikey looking density of states\n        sigma_layers (float): Variance for a gaussian blur with respect to the layers\n            This will help smooth out the the pixelation that can occur between the summed\n            dos with respect to the layers.\n        energyaxis (str): Axis to plot the energy on. ('x' or 'y')\n        erange (list): Upper and lower energy bounds for the plot.\n        lrange (list): Upper and lower bounds of the layers included in the plot.\n        antialiased (bool): Determines if antialiasing is used or not.\n        fontsize (float): Fontsize of all the text in the group.\n        interface_layer (float or None): If a value is provided, then the axis labels will be\n            shifted accordingly so that the defined interface layer is zero.\n        show_interface_line (bool): If True, then a line will be drawn\n            on the plot to identify the interface layer defined by interface_layer.\n        interface_line_color (str): Color of the line drawn on the plot to mark the\n            interface.\n        interface_line_width (float): Line with of the line marking the interface.\n        interface_line_style (str): Style of the line marking the interface.\n        log_scale (bool): Determines if the color map is applied in log scale of not.\n            Recommended in order to accurately view the band gap and smaller features.\n        contour (bool): Determines if the color map is plotted as a contour plot instead\n            of a heatmap.\n        levels (int): Number of levels used in the contour plot.\n        min_cutoff (float): Minimum dos value used to determine the cut off for the plot.\n            This can be adjusted to better visualize the band gap of the material.\n        max_cutoff (float): Maximum dos value used to determine the cut off for the plot.\n            This can be adjusted to better visualize the band gap of the material.\n        atol (float or None): Tolarence used in the grouping of the layers.\n            This value is automatically calculated if None and is usually on the order of\n            1e-3.\n        custom_layer_inds (list or None): If the structure being calculated has relaxed\n            atomic positions, sometimes the layer grouping algorithm can behave non-idealy.\n            If this is the case, the user can input a list of list that contain the\n            atomic indices in each layers of the material.\n        custom_cbar_label (str or None): Custom label for the colorbar\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n        plot_vbm_cbm (bool): Determines if the valence band maximum and conduction band minimum\n            are plotted on the graph.\n        vbm_color (str): Color of the vbm line.\n        cbm_color (str): Color of the cbm line.\n        vbm_linestyle (str): Linestyle of the vbm line.\n        cbm_linestyle (str): Linestyle of the cbm line.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n    if show_structure:\n        if energyaxis == \"x\":\n            fig, axs = plt.subplots(\n                nrows=1,\n                ncols=2,\n                gridspec_kw={\"width_ratios\": [1, 6]},\n                figsize=figsize,\n                dpi=400,\n            )\n            structure_ax = axs[0]\n            dos_ax = axs[1]\n\n        elif energyaxis == \"y\":\n            fig, axs = plt.subplots(\n                nrows=2,\n                ncols=1,\n                gridspec_kw={\"height_ratios\": [1, 6], \"hspace\": -0.02},\n                figsize=figsize,\n                dpi=400,\n            )\n            structure_ax = axs[0]\n            sm = plt.cm.ScalarMappable()\n            sm.set_array([])\n            fig.colorbar(sm, ax=structure_ax).ax.set_visible(False)\n            dos_ax = axs[1]\n\n        structure_ax.spines[\"left\"].set_visible(False)\n        structure_ax.spines[\"right\"].set_visible(False)\n        structure_ax.spines[\"top\"].set_visible(False)\n        structure_ax.spines[\"bottom\"].set_visible(False)\n\n        structure_ax.tick_params(\n            left=False,\n            bottom=False,\n            labelleft=False,\n            labelbottom=False,\n        )\n\n    else:\n        fig = plt.figure(figsize=figsize, dpi=400)\n        dos_ax = fig.add_subplot(111)\n\n    _figure_setup_layer_dos(\n        ax=dos_ax, fontsize=fontsize, energyaxis=energyaxis\n    )\n\n    dos = Dos(\n        shift_efermi=shift_efermi,\n        folder=folder,\n        spin=spin,\n        soc_axis=soc_axis,\n        combination_method=combination_method,\n        sp_method=sp_method,\n    )\n    dos.plot_layers(\n        ax=dos_ax,\n        sigma_layers=sigma_layers,\n        sigma_energy=sigma_energy,\n        cmap=cmap,\n        erange=erange,\n        lrange=lrange,\n        antialiased=antialiased,\n        fontsize=fontsize,\n        energyaxis=energyaxis,\n        interface_layer=interface_layer,\n        show_interface_line=show_interface_line,\n        interface_line_color=interface_line_color,\n        interface_line_style=interface_line_style,\n        interface_line_width=interface_line_width,\n        log_scale=log_scale,\n        contour=contour,\n        levels=levels,\n        min_cutoff=min_cutoff,\n        max_cutoff=max_cutoff,\n        atol=atol,\n        custom_cbar_label=custom_cbar_label,\n        custom_layer_inds=custom_layer_inds,\n        cbar_orientation=cbar_orientation,\n        show_bounds=show_bounds,\n        set_bounds=set_bounds,\n    )\n\n    if plot_vbm_cbm:\n        gap = BandGap(folder=folder)\n        vbm = gap.vbm\n        cbm = gap.cbm\n        # _, vbm, cbm = get_bandgap(folder=folder, printbg=False, return_vbm_cbm=True)\n\n        if energyaxis == \"y\":\n            dos_ax.axhline(\n                y=cbm,\n                color=cbm_color,\n                linestyle=cbm_linestyle,\n            )\n            dos_ax.axhline(\n                y=vbm,\n                color=vbm_color,\n                linestyle=vbm_linestyle,\n            )\n        elif energyaxis == \"x\":\n            dos_ax.axvline(\n                x=cbm,\n                color=cbm_color,\n                linestyle=cbm_linestyle,\n            )\n            dos_ax.axvline(\n                x=vbm,\n                color=vbm_color,\n                linestyle=vbm_linestyle,\n            )\n\n    if energyaxis == \"y\":\n        dos_ax.set_ylim(erange[0], erange[1])\n    elif energyaxis == \"x\":\n        dos_ax.set_xlim(erange[0], erange[1])\n\n    if show_structure:\n        if energyaxis == \"y\":\n            dos.plot_structure(ax=structure_ax, rotation=[90, 90, 90])\n        elif energyaxis == \"x\":\n            dos.plot_structure(ax=structure_ax, rotation=[0, 90, 90])\n            fig.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output, bbox_inches=\"tight\")\n    else:\n        if show_structure:\n            return fig, dos_ax, structure_ax\n        else:\n            return fig, dos_ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.dos_ldos","title":"<code>dos_ldos(folder, layers, output='dos_ldos.png', linewidth=1.5, fill=True, alpha=0.3, sigma=0.05, energyaxis='x', color='black', figsize=(4, 3), erange=[-6, 6], spin='up', soc_axis=None, combination_method='add', fontsize=12, save=True, shift_efermi=0, log_scale=False, atol=None, custom_layer_inds=None, linestyle='-')</code>","text":"<p>This function plots the local density of states for atomic layers. Useful for comparing to STS measurments.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>layers</code> <code>list</code> <p>List of atomic layers to include in the ldos plot. 0 = first layer</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'dos_ldos.png'</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'x'</code> <code>color</code> <code>list</code> <p>Color of plot and fill.</p> <code>'black'</code> <code>spin</code> <code>str</code> <p>Which spin direction to parse ('up' or 'down')</p> <code>'up'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> <code>combination_method</code> <code>str</code> <p>If spin == 'both', this determines if the spin up and spin down desnities are added or subtracted. ('add' or 'sub')</p> <code>'add'</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def dos_ldos(\n    folder,\n    layers,\n    output=\"dos_ldos.png\",\n    linewidth=1.5,\n    fill=True,\n    alpha=0.3,\n    sigma=0.05,\n    energyaxis=\"x\",\n    color=\"black\",\n    figsize=(4, 3),\n    erange=[-6, 6],\n    spin=\"up\",\n    soc_axis=None,\n    combination_method=\"add\",\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n    log_scale=False,\n    atol=None,\n    custom_layer_inds=None,\n    linestyle=\"-\",\n):\n    \"\"\"\n    This function plots the local density of states for atomic layers. Useful for comparing\n    to STS measurments.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        layers (list): List of atomic layers to include in the ldos plot. 0 = first layer\n        output (str): File name of the resulting plot.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color (list): Color of plot and fill.\n        spin (str): Which spin direction to parse ('up' or 'down')\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        combination_method (str): If spin == 'both', this determines if the spin up and spin down\n            desnities are added or subtracted. ('add' or 'sub')\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    dos = Dos(\n        shift_efermi=shift_efermi,\n        folder=folder,\n        spin=spin,\n        combination_method=combination_method,\n    )\n\n    fig = plt.figure(figsize=figsize, dpi=400)\n    ax = fig.add_subplot(111)\n    _figure_setup_dos(\n        ax=ax, fontsize=fontsize, energyaxis=energyaxis, log_scale=log_scale\n    )\n\n    dos.plot_ldos(\n        ax=ax,\n        layers=layers,\n        linewidth=linewidth,\n        fill=fill,\n        alpha=alpha,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color=color,\n        erange=erange,\n        log_scale=log_scale,\n        atol=atol,\n        custom_layer_inds=custom_layer_inds,\n        linestyle=linestyle,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.dos_orbitals","title":"<code>dos_orbitals(folder, orbitals, output='dos_orbitals.png', fill=True, alpha=0.3, linewidth=1.5, sigma=0.05, energyaxis='x', color_list=None, legend=True, total=True, figsize=(4, 3), erange=[-6, 6], spin='up', soc_axis=None, combination_method='add', fontsize=12, save=True, shift_efermi=0)</code>","text":"<p>This function plots the orbital projected density of states.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>orbitals</code> <code>list</code> <p>List of orbitals to compare</p> <p>| 0 = s | 1 = py | 2 = pz | 3 = px | 4 = dxy | 5 = dyz | 6 = dz2 | 7 = dxz | 8 = dx2-y2 | 9 = fy3x2 | 10 = fxyz | 11 = fyz2 | 12 = fz3 | 13 = fxz2 | 14 = fzx3 | 15 = fx3</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'dos_orbitals.png'</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'x'</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines whether to draw the legend or not</p> <code>True</code> <code>total</code> <code>bool</code> <p>Determines wheth to draw the total density of states or not</p> <code>True</code> <code>spin</code> <code>str</code> <p>Which spin direction to parse ('up' or 'down')</p> <code>'up'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> <code>combination_method</code> <code>str</code> <p>If spin == 'both', this determines if the spin up and spin down desnities are added or subtracted. ('add' or 'sub')</p> <code>'add'</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def dos_orbitals(\n    folder,\n    orbitals,\n    output=\"dos_orbitals.png\",\n    fill=True,\n    alpha=0.3,\n    linewidth=1.5,\n    sigma=0.05,\n    energyaxis=\"x\",\n    color_list=None,\n    legend=True,\n    total=True,\n    figsize=(4, 3),\n    erange=[-6, 6],\n    spin=\"up\",\n    soc_axis=None,\n    combination_method=\"add\",\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n):\n    \"\"\"\n    This function plots the orbital projected density of states.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        orbitals (list): List of orbitals to compare\n\n            | 0 = s\n            | 1 = py\n            | 2 = pz\n            | 3 = px\n            | 4 = dxy\n            | 5 = dyz\n            | 6 = dz2\n            | 7 = dxz\n            | 8 = dx2-y2\n            | 9 = fy3x2\n            | 10 = fxyz\n            | 11 = fyz2\n            | 12 = fz3\n            | 13 = fxz2\n            | 14 = fzx3\n            | 15 = fx3\n\n        output (str): File name of the resulting plot.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines whether to draw the legend or not\n        total (bool): Determines wheth to draw the total density of states or not\n        spin (str): Which spin direction to parse ('up' or 'down')\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        combination_method (str): If spin == 'both', this determines if the spin up and spin down\n            desnities are added or subtracted. ('add' or 'sub')\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    dos = Dos(\n        shift_efermi=shift_efermi,\n        folder=folder,\n        spin=spin,\n        combination_method=combination_method,\n    )\n\n    fig = plt.figure(figsize=figsize, dpi=400)\n    ax = fig.add_subplot(111)\n    _figure_setup_dos(ax=ax, fontsize=fontsize, energyaxis=energyaxis)\n\n    dos.plot_orbitals(\n        ax=ax,\n        orbitals=orbitals,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color_list=color_list,\n        legend=legend,\n        total=total,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.dos_orbitals_spin_polarized","title":"<code>dos_orbitals_spin_polarized(folder, orbitals, output='dos_orbitals_sp.png', fill=True, alpha=0.3, linewidth=1.5, sigma=0.05, energyaxis='y', soc_axis='z', color_list=None, legend=True, total=True, figsize=(4, 3), erange=[-6, 6], fontsize=12, save=True, shift_efermi=0)</code>","text":"<p>This function plots a spin polarized orbital projected density of states.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>orbitals</code> <code>list</code> <p>List of orbitals to compare</p> <p>| 0 = s | 1 = py | 2 = pz | 3 = px | 4 = dxy | 5 = dyz | 6 = dz2 | 7 = dxz | 8 = dx2-y2 | 9 = fy3x2 | 10 = fxyz | 11 = fyz2 | 12 = fz3 | 13 = fxz2 | 14 = fzx3 | 15 = fx3</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'dos_orbitals_sp.png'</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'y'</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines whether to draw the legend or not</p> <code>True</code> <code>total</code> <code>bool</code> <p>Determines wheth to draw the total density of states or not</p> <code>True</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def dos_orbitals_spin_polarized(\n    folder,\n    orbitals,\n    output=\"dos_orbitals_sp.png\",\n    fill=True,\n    alpha=0.3,\n    linewidth=1.5,\n    sigma=0.05,\n    energyaxis=\"y\",\n    soc_axis=\"z\",\n    color_list=None,\n    legend=True,\n    total=True,\n    figsize=(4, 3),\n    erange=[-6, 6],\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n):\n    \"\"\"\n    This function plots a spin polarized orbital projected density of states.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        orbitals (list): List of orbitals to compare\n\n            | 0 = s\n            | 1 = py\n            | 2 = pz\n            | 3 = px\n            | 4 = dxy\n            | 5 = dyz\n            | 6 = dz2\n            | 7 = dxz\n            | 8 = dx2-y2\n            | 9 = fy3x2\n            | 10 = fxyz\n            | 11 = fyz2\n            | 12 = fz3\n            | 13 = fxz2\n            | 14 = fzx3\n            | 15 = fx3\n\n        output (str): File name of the resulting plot.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines whether to draw the legend or not\n        total (bool): Determines wheth to draw the total density of states or not\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    dos_up = Dos(\n        shift_efermi=shift_efermi, folder=folder, spin=\"up\", soc_axis=soc_axis\n    )\n    dos_down = Dos(\n        shift_efermi=shift_efermi,\n        folder=folder,\n        spin=\"down\",\n        soc_axis=soc_axis,\n    )\n\n    fig = plt.figure(figsize=figsize, dpi=400)\n    ax = fig.add_subplot(111)\n    _figure_setup_dos(ax=ax, fontsize=fontsize, energyaxis=energyaxis)\n\n    dos_up.plot_orbitals(\n        ax=ax,\n        orbitals=orbitals,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color_list=color_list,\n        legend=legend,\n        total=total,\n        erange=erange,\n    )\n\n    dos_down.plot_orbitals(\n        ax=ax,\n        orbitals=orbitals,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color_list=color_list,\n        legend=False,\n        total=total,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.dos_plain","title":"<code>dos_plain(folder, output='dos_plain.png', linewidth=1.5, fill=True, alpha=0.3, sigma=0.05, energyaxis='x', color='black', figsize=(4, 3), erange=[-6, 6], spin='up', soc_axis=None, combination_method='add', fontsize=12, save=True, shift_efermi=0, log_scale=False)</code>","text":"<p>This function plots the total density of states.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'dos_plain.png'</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'x'</code> <code>color</code> <code>list</code> <p>Color of plot and fill.</p> <code>'black'</code> <code>spin</code> <code>str</code> <p>Which spin direction to parse ('up' or 'down')</p> <code>'up'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> <code>combination_method</code> <code>str</code> <p>If spin == 'both', this determines if the spin up and spin down desnities are added or subtracted. ('add' or 'sub')</p> <code>'add'</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def dos_plain(\n    folder,\n    output=\"dos_plain.png\",\n    linewidth=1.5,\n    fill=True,\n    alpha=0.3,\n    sigma=0.05,\n    energyaxis=\"x\",\n    color=\"black\",\n    figsize=(4, 3),\n    erange=[-6, 6],\n    spin=\"up\",\n    soc_axis=None,\n    combination_method=\"add\",\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n    log_scale=False,\n):\n    \"\"\"\n    This function plots the total density of states.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        output (str): File name of the resulting plot.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color (list): Color of plot and fill.\n        spin (str): Which spin direction to parse ('up' or 'down')\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        combination_method (str): If spin == 'both', this determines if the spin up and spin down\n            desnities are added or subtracted. ('add' or 'sub')\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    dos = Dos(\n        shift_efermi=shift_efermi,\n        folder=folder,\n        spin=spin,\n        combination_method=combination_method,\n    )\n\n    fig = plt.figure(figsize=figsize, dpi=400)\n    ax = fig.add_subplot(111)\n    _figure_setup_dos(ax=ax, fontsize=fontsize, energyaxis=energyaxis)\n\n    dos.plot_plain(\n        ax=ax,\n        linewidth=linewidth,\n        fill=fill,\n        alpha=alpha,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color=color,\n        erange=erange,\n        log_scale=log_scale,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.dos_plain_spin_polarized","title":"<code>dos_plain_spin_polarized(folder, output='dos_plain_sp.png', linewidth=1.5, fill=True, alpha=0.3, sigma=0.05, energyaxis='x', soc_axis='z', color='black', figsize=(4, 3), erange=[-6, 6], fontsize=12, save=True, shift_efermi=0)</code>","text":"<p>This function plots the spin polarized total density of states.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'dos_plain_sp.png'</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'x'</code> <code>color</code> <code>str</code> <p>Color of plot and fill.</p> <code>'black'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def dos_plain_spin_polarized(\n    folder,\n    output=\"dos_plain_sp.png\",\n    linewidth=1.5,\n    fill=True,\n    alpha=0.3,\n    sigma=0.05,\n    energyaxis=\"x\",\n    soc_axis=\"z\",\n    color=\"black\",\n    figsize=(4, 3),\n    erange=[-6, 6],\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n):\n    \"\"\"\n    This function plots the spin polarized total density of states.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        output (str): File name of the resulting plot.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color (str): Color of plot and fill.\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    dos_up = Dos(\n        shift_efermi=shift_efermi, folder=folder, spin=\"up\", soc_axis=soc_axis\n    )\n    dos_down = Dos(\n        shift_efermi=shift_efermi,\n        folder=folder,\n        spin=\"down\",\n        soc_axis=soc_axis,\n    )\n\n    fig = plt.figure(figsize=figsize, dpi=400)\n    ax = fig.add_subplot(111)\n    _figure_setup_dos(ax=ax, fontsize=fontsize, energyaxis=energyaxis)\n\n    dos_up.plot_plain(\n        ax=ax,\n        linewidth=linewidth,\n        fill=fill,\n        alpha=alpha,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color=color,\n        erange=erange,\n    )\n\n    dos_down.plot_plain(\n        ax=ax,\n        linewidth=linewidth,\n        fill=fill,\n        alpha=alpha,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color=color,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.dos_spd","title":"<code>dos_spd(folder, output='dos_spd.png', orbitals='spd', fill=True, alpha=0.3, linewidth=1.5, sigma=0.05, energyaxis='x', color_list=None, legend=True, total=True, figsize=(4, 3), erange=[-6, 6], spin='up', soc_axis=None, combination_method='add', fontsize=12, save=True, shift_efermi=0)</code>","text":"<p>This function plots an s, p, d projected density of states.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>orbitals</code> <code>str</code> <p>String that contains the s, p, or d orbitals that to project onto. The default is 'spd', if the user only wanted to project onto the p, and d orbitals than 'pd' should be passed in</p> <code>'spd'</code> <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'dos_spd.png'</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'x'</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines whether to draw the legend or not</p> <code>True</code> <code>total</code> <code>bool</code> <p>Determines wheth to draw the total density of states or not</p> <code>True</code> <code>spin</code> <code>str</code> <p>Which spin direction to parse ('up' or 'down')</p> <code>'up'</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> <code>combination_method</code> <code>str</code> <p>If spin == 'both', this determines if the spin up and spin down desnities are added or subtracted. ('add' or 'sub')</p> <code>'add'</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def dos_spd(\n    folder,\n    output=\"dos_spd.png\",\n    orbitals=\"spd\",\n    fill=True,\n    alpha=0.3,\n    linewidth=1.5,\n    sigma=0.05,\n    energyaxis=\"x\",\n    color_list=None,\n    legend=True,\n    total=True,\n    figsize=(4, 3),\n    erange=[-6, 6],\n    spin=\"up\",\n    soc_axis=None,\n    combination_method=\"add\",\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n):\n    \"\"\"\n    This function plots an s, p, d projected density of states.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        orbitals (str): String that contains the s, p, or d orbitals that to project onto.\n            The default is 'spd', if the user only wanted to project onto the p, and d orbitals\n            than 'pd' should be passed in\n        output (str): File name of the resulting plot.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines whether to draw the legend or not\n        total (bool): Determines wheth to draw the total density of states or not\n        spin (str): Which spin direction to parse ('up' or 'down')\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        combination_method (str): If spin == 'both', this determines if the spin up and spin down\n            desnities are added or subtracted. ('add' or 'sub')\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    dos = Dos(\n        shift_efermi=shift_efermi,\n        folder=folder,\n        spin=spin,\n        combination_method=combination_method,\n    )\n\n    fig = plt.figure(figsize=figsize, dpi=400)\n    ax = fig.add_subplot(111)\n    _figure_setup_dos(ax=ax, fontsize=fontsize, energyaxis=energyaxis)\n\n    dos.plot_spd(\n        ax=ax,\n        orbitals=orbitals,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color_list=color_list,\n        legend=legend,\n        total=total,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"standard/#vaspvis.standard.dos_spd_spin_polarized","title":"<code>dos_spd_spin_polarized(folder, output='dos_spd_sp.png', orbitals='spd', fill=True, alpha=0.3, linewidth=1.5, sigma=0.05, energyaxis='x', soc_axis='z', color_list=None, legend=True, total=True, figsize=(4, 3), erange=[-6, 6], fontsize=12, save=True, shift_efermi=0)</code>","text":"<p>This function plots a spin polarized s, p, d projected density of states.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>This is the folder that contains the VASP files</p> required <code>orbitals</code> <code>str</code> <p>String that contains the s, p, or d orbitals that to project onto. The default is 'spd', if the user only wanted to project onto the p, and d orbitals than 'pd' should be passed in</p> <code>'spd'</code> <code>output</code> <code>str</code> <p>File name of the resulting plot.</p> <code>'dos_spd_sp.png'</code> <code>fill</code> <code>bool</code> <p>Determines wether or not to fill underneath the plot</p> <code>True</code> <code>alpha</code> <code>float</code> <p>Alpha value for the fill</p> <code>0.3</code> <code>linewidth</code> <code>float</code> <p>Linewidth of lines</p> <code>1.5</code> <code>sigma</code> <code>float</code> <p>Standard deviation for gaussian filter</p> <code>0.05</code> <code>energyaxis</code> <code>str</code> <p>Determines the axis to plot the energy on ('x' or 'y')</p> <code>'x'</code> <code>color_list</code> <code>list</code> <p>List of colors that is the same length as the number of projections in the plot.</p> <code>None</code> <code>legend</code> <code>bool</code> <p>Determines whether to draw the legend or not</p> <code>True</code> <code>total</code> <code>bool</code> <p>Determines wheth to draw the total density of states or not</p> <code>True</code> <code>figsize</code> <code>list / tuple</code> <p>Desired size of the image in inches (width, height)</p> <code>(4, 3)</code> <code>erange</code> <code>list</code> <p>Energy range for the DOS plot ([lower bound, upper bound])</p> <code>[-6, 6]</code> <code>fontsize</code> <code>float</code> <p>Font size of the text in the figure.</p> <code>12</code> <code>save</code> <code>bool</code> <p>Determines whether to automatically save the figure or not. If not the figure and axis are return for further manipulation.</p> <code>True</code> <p>Returns:</p> Type Description <p>If save == True, this function will return nothing and directly save the image as</p> <p>the output name. If save == False, the function will return the matplotlib figure</p> <p>and axis for further editing.</p> Source code in <code>vaspvis/standard.py</code> <pre><code>def dos_spd_spin_polarized(\n    folder,\n    output=\"dos_spd_sp.png\",\n    orbitals=\"spd\",\n    fill=True,\n    alpha=0.3,\n    linewidth=1.5,\n    sigma=0.05,\n    energyaxis=\"x\",\n    soc_axis=\"z\",\n    color_list=None,\n    legend=True,\n    total=True,\n    figsize=(4, 3),\n    erange=[-6, 6],\n    fontsize=12,\n    save=True,\n    shift_efermi=0,\n):\n    \"\"\"\n    This function plots a spin polarized s, p, d projected density of states.\n\n    Parameters:\n        folder (str): This is the folder that contains the VASP files\n        orbitals (str): String that contains the s, p, or d orbitals that to project onto.\n            The default is 'spd', if the user only wanted to project onto the p, and d orbitals\n            than 'pd' should be passed in\n        output (str): File name of the resulting plot.\n        fill (bool): Determines wether or not to fill underneath the plot\n        alpha (float): Alpha value for the fill\n        linewidth (float): Linewidth of lines\n        sigma (float): Standard deviation for gaussian filter\n        energyaxis (str): Determines the axis to plot the energy on ('x' or 'y')\n        color_list (list): List of colors that is the same length as the number of projections\n            in the plot.\n        legend (bool): Determines whether to draw the legend or not\n        total (bool): Determines wheth to draw the total density of states or not\n        figsize (list / tuple): Desired size of the image in inches (width, height)\n        erange (list): Energy range for the DOS plot ([lower bound, upper bound])\n        fontsize (float): Font size of the text in the figure.\n        save (bool): Determines whether to automatically save the figure or not. If not\n            the figure and axis are return for further manipulation.\n\n    Returns:\n        If save == True, this function will return nothing and directly save the image as\n        the output name. If save == False, the function will return the matplotlib figure\n        and axis for further editing.\n    \"\"\"\n\n    dos_up = Dos(\n        shift_efermi=shift_efermi, folder=folder, spin=\"up\", soc_axis=soc_axis\n    )\n    dos_down = Dos(\n        shift_efermi=shift_efermi,\n        folder=folder,\n        spin=\"down\",\n        soc_axis=soc_axis,\n    )\n\n    fig = plt.figure(figsize=figsize, dpi=400)\n    ax = fig.add_subplot(111)\n    _figure_setup_dos(ax=ax, fontsize=fontsize, energyaxis=energyaxis)\n\n    dos_up.plot_spd(\n        ax=ax,\n        orbitals=orbitals,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color_list=color_list,\n        legend=legend,\n        total=total,\n        erange=erange,\n    )\n\n    dos_down.plot_spd(\n        ax=ax,\n        orbitals=orbitals,\n        fill=fill,\n        alpha=alpha,\n        linewidth=linewidth,\n        sigma=sigma,\n        energyaxis=energyaxis,\n        color_list=color_list,\n        legend=False,\n        total=total,\n        erange=erange,\n    )\n\n    plt.tight_layout(pad=0.4)\n\n    if save:\n        plt.savefig(output)\n    else:\n        return fig, ax\n</code></pre>"},{"location":"stm/","title":"STM Images","text":""},{"location":"stm/#stmpy","title":"stm.py","text":""},{"location":"stm/#vaspvis.stm.STM","title":"<code>STM</code>","text":"<p>This class contains all the methods for generating STM images with VASP</p> Source code in <code>vaspvis/stm.py</code> <pre><code>class STM:\n    \"\"\"\n    This class contains all the methods for generating STM images with VASP\n    \"\"\"\n\n    def __init__(\n        self,\n        folder,\n        custom_color_dict = None,\n    ):\n        self.folder = folder\n        self.preloaded_data = os.path.isfile(os.path.join(folder, 'parchg.npy'))\n        self.poscar = Poscar.from_file(\n            os.path.join(folder, 'POSCAR'),\n            check_for_POTCAR=False,\n            read_velocities=False\n        )\n        self.data, self.a_vals, self.b_vals, self.c_vals = self._load_parchg()\n        [self.bottom_surface,\n        self.bottom_ind,\n        self.top_surface,\n        self.top_ind] = self._get_surface_heights()\n        self.X = None\n        self.Y = None\n        self.Z = None\n        self.x_shift = None\n        self.y_shift = None\n\n    def _load_parchg(self):\n        if self.preloaded_data:\n            with open(os.path.join(self.folder, 'parchg.npy'), 'rb') as p:\n                data = np.load(p)\n        else:\n            parchg = Chgcar.from_file(os.path.join(self.folder, 'PARCHG'))\n            data = parchg.data['total']\n            np.save(os.path.join(self.folder, 'parchg.npy'), data)\n\n        a_vals = np.linspace(0,1,data.shape[0])\n        b_vals = np.linspace(0,1,data.shape[1])\n        c_vals = np.linspace(0,1,data.shape[2])\n\n        return data, a_vals, b_vals, c_vals\n\n    def _get_surface_heights(self):\n        bottom_surface = self.poscar.structure.frac_coords[:,-1].min()\n        top_surface = self.poscar.structure.frac_coords[:,-1].max()\n        bottom_ind = np.argmin((self.c_vals - bottom_surface)**2)\n        top_ind = np.argmin((self.c_vals - top_surface)**2)\n\n        return bottom_surface, bottom_ind, top_surface, top_ind\n\n    def _interp(self, x, x1, x2, y1, y2):\n        return y1 + (((y2 - y1) / (x2 - x1)) * (x - x1)) \n\n    def _rotate_structure(self, structure, angle):\n        copy_structure = copy.copy(structure)\n        angle = angle * (np.pi / 180)\n        operation = SymmOp.from_rotation_and_translation(\n            rotation_matrix=np.array([\n                [np.cos(angle), -np.sin(angle), 0],\n                [np.sin(angle), np.cos(angle), 0],\n                [0,0,1],\n            ]),\n            translation_vec=[0,0,0],\n        )\n        copy_structure.apply_operation(operation, fractional=False)\n\n        return copy_structure\n\n    def _get_constant_current_isosurface(self, current, sigma=6, top=True):\n        slab_middle_ind = int((self.top_ind + self.bottom_ind) / 2)\n        cell_middle_ind = int(self.data.shape[-1] / 2)\n        shift = cell_middle_ind - slab_middle_ind\n        init_shape = self.data.shape[:2]\n        shifted_slab = np.roll(\n            self.data,\n            shift,\n            axis=2,\n        )\n        c_vals = self.c_vals\n        c_vals_extended = np.hstack([c_vals[:-1] - 1, c_vals, c_vals[1:] + 1])\n        shifted_cvals = np.roll(\n            c_vals_extended,\n            shift,\n        )\n        shifted_cvals = shifted_cvals[len(c_vals)-1:(2*len(c_vals))-1]\n\n        if top:\n            shifted_slab = shifted_slab[:,:,self.top_ind+shift:]\n            shifted_cvals = shifted_cvals[self.top_ind+shift:]\n        else:\n            shifted_slab = shifted_slab[:,:,:self.bottom_ind+shift]\n            shifted_cvals = shifted_cvals[:self.bottom_ind+shift]\n\n\n        if top:\n            heights = np.zeros(shifted_slab.shape[:2])\n            inds = np.zeros(shifted_slab.shape[:2], dtype=bool)\n            for i in range(0, shifted_slab.shape[-1]-1)[::-1]:\n                points = inds &lt; (shifted_slab[:,:,i] &gt; current)\n                x1 = shifted_slab[points, i]\n                x2 = shifted_slab[points, i+1]\n                y1 = shifted_cvals[i]\n                y2 = shifted_cvals[i+1]\n                heights[points] = self._interp(\n                    x=current,\n                    x1=x1,\n                    x2=x2,\n                    y1=y1,\n                    y2=y2,\n                )\n                inds[points] = True\n\n            heights[heights &lt;= self.top_surface] = heights[heights &gt; self.top_surface].min()\n\n        else:\n            heights = np.zeros(shifted_slab.shape[:2])\n            inds = np.zeros(shifted_slab.shape[:2], dtype=bool)\n            for i in range(1, shifted_slab.shape[-1]):\n                points = inds &lt; (shifted_slab[:,:,i] &gt; current)\n                x1 = shifted_slab[points, i-1]\n                x2 = shifted_slab[points, i]\n                y1 = shifted_cvals[i-1]\n                y2 = shifted_cvals[i]\n                heights[points] = self._interp(\n                    x=current,\n                    x1=x1,\n                    x2=x2,\n                    y1=y1,\n                    y2=y2,\n                )\n                inds[points] = True\n\n            heights[heights &gt;= self.top_surface] = heights[heights &lt; self.top_surface].min()\n\n        return heights\n\n    def _generate_supercell(self, x, y, Z, scaling_matrix=[8,8]):\n        x = np.concatenate([x + i for i in range(scaling_matrix[0])])\n        y = np.concatenate([y + i for i in range(scaling_matrix[1])])\n        Z = np.hstack([\n            np.vstack([Z for _ in range(scaling_matrix[0])]) for _ in range(scaling_matrix[1])\n        ])\n        return x, y, Z\n\n    def _get_intercept(self, midpoint, vector):\n        if vector[0] == 0:\n            intersect = [0, midpoint[1]]\n        else:\n            slope = vector[1] / vector[0]\n            f = ((slope * midpoint[1]) + midpoint[0])/ ((slope**2) + 1)\n            intersect = [f, slope * f]\n\n        return intersect\n\n    def _get_ratio(self, a, b):\n        a_norm = np.linalg.norm(a)\n        b_norm = np.linalg.norm(b)\n        ratio_array = np.ones(2)\n        min_ind = np.argmin([a_norm, b_norm])\n        ratio = np.max([a_norm, b_norm]) / np.min([a_norm, b_norm])\n        ratio_array[min_ind] = ratio\n\n        return ratio_array\n\n    def _get_square(self, a, b):\n        midpoint = 0.5 * (a + b)\n        a_inter = self._get_intercept(midpoint, a)\n        b_inter = self._get_intercept(midpoint, b)\n        a_len = np.linalg.norm(a_inter - midpoint)\n        b_len = np.linalg.norm(b_inter - midpoint)\n\n        r = np.min([a_len, b_len])\n\n        box_length = (2 * r) / np.sqrt(2)\n\n        return box_length, midpoint\n\n    def _get_scaling_matrix(self, a, b, scan_size=40):\n        final_box_length = 0\n        final_midpoint = np.zeros(2)\n        ratio = self._get_ratio(a, b)\n        scaling_matrix = np.ones(2)\n        i = 1\n        while final_box_length &lt;= scan_size:\n            i += 1\n            a_new = a * int(i * ratio[0])\n            b_new = b * int(i * ratio[1])\n            box_length, midpoint = self._get_square(a_new, b_new)\n            final_box_length = box_length\n            final_midpoint = midpoint\n            scaling_matrix[0] = int(i * ratio[0])\n            scaling_matrix[1] = int(i * ratio[1])\n\n        return scaling_matrix.astype(int), midpoint\n\n    def _run_constant_current_scan(self, current, structure, top=True, scan_size=40):\n        scaling_matrix, midpoint = self._get_scaling_matrix(\n            a=structure.lattice.matrix[0,:2],\n            b=structure.lattice.matrix[1,:2],\n            scan_size=scan_size,\n        )\n        Z = self._get_constant_current_isosurface(current, top=top)\n        if top:\n            Z = np.abs(Z - self.top_surface)\n        else:\n            Z = np.abs(Z - self.bottom_surface)\n\n        x, y, Z = self._generate_supercell(\n            self.a_vals,\n            self.b_vals,\n            Z,\n            scaling_matrix=scaling_matrix,\n        )\n\n        X, Y = np.meshgrid(x, y)\n\n        conv_input = np.c_[np.ravel(X), np.ravel(Y), np.ravel(Z)]\n        converted = structure.lattice.get_cartesian_coords(conv_input)\n        X_conv, Y_conv, Z_conv = converted[:,0], converted[:,1], converted[:,2]\n        X_conv = X_conv.reshape(X.shape)\n        Y_conv = Y_conv.reshape(Y.shape)\n        Z_conv = Z_conv.reshape(Z.shape)\n        shifted_point = midpoint - (scan_size / 2)\n        X_conv -= shifted_point[0]\n        Y_conv -= shifted_point[1]\n\n        return X_conv, Y_conv, Z_conv, midpoint, scaling_matrix\n\n    def _plot_stm_general(\n        self,\n        ax,\n        X,\n        Y,\n        Z,\n        cmap,\n    ):\n        ax.pcolormesh(\n            X,\n            Y,\n            Z.T,\n            shading='gouraud',\n            cmap=cmap,\n            norm=Normalize(vmin=Z.min(), vmax=Z.max()),\n            rasterized=True,\n            antialiased=True,\n        )\n\n    def _plot_atoms_general(\n        self,\n        ax,\n        atol,\n        max_bond_length,\n        atom_size,\n        bond_line_width,\n        scaling_matrix,\n        midpoint,\n        scan_size,\n        legend,\n        top,\n        structure,\n        atom_axis_bounds,\n        atoms_box,\n        legend_atom_size,\n        custom_color_dict=None,\n    ):\n        supercell = make_supercell(\n            structure,\n            scaling_matrix=np.hstack([scaling_matrix, 1]),\n        )\n        inds, heights = group_layers(supercell, atol=atol)\n\n        if top:\n            surface_inds = inds[-1]\n        else:\n            surface_inds = inds[0]\n\n        surface_atom_coords = supercell.cart_coords[surface_inds]\n        surface_atom_symbols = np.array(supercell.species, dtype='str')[surface_inds]\n        surface_atom_species = np.zeros(surface_atom_symbols.shape, dtype=int)\n        surface_atom_sizes = np.zeros(surface_atom_symbols.shape, dtype=float)\n        unique_species = np.unique(surface_atom_symbols)\n        unique_elements = [Element(i) for i in unique_species]\n        unique_zs = [Element(i).Z for i in unique_species]\n\n        for i, z in enumerate(unique_elements):\n            surface_atom_species[np.isin(surface_atom_symbols, unique_species[i])] = z.Z\n            surface_atom_sizes[np.isin(surface_atom_symbols, unique_species[i])] = z.atomic_radius\n\n        surface_atom_sizes /= surface_atom_sizes.max()\n\n        if custom_color_dict is not None:\n            for element in custom_color_dict:\n                z = Element(element).Z\n                jmol_colors[z] = np.array(custom_color_dict[element]) / 255\n\n        colors = jmol_colors[surface_atom_species]\n\n        shifted_point = midpoint - (scan_size / 2)\n        surface_atom_coords[:,0] -= shifted_point[0]\n        surface_atom_coords[:,1] -= shifted_point[1]\n\n        neighbor_graph = radius_neighbors_graph(\n            X=surface_atom_coords,\n            radius=max_bond_length,\n        ).toarray()\n\n        bonds = []\n\n        for i in range(neighbor_graph.shape[0]):\n            for j in range(neighbor_graph.shape[0]):\n                if neighbor_graph[i,j] &gt; 0:\n                    to_append = [\n                        surface_atom_coords[i],\n                        surface_atom_coords[j],\n                        [np.nan, np.nan, np.nan],\n                    ]\n                    bonds.append(to_append)\n\n        bonds = np.vstack(bonds)\n\n        ax_atoms = ax.inset_axes(\n            bounds=atom_axis_bounds,\n        )\n        ax_atoms.set_xlim(\n            atom_axis_bounds[0] * scan_size,\n            (atom_axis_bounds[0] + atom_axis_bounds[2]) * scan_size\n        )\n        ax_atoms.set_ylim(\n            atom_axis_bounds[1] * scan_size,\n            (atom_axis_bounds[1] + atom_axis_bounds[3]) * scan_size\n        )\n        ax_atoms.set_facecolor((0,0,0,0))\n\n        ax_atoms.tick_params(\n            bottom=False,\n            left=False,\n            labelbottom=False,\n            labelleft=False,\n        )\n\n        if not atoms_box:\n            ax_atoms.spines['left'].set_visible(False)\n            ax_atoms.spines['right'].set_visible(False)\n            ax_atoms.spines['top'].set_visible(False)\n            ax_atoms.spines['bottom'].set_visible(False)\n\n        ax_atoms.plot(\n            bonds[:,0],\n            bonds[:,1],\n            color='lightgrey',\n            linewidth=bond_line_width,\n            zorder=5,\n            path_effects=[pa.Stroke(linewidth=bond_line_width+2, foreground='black'), pa.Normal()],\n        )\n        ax_atoms.scatter(\n            surface_atom_coords[:,0],\n            surface_atom_coords[:,1],\n            c=colors,\n            ec='black',\n            s=atom_size*surface_atom_sizes,\n            zorder=10,\n        )\n\n        if legend:\n            legend_lines = []\n            legend_labels = []\n            for name, color, element in zip(unique_species, jmol_colors[unique_zs], unique_elements):\n                legend_lines.append(plt.scatter(\n                    [-1],\n                    [-1],\n                    color=color,\n                    s=legend_atom_size*element.atomic_radius,\n                    ec='black',\n                ))\n                legend_labels.append(\n                    f'{name}'\n                )\n\n            leg = ax.get_legend()\n\n            if leg is None:\n                handles = legend_lines\n                labels = legend_labels\n            else:\n                handles = [l._legmarker for l in leg.legendHandles]\n                labels = [text._text for text in leg.texts]\n                handles.extend(legend_lines)\n                labels.extend(legend_labels)\n\n            l = ax.legend(\n                handles,\n                labels,\n                ncol=1,\n                loc='upper right',\n                framealpha=1,\n                fontsize=16,\n            )\n            l.set_zorder(200)\n            frame = l.get_frame()\n            frame.set_facecolor('white')\n            frame.set_edgecolor('black')\n\n    def add_scale_bar(\n        self,\n        ax,\n        width,\n        height,\n        offset_x=1,\n        offset_y=1,\n        units='nm',\n        color='white',\n        border_color='black',\n        border_width=0.75,\n        fontsize=16,\n    ):\n        rect = Rectangle(\n            xy=(offset_x, offset_y),\n            width=width,\n            height=height,\n            facecolor=color,\n            edgecolor=border_color,\n            linewidth=border_width,\n            zorder=100,\n        )\n        if units == 'nm':\n            annotation = f'{np.round(width / 10, 2)} nm'\n        elif units == 'A':\n            annotation = f'${width} \\\\AA$'\n        else:\n            raise('Please select proper units, either \"nm\" (nanometers) or \"A\" (angstroms)')\n\n        ax.annotate(\n            annotation,\n            xy=(offset_x + (width / 2), offset_y + (1.05 * height)),\n            xycoords='data',\n            ha='center',\n            va='bottom',\n            color=color,\n            fontsize=fontsize,\n            fontweight='bold',\n            path_effects=[pa.Stroke(linewidth=border_width, foreground=border_color)],\n            zorder=100,\n        )\n        ax.add_patch(rect)\n\n\n    def plot_constant_current(\n        self,\n        ax,\n        current,\n        top=True,\n        scan_size=40,\n        atol=0.03,\n        plot_atoms=False,\n        atom_size=80,\n        legend_atom_size=100,\n        bond_line_width=2,\n        max_bond_length=3.14,\n        cmap='hot',\n        sigma=4,\n        legend=False,\n        rotation=0,\n        atom_axis_bounds=[0.5,0.0,0.5,0.5],\n        atoms_box=False,\n        custom_color_dict=None,\n    ):\n        if rotation != 0:\n            structure = self._rotate_structure(self.poscar.structure, angle=rotation)\n        else:\n            structure = self.poscar.structure\n\n        X, Y, Z, midpoint, scaling_matrix = self._run_constant_current_scan(\n            current=current,\n            structure=structure,\n            top=top,\n            scan_size=scan_size,\n        )\n        Z = gaussian_filter(Z, sigma=sigma)\n        shifted_midpoint = midpoint - (scan_size / 2)\n\n        ax.set_xlim(0, scan_size)\n        ax.set_ylim(0, scan_size)\n\n        self._plot_stm_general(\n            ax=ax,\n            X=X,\n            Y=Y,\n            Z=Z,\n            cmap=cmap,\n        )\n\n        if plot_atoms:\n            self._plot_atoms_general(\n                ax=ax,\n                atol=atol,\n                max_bond_length=max_bond_length,\n                atom_size=atom_size,\n                bond_line_width=bond_line_width,\n                scaling_matrix=scaling_matrix,\n                midpoint=midpoint,\n                scan_size=scan_size,\n                legend=legend,\n                top=top,\n                structure=structure,\n                atom_axis_bounds=atom_axis_bounds,\n                atoms_box=atoms_box,\n                legend_atom_size=legend_atom_size,\n                custom_color_dict=custom_color_dict,\n            )\n</code></pre>"}]}